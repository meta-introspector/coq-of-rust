(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module macros.
  
End macros.

Module errno.
  (*
          unsafe fn errno_location() -> *mut c_int {
              unsafe { libc::__errno_location() }
          }
  *)
  Definition errno_location : M (mut_ref ltac:(libc.unix.c_int)) :=
    M.call libc.unix.linux_like.linux.__errno_location.
  
  (*
  pub fn errno() -> i32 {
      Errno::last_raw()
  }
  *)
  Definition errno : M i32.t := M.call nix.errno.consts.Errno.t::["last_raw"].
  
  Module  Impl_nix_errno_consts_Errno_t.
  Section Impl_nix_errno_consts_Errno_t.
    Definition Self : Set := nix.errno.consts.Errno.t.
    
    (*
        pub fn last() -> Self {
            Self::from_raw(Self::last_raw())
        }
    *)
    Definition last : M Self :=
      let* α0 : i32.t := M.call nix.errno.consts.Errno.t::["last_raw"] in
      M.call (nix.errno.consts.Errno.t::["from_raw"] α0).
    
    Global Instance AssociatedFunction_last :
      Notations.DoubleColon Self "last" := {
      Notations.double_colon := last;
    }.
    
    (*
        pub fn last_raw() -> i32 {
            unsafe { *errno_location() }
        }
    *)
    Definition last_raw : M i32.t :=
      let* α0 : mut_ref i32.t := M.call nix.errno.errno_location in
      M.read (deref α0).
    
    Global Instance AssociatedFunction_last_raw :
      Notations.DoubleColon Self "last_raw" := {
      Notations.double_colon := last_raw;
    }.
    
    (*
        pub fn set(self) {
            Self::set_raw(self as i32)
        }
    *)
    Definition set (self : Self) : M unit :=
      let* self := M.alloc self in
      let* α0 : nix.errno.consts.Errno.t := M.read self in
      M.call (nix.errno.consts.Errno.t::["set_raw"] (rust_cast α0)).
    
    Global Instance AssociatedFunction_set :
      Notations.DoubleColon Self "set" := {
      Notations.double_colon := set;
    }.
    
    (*
        pub fn set_raw(errno: i32) {
            // Safe because errno is a thread-local variable
            unsafe {
                *errno_location() = errno;
            }
        }
    *)
    Definition set_raw (errno : i32.t) : M unit :=
      let* errno := M.alloc errno in
      let* _ : M.Val unit :=
        let* α0 : mut_ref i32.t := M.call nix.errno.errno_location in
        let* α1 : i32.t := M.read errno in
        assign (deref α0) α1 in
      let* α0 : M.Val unit := M.alloc tt in
      M.read α0.
    
    Global Instance AssociatedFunction_set_raw :
      Notations.DoubleColon Self "set_raw" := {
      Notations.double_colon := set_raw;
    }.
    
    (*
        pub const fn from_i32(err: i32) -> Errno {
            Self::from_raw(err)
        }
    *)
    Definition from_i32 (err : i32.t) : M nix.errno.consts.Errno.t :=
      let* err := M.alloc err in
      let* α0 : i32.t := M.read err in
      M.call (nix.errno.consts.Errno.t::["from_raw"] α0).
    
    Global Instance AssociatedFunction_from_i32 :
      Notations.DoubleColon Self "from_i32" := {
      Notations.double_colon := from_i32;
    }.
    
    (*
        pub const fn from_raw(err: i32) -> Errno {
            #[allow(deprecated)]
            from_i32(err)
        }
    *)
    Definition from_raw (err : i32.t) : M nix.errno.consts.Errno.t :=
      let* err := M.alloc err in
      let* α0 : i32.t := M.read err in
      M.call (nix.errno.consts.from_i32 α0).
    
    Global Instance AssociatedFunction_from_raw :
      Notations.DoubleColon Self "from_raw" := {
      Notations.double_colon := from_raw;
    }.
    
    (*
        pub fn desc(self) -> &'static str {
            desc(self)
        }
    *)
    Definition desc (self : Self) : M (ref str.t) :=
      let* self := M.alloc self in
      let* α0 : nix.errno.consts.Errno.t := M.read self in
      M.call (nix.errno.desc α0).
    
    Global Instance AssociatedFunction_desc :
      Notations.DoubleColon Self "desc" := {
      Notations.double_colon := desc;
    }.
    
    (*
        pub fn clear() {
            Self::set_raw(0)
        }
    *)
    Definition clear : M unit :=
      M.call (nix.errno.consts.Errno.t::["set_raw"] ((Integer.of_Z 0) : i32.t)).
    
    Global Instance AssociatedFunction_clear :
      Notations.DoubleColon Self "clear" := {
      Notations.double_colon := clear;
    }.
    
    (*
        pub fn result<S: ErrnoSentinel + PartialEq<S>>(value: S) -> Result<S> {
            if value == S::sentinel() {
                Err(Self::last())
            } else {
                Ok(value)
            }
        }
    *)
    Definition result {S : Set} (value : S) : M ltac:(nix.Result S) :=
      let* value := M.alloc value in
      let* α0 : (ref S) -> (ref S) -> M bool.t :=
        ltac:(M.get_method (fun ℐ =>
          core.cmp.PartialEq.eq (Self := S) (Rhs := S) (Trait := ℐ))) in
      let* α1 : M S :=
        ltac:(M.get_method (fun ℐ =>
          nix.errno.ErrnoSentinel.sentinel (Self := S) (Trait := ℐ))) in
      let* α2 : S := M.call α1 in
      let* α3 : M.Val S := M.alloc α2 in
      let* α4 : bool.t := M.call (α0 (borrow value) (borrow α3)) in
      let* α5 : M.Val bool.t := M.alloc α4 in
      let* α6 : bool.t := M.read (use α5) in
      let* α7 : M.Val (core.result.Result.t S nix.errno.consts.Errno.t) :=
        if α6 then
          let* α0 : nix.errno.consts.Errno.t :=
            M.call nix.errno.consts.Errno.t::["last"] in
          M.alloc (core.result.Result.Err α0)
        else
          let* α0 : S := M.read value in
          M.alloc (core.result.Result.Ok α0) in
      M.read α7.
    
    Global Instance AssociatedFunction_result {S : Set} :
      Notations.DoubleColon Self "result" := {
      Notations.double_colon := result (S := S);
    }.
  End Impl_nix_errno_consts_Errno_t.
  End Impl_nix_errno_consts_Errno_t.
  
  Module  ErrnoSentinel.
  Section ErrnoSentinel.
    Class Trait (Self : Set) : Type := {
      sentinel : M Self;
    }.
    
  End ErrnoSentinel.
  End ErrnoSentinel.
  
  Module  Impl_nix_errno_ErrnoSentinel_for_isize_t.
  Section Impl_nix_errno_ErrnoSentinel_for_isize_t.
    Definition Self : Set := isize.t.
    
    (*
        fn sentinel() -> Self {
            -1
        }
    *)
    Definition sentinel : M Self := M.pure ((Integer.of_Z (-1)) : isize.t).
    
    Global Instance AssociatedFunction_sentinel :
      Notations.DoubleColon Self "sentinel" := {
      Notations.double_colon := sentinel;
    }.
    
    Global Instance ℐ : nix.errno.ErrnoSentinel.Trait Self := {
      nix.errno.ErrnoSentinel.sentinel := sentinel;
    }.
  End Impl_nix_errno_ErrnoSentinel_for_isize_t.
  End Impl_nix_errno_ErrnoSentinel_for_isize_t.
  
  Module  Impl_nix_errno_ErrnoSentinel_for_i32_t.
  Section Impl_nix_errno_ErrnoSentinel_for_i32_t.
    Definition Self : Set := i32.t.
    
    (*
        fn sentinel() -> Self {
            -1
        }
    *)
    Definition sentinel : M Self := M.pure ((Integer.of_Z (-1)) : i32.t).
    
    Global Instance AssociatedFunction_sentinel :
      Notations.DoubleColon Self "sentinel" := {
      Notations.double_colon := sentinel;
    }.
    
    Global Instance ℐ : nix.errno.ErrnoSentinel.Trait Self := {
      nix.errno.ErrnoSentinel.sentinel := sentinel;
    }.
  End Impl_nix_errno_ErrnoSentinel_for_i32_t.
  End Impl_nix_errno_ErrnoSentinel_for_i32_t.
  
  Module  Impl_nix_errno_ErrnoSentinel_for_i64_t.
  Section Impl_nix_errno_ErrnoSentinel_for_i64_t.
    Definition Self : Set := i64.t.
    
    (*
        fn sentinel() -> Self {
            -1
        }
    *)
    Definition sentinel : M Self := M.pure ((Integer.of_Z (-1)) : i64.t).
    
    Global Instance AssociatedFunction_sentinel :
      Notations.DoubleColon Self "sentinel" := {
      Notations.double_colon := sentinel;
    }.
    
    Global Instance ℐ : nix.errno.ErrnoSentinel.Trait Self := {
      nix.errno.ErrnoSentinel.sentinel := sentinel;
    }.
  End Impl_nix_errno_ErrnoSentinel_for_i64_t.
  End Impl_nix_errno_ErrnoSentinel_for_i64_t.
  
  Module  Impl_nix_errno_ErrnoSentinel_for_mut_ref_core_ffi_c_void_t.
  Section Impl_nix_errno_ErrnoSentinel_for_mut_ref_core_ffi_c_void_t.
    Definition Self : Set := mut_ref core.ffi.c_void.t.
    
    (*
        fn sentinel() -> Self {
            -1isize as *mut c_void
        }
    *)
    Definition sentinel : M Self :=
      M.pure (rust_cast ((Integer.of_Z (-1)) : isize.t)).
    
    Global Instance AssociatedFunction_sentinel :
      Notations.DoubleColon Self "sentinel" := {
      Notations.double_colon := sentinel;
    }.
    
    Global Instance ℐ : nix.errno.ErrnoSentinel.Trait Self := {
      nix.errno.ErrnoSentinel.sentinel := sentinel;
    }.
  End Impl_nix_errno_ErrnoSentinel_for_mut_ref_core_ffi_c_void_t.
  End Impl_nix_errno_ErrnoSentinel_for_mut_ref_core_ffi_c_void_t.
  
  Module  Impl_nix_errno_ErrnoSentinel_for_libc_unix_sighandler_t.
  Section Impl_nix_errno_ErrnoSentinel_for_libc_unix_sighandler_t.
    Definition Self : Set := ltac:(libc.unix.sighandler_t).
    
    (*
        fn sentinel() -> Self {
            libc::SIG_ERR
        }
    *)
    Definition sentinel : M Self := M.read libc.unix.SIG_ERR.
    
    Global Instance AssociatedFunction_sentinel :
      Notations.DoubleColon Self "sentinel" := {
      Notations.double_colon := sentinel;
    }.
    
    Global Instance ℐ : nix.errno.ErrnoSentinel.Trait Self := {
      nix.errno.ErrnoSentinel.sentinel := sentinel;
    }.
  End Impl_nix_errno_ErrnoSentinel_for_libc_unix_sighandler_t.
  End Impl_nix_errno_ErrnoSentinel_for_libc_unix_sighandler_t.
  
  Module  Impl_core_error_Error_for_nix_errno_consts_Errno_t.
  Section Impl_core_error_Error_for_nix_errno_consts_Errno_t.
    Definition Self : Set := nix.errno.consts.Errno.t.
    
    Global Instance ℐ : core.error.Error.Required.Trait Self := {
      core.error.Error.source := Datatypes.None;
      core.error.Error.type_id := Datatypes.None;
      core.error.Error.description := Datatypes.None;
      core.error.Error.cause := Datatypes.None;
      core.error.Error.provide := Datatypes.None;
    }.
  End Impl_core_error_Error_for_nix_errno_consts_Errno_t.
  End Impl_core_error_Error_for_nix_errno_consts_Errno_t.
  
  Module  Impl_core_fmt_Display_for_nix_errno_consts_Errno_t.
  Section Impl_core_fmt_Display_for_nix_errno_consts_Errno_t.
    Definition Self : Set := nix.errno.consts.Errno.t.
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{:?}: {}", self, self.desc())
        }
    *)
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter.t)
        : M ltac:(core.fmt.Result) :=
      let* self := M.alloc self in
      let* f := M.alloc f in
      let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
      let* α1 : ref str.t := M.read (mk_str "") in
      let* α2 : ref str.t := M.read (mk_str ": ") in
      let* α3 : M.Val (array (ref str.t)) := M.alloc [ α1; α2 ] in
      let* α4 : core.fmt.rt.Argument.t :=
        M.call (core.fmt.rt.Argument.t::["new_debug"] (borrow self)) in
      let* α5 : ref nix.errno.consts.Errno.t := M.read self in
      let* α6 : nix.errno.consts.Errno.t := M.read (deref α5) in
      let* α7 : ref str.t := M.call (nix.errno.consts.Errno.t::["desc"] α6) in
      let* α8 : M.Val (ref str.t) := M.alloc α7 in
      let* α9 : core.fmt.rt.Argument.t :=
        M.call (core.fmt.rt.Argument.t::["new_display"] (borrow α8)) in
      let* α10 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α4; α9 ] in
      let* α11 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_v1"]
            (pointer_coercion "Unsize" (borrow α3))
            (pointer_coercion "Unsize" (borrow α10))) in
      M.call (core.fmt.Formatter.t::["write_fmt"] α0 α11).
    
    Global Instance AssociatedFunction_fmt :
      Notations.DoubleColon Self "fmt" := {
      Notations.double_colon := fmt;
    }.
    
    Global Instance ℐ : core.fmt.Display.Trait Self := {
      core.fmt.Display.fmt := fmt;
    }.
  End Impl_core_fmt_Display_for_nix_errno_consts_Errno_t.
  End Impl_core_fmt_Display_for_nix_errno_consts_Errno_t.
  
  Module  Impl_core_convert_From_nix_errno_consts_Errno_t_for_std_io_error_Error_t.
  Section Impl_core_convert_From_nix_errno_consts_Errno_t_for_std_io_error_Error_t.
    Definition Self : Set := std.io.error.Error.t.
    
    (*
        fn from(err: Errno) -> Self {
            io::Error::from_raw_os_error(err as i32)
        }
    *)
    Definition from (err : nix.errno.consts.Errno.t) : M Self :=
      let* err := M.alloc err in
      let* α0 : nix.errno.consts.Errno.t := M.read err in
      M.call (std.io.error.Error.t::["from_raw_os_error"] (rust_cast α0)).
    
    Global Instance AssociatedFunction_from :
      Notations.DoubleColon Self "from" := {
      Notations.double_colon := from;
    }.
    
    Global Instance ℐ :
      core.convert.From.Trait Self (T := nix.errno.consts.Errno.t) := {
      core.convert.From.from := from;
    }.
  End Impl_core_convert_From_nix_errno_consts_Errno_t_for_std_io_error_Error_t.
  End Impl_core_convert_From_nix_errno_consts_Errno_t_for_std_io_error_Error_t.
  
  Module  Impl_core_convert_TryFrom_std_io_error_Error_t_for_nix_errno_consts_Errno_t.
  Section Impl_core_convert_TryFrom_std_io_error_Error_t_for_nix_errno_consts_Errno_t.
    Definition Self : Set := nix.errno.consts.Errno.t.
    
    (*
        type Error = io::Error;
    *)
    Definition Error : Set := std.io.error.Error.t.
    
    (*
        fn try_from(ioerror: io::Error) -> std::result::Result<Self, io::Error> {
            ioerror.raw_os_error().map(Errno::from_raw).ok_or(ioerror)
        }
    *)
    Definition try_from
        (ioerror : std.io.error.Error.t)
        : M (core.result.Result.t Self std.io.error.Error.t) :=
      let* ioerror := M.alloc ioerror in
      let* α0 : core.option.Option.t i32.t :=
        M.call (std.io.error.Error.t::["raw_os_error"] (borrow ioerror)) in
      let* α1 : core.option.Option.t nix.errno.consts.Errno.t :=
        M.call
          ((core.option.Option.t i32.t)::["map"]
            α0
            nix.errno.consts.Errno.t::["from_raw"]) in
      let* α2 : std.io.error.Error.t := M.read ioerror in
      M.call ((core.option.Option.t nix.errno.consts.Errno.t)::["ok_or"] α1 α2).
    
    Global Instance AssociatedFunction_try_from :
      Notations.DoubleColon Self "try_from" := {
      Notations.double_colon := try_from;
    }.
    
    Global Instance ℐ :
      core.convert.TryFrom.Trait Self (T := std.io.error.Error.t) := {
      core.convert.TryFrom.Error := Error;
      core.convert.TryFrom.try_from := try_from;
    }.
  End Impl_core_convert_TryFrom_std_io_error_Error_t_for_nix_errno_consts_Errno_t.
  End Impl_core_convert_TryFrom_std_io_error_Error_t_for_nix_errno_consts_Errno_t.
  
  (*
  fn desc(errno: Errno) -> &'static str {
      use self::Errno::*;
      match errno {
          UnknownErrno => "Unknown errno",
          EPERM => "Operation not permitted",
          ENOENT => "No such file or directory",
          ESRCH => "No such process",
          EINTR => "Interrupted system call",
          EIO => "I/O error",
          ENXIO => "No such device or address",
          E2BIG => "Argument list too long",
          ENOEXEC => "Exec format error",
          EBADF => "Bad file number",
          ECHILD => "No child processes",
          EAGAIN => "Try again",
          ENOMEM => "Out of memory",
          EACCES => "Permission denied",
          EFAULT => "Bad address",
          #[cfg(not(target_os = "haiku"))]
          ENOTBLK => "Block device required",
          EBUSY => "Device or resource busy",
          EEXIST => "File exists",
          EXDEV => "Cross-device link",
          ENODEV => "No such device",
          ENOTDIR => "Not a directory",
          EISDIR => "Is a directory",
          EINVAL => "Invalid argument",
          ENFILE => "File table overflow",
          EMFILE => "Too many open files",
          ENOTTY => "Not a typewriter",
          ETXTBSY => "Text file busy",
          EFBIG => "File too large",
          ENOSPC => "No space left on device",
          ESPIPE => "Illegal seek",
          EROFS => "Read-only file system",
          EMLINK => "Too many links",
          EPIPE => "Broken pipe",
          EDOM => "Math argument out of domain of func",
          ERANGE => "Math result not representable",
          EDEADLK => "Resource deadlock would occur",
          ENAMETOOLONG => "File name too long",
          ENOLCK => "No record locks available",
          ENOSYS => "Function not implemented",
          ENOTEMPTY => "Directory not empty",
          ELOOP => "Too many symbolic links encountered",
          ENOMSG => "No message of desired type",
          EIDRM => "Identifier removed",
          EINPROGRESS => "Operation now in progress",
          EALREADY => "Operation already in progress",
          ENOTSOCK => "Socket operation on non-socket",
          EDESTADDRREQ => "Destination address required",
          EMSGSIZE => "Message too long",
          EPROTOTYPE => "Protocol wrong type for socket",
          ENOPROTOOPT => "Protocol not available",
          EPROTONOSUPPORT => "Protocol not supported",
          #[cfg(not(target_os = "haiku"))]
          ESOCKTNOSUPPORT => "Socket type not supported",
          #[cfg(not(target_os = "haiku"))]
          EPFNOSUPPORT => "Protocol family not supported",
          #[cfg(not(target_os = "haiku"))]
          EAFNOSUPPORT => "Address family not supported by protocol",
          EADDRINUSE => "Address already in use",
          EADDRNOTAVAIL => "Cannot assign requested address",
          ENETDOWN => "Network is down",
          ENETUNREACH => "Network is unreachable",
          ENETRESET => "Network dropped connection because of reset",
          ECONNABORTED => "Software caused connection abort",
          ECONNRESET => "Connection reset by peer",
          ENOBUFS => "No buffer space available",
          EISCONN => "Transport endpoint is already connected",
          ENOTCONN => "Transport endpoint is not connected",
          ESHUTDOWN => "Cannot send after transport endpoint shutdown",
          #[cfg(not(target_os = "haiku"))]
          ETOOMANYREFS => "Too many references: cannot splice",
          ETIMEDOUT => "Connection timed out",
          ECONNREFUSED => "Connection refused",
          EHOSTDOWN => "Host is down",
          EHOSTUNREACH => "No route to host",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          ECHRNG => "Channel number out of range",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EL2NSYNC => "Level 2 not synchronized",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EL3HLT => "Level 3 halted",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EL3RST => "Level 3 reset",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          ELNRNG => "Link number out of range",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EUNATCH => "Protocol driver not attached",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          ENOCSI => "No CSI structure available",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EL2HLT => "Level 2 halted",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBADE => "Invalid exchange",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBADR => "Invalid request descriptor",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EXFULL => "Exchange full",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ENOANO => "No anode",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBADRQC => "Invalid request code",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBADSLT => "Invalid slot",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBFONT => "Bad font file format",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          ENOSTR => "Device not a stream",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          ENODATA => "No data available",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          ETIME => "Timer expired",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          ENOSR => "Out of streams resources",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ENONET => "Machine is not on the network",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ENOPKG => "Package not installed",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          EREMOTE => "Object is remote",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          ENOLINK => "Link has been severed",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EADV => "Advertise error",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ESRMNT => "Srmount error",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ECOMM => "Communication error on send",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia",
          ))]
          EPROTO => "Protocol error",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          EMULTIHOP => "Multihop attempted",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EDOTDOT => "RFS specific error",
  
          #[cfg(any(linux_android, target_os = "aix", target_os = "fuchsia"))]
          EBADMSG => "Not a data message",
  
          #[cfg(solarish)]
          EBADMSG => "Trying to read unreadable message",
  
          #[cfg(any(
              linux_android,
              target_os = "aix",
              target_os = "fuchsia",
              target_os = "haiku",
              target_os = "hurd"
          ))]
          EOVERFLOW => "Value too large for defined data type",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ENOTUNIQ => "Name not unique on network",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EBADFD => "File descriptor in bad state",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EREMCHG => "Remote address changed",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ELIBACC => "Can not access a needed shared library",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ELIBBAD => "Accessing a corrupted shared library",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ELIBSCN => ".lib section in a.out corrupted",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ELIBMAX => "Attempting to link in too many shared libraries",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          ELIBEXEC => "Cannot exec a shared library directly",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia",
              target_os = "openbsd"
          ))]
          EILSEQ => "Illegal byte sequence",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "aix",
              target_os = "fuchsia"
          ))]
          ERESTART => "Interrupted system call should be restarted",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          ESTRPIPE => "Streams pipe error",
  
          #[cfg(any(linux_android, solarish, target_os = "fuchsia"))]
          EUSERS => "Too many users",
  
          #[cfg(any(
              linux_android,
              target_os = "fuchsia",
              target_os = "netbsd",
              target_os = "redox"
          ))]
          EOPNOTSUPP => "Operation not supported on transport endpoint",
  
          #[cfg(any(linux_android, target_os = "fuchsia", target_os = "hurd"))]
          ESTALE => "Stale file handle",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EUCLEAN => "Structure needs cleaning",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          ENOTNAM => "Not a XENIX named type file",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          ENAVAIL => "No XENIX semaphores available",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EISNAM => "Is a named type file",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EREMOTEIO => "Remote I/O error",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EDQUOT => "Quota exceeded",
  
          #[cfg(any(
              linux_android,
              target_os = "fuchsia",
              target_os = "openbsd",
              target_os = "dragonfly"
          ))]
          ENOMEDIUM => "No medium found",
  
          #[cfg(any(
              linux_android,
              target_os = "fuchsia",
              target_os = "openbsd"
          ))]
          EMEDIUMTYPE => "Wrong medium type",
  
          #[cfg(any(
              linux_android,
              solarish,
              target_os = "fuchsia",
              target_os = "haiku"
          ))]
          ECANCELED => "Operation canceled",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          ENOKEY => "Required key not available",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EKEYEXPIRED => "Key has expired",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EKEYREVOKED => "Key has been revoked",
  
          #[cfg(any(linux_android, target_os = "fuchsia"))]
          EKEYREJECTED => "Key was rejected by service",
  
          #[cfg(any(
              linux_android,
              target_os = "aix",
              target_os = "fuchsia",
              target_os = "hurd"
          ))]
          EOWNERDEAD => "Owner died",
  
          #[cfg(solarish)]
          EOWNERDEAD => "Process died with lock",
  
          #[cfg(any(linux_android, target_os = "aix", target_os = "fuchsia"))]
          ENOTRECOVERABLE => "State not recoverable",
  
          #[cfg(solarish)]
          ENOTRECOVERABLE => "Lock is not recoverable",
  
          #[cfg(any(
              all(target_os = "linux", not(target_arch = "mips")),
              target_os = "fuchsia"
          ))]
          ERFKILL => "Operation not possible due to RF-kill",
  
          #[cfg(any(
              all(target_os = "linux", not(target_arch = "mips")),
              target_os = "fuchsia"
          ))]
          EHWPOISON => "Memory page has hardware error",
  
          #[cfg(freebsdlike)]
          EDOOFUS => "Programming error",
  
          #[cfg(any(freebsdlike, target_os = "hurd", target_os = "redox"))]
          EMULTIHOP => "Multihop attempted",
  
          #[cfg(any(freebsdlike, target_os = "hurd", target_os = "redox"))]
          ENOLINK => "Link has been severed",
  
          #[cfg(target_os = "freebsd")]
          ENOTCAPABLE => "Capabilities insufficient",
  
          #[cfg(target_os = "freebsd")]
          ECAPMODE => "Not permitted in capability mode",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          ENEEDAUTH => "Need authenticator",
  
          #[cfg(any(bsd, target_os = "redox", solarish))]
          EOVERFLOW => "Value too large to be stored in data type",
  
          #[cfg(any(
              freebsdlike,
              apple_targets,
              target_os = "netbsd",
              target_os = "redox",
              target_os = "haiku",
              target_os = "hurd"
          ))]
          EILSEQ => "Illegal byte sequence",
  
          #[cfg(any(bsd, target_os = "haiku"))]
          ENOATTR => "Attribute not found",
  
          #[cfg(any(
              bsd,
              target_os = "redox",
              target_os = "haiku",
              target_os = "hurd"
          ))]
          EBADMSG => "Bad message",
  
          #[cfg(any(
              bsd,
              target_os = "haiku",
              target_os = "hurd",
              target_os = "redox"
          ))]
          EPROTO => "Protocol error",
  
          #[cfg(any(
              freebsdlike,
              apple_targets,
              target_os = "openbsd",
              target_os = "hurd"
          ))]
          ENOTRECOVERABLE => "State not recoverable",
  
          #[cfg(any(freebsdlike, apple_targets, target_os = "openbsd"))]
          EOWNERDEAD => "Previous owner died",
  
          #[cfg(any(
              bsd,
              target_os = "aix",
              solarish,
              target_os = "haiku",
              target_os = "hurd"
          ))]
          ENOTSUP => "Operation not supported",
  
          #[cfg(any(bsd, target_os = "aix", target_os = "hurd"))]
          EPROCLIM => "Too many processes",
  
          #[cfg(any(
              bsd,
              target_os = "aix",
              target_os = "hurd",
              target_os = "redox"
          ))]
          EUSERS => "Too many users",
  
          #[cfg(any(
              bsd,
              solarish,
              target_os = "redox",
              target_os = "aix",
              target_os = "haiku",
              target_os = "hurd"
          ))]
          EDQUOT => "Disc quota exceeded",
  
          #[cfg(any(
              bsd,
              solarish,
              target_os = "redox",
              target_os = "aix",
              target_os = "haiku"
          ))]
          ESTALE => "Stale NFS file handle",
  
          #[cfg(any(bsd, target_os = "aix", target_os = "redox"))]
          EREMOTE => "Too many levels of remote in path",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EBADRPC => "RPC struct is bad",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          ERPCMISMATCH => "RPC version wrong",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EPROGUNAVAIL => "RPC prog. not avail",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EPROGMISMATCH => "Program version wrong",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EPROCUNAVAIL => "Bad procedure for program",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EFTYPE => "Inappropriate file type or format",
  
          #[cfg(any(bsd, target_os = "hurd"))]
          EAUTH => "Authentication error",
  
          #[cfg(any(
              bsd,
              target_os = "aix",
              target_os = "hurd",
              target_os = "redox"
          ))]
          ECANCELED => "Operation canceled",
  
          #[cfg(apple_targets)]
          EPWROFF => "Device power is off",
  
          #[cfg(apple_targets)]
          EDEVERR => "Device error, e.g. paper out",
  
          #[cfg(apple_targets)]
          EBADEXEC => "Bad executable",
  
          #[cfg(apple_targets)]
          EBADARCH => "Bad CPU type in executable",
  
          #[cfg(apple_targets)]
          ESHLIBVERS => "Shared library version mismatch",
  
          #[cfg(apple_targets)]
          EBADMACHO => "Malformed Macho file",
  
          #[cfg(any(apple_targets, target_os = "netbsd", target_os = "haiku"))]
          EMULTIHOP => "Reserved",
  
          #[cfg(any(
              apple_targets,
              target_os = "aix",
              target_os = "netbsd",
              target_os = "redox"
          ))]
          ENODATA => "No message available on STREAM",
  
          #[cfg(any(apple_targets, target_os = "netbsd", target_os = "haiku"))]
          ENOLINK => "Reserved",
  
          #[cfg(any(
              apple_targets,
              target_os = "aix",
              target_os = "netbsd",
              target_os = "redox"
          ))]
          ENOSR => "No STREAM resources",
  
          #[cfg(any(
              apple_targets,
              target_os = "aix",
              target_os = "netbsd",
              target_os = "redox"
          ))]
          ENOSTR => "Not a STREAM",
  
          #[cfg(any(
              apple_targets,
              target_os = "aix",
              target_os = "netbsd",
              target_os = "redox"
          ))]
          ETIME => "STREAM ioctl timeout",
  
          #[cfg(any(apple_targets, solarish, target_os = "aix"))]
          EOPNOTSUPP => "Operation not supported on socket",
  
          #[cfg(apple_targets)]
          ENOPOLICY => "No such policy registered",
  
          #[cfg(apple_targets)]
          EQFULL => "Interface output queue is full",
  
          #[cfg(any(target_os = "openbsd", target_os = "hurd"))]
          EOPNOTSUPP => "Operation not supported",
  
          #[cfg(target_os = "openbsd")]
          EIPSEC => "IPsec processing failure",
  
          #[cfg(target_os = "dragonfly")]
          EASYNC => "Async",
  
          #[cfg(solarish)]
          EDEADLOCK => "Resource deadlock would occur",
  
          #[cfg(solarish)]
          ELOCKUNMAPPED => "Locked lock was unmapped",
  
          #[cfg(solarish)]
          ENOTACTIVE => "Facility is not active",
  
          #[cfg(target_os = "hurd")]
          EBACKGROUND => "Inappropriate operation for background process",
  
          #[cfg(target_os = "hurd")]
          EDIED => "Translator died",
  
          #[cfg(target_os = "hurd")]
          EGREGIOUS => "You really blew it this time",
  
          #[cfg(target_os = "hurd")]
          EIEIO => "Computer bought the farm",
  
          #[cfg(target_os = "hurd")]
          EGRATUITOUS => "Gratuitous error",
      }
  }
  *)
  Definition desc (errno : nix.errno.consts.Errno.t) : M (ref str.t) :=
    let* errno := M.alloc errno in
    let* α0 : M.Val (ref str.t) :=
      match_operator
        errno
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.UnknownErrno =>
              M.pure (mk_str "Unknown errno")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPERM =>
              M.pure (mk_str "Operation not permitted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOENT =>
              M.pure (mk_str "No such file or directory")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESRCH => M.pure (mk_str "No such process")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EINTR =>
              M.pure (mk_str "Interrupted system call")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EIO => M.pure (mk_str "I/O error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENXIO =>
              M.pure (mk_str "No such device or address")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.E2BIG =>
              M.pure (mk_str "Argument list too long")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOEXEC =>
              M.pure (mk_str "Exec format error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADF => M.pure (mk_str "Bad file number")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECHILD =>
              M.pure (mk_str "No child processes")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EAGAIN => M.pure (mk_str "Try again")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOMEM => M.pure (mk_str "Out of memory")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EACCES =>
              M.pure (mk_str "Permission denied")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EFAULT => M.pure (mk_str "Bad address")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTBLK =>
              M.pure (mk_str "Block device required")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBUSY =>
              M.pure (mk_str "Device or resource busy")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EEXIST => M.pure (mk_str "File exists")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EXDEV =>
              M.pure (mk_str "Cross-device link")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENODEV => M.pure (mk_str "No such device")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTDIR =>
              M.pure (mk_str "Not a directory")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EISDIR => M.pure (mk_str "Is a directory")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EINVAL =>
              M.pure (mk_str "Invalid argument")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENFILE =>
              M.pure (mk_str "File table overflow")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EMFILE =>
              M.pure (mk_str "Too many open files")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTTY =>
              M.pure (mk_str "Not a typewriter")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ETXTBSY => M.pure (mk_str "Text file busy")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EFBIG => M.pure (mk_str "File too large")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOSPC =>
              M.pure (mk_str "No space left on device")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESPIPE => M.pure (mk_str "Illegal seek")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EROFS =>
              M.pure (mk_str "Read-only file system")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EMLINK => M.pure (mk_str "Too many links")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPIPE => M.pure (mk_str "Broken pipe")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EDOM =>
              M.pure (mk_str "Math argument out of domain of func")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ERANGE =>
              M.pure (mk_str "Math result not representable")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EDEADLK =>
              M.pure (mk_str "Resource deadlock would occur")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENAMETOOLONG =>
              M.pure (mk_str "File name too long")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOLCK =>
              M.pure (mk_str "No record locks available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOSYS =>
              M.pure (mk_str "Function not implemented")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTEMPTY =>
              M.pure (mk_str "Directory not empty")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELOOP =>
              M.pure (mk_str "Too many symbolic links encountered")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOMSG =>
              M.pure (mk_str "No message of desired type")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EIDRM =>
              M.pure (mk_str "Identifier removed")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EINPROGRESS =>
              M.pure (mk_str "Operation now in progress")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EALREADY =>
              M.pure (mk_str "Operation already in progress")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTSOCK =>
              M.pure (mk_str "Socket operation on non-socket")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EDESTADDRREQ =>
              M.pure (mk_str "Destination address required")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EMSGSIZE =>
              M.pure (mk_str "Message too long")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPROTOTYPE =>
              M.pure (mk_str "Protocol wrong type for socket")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOPROTOOPT =>
              M.pure (mk_str "Protocol not available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPROTONOSUPPORT =>
              M.pure (mk_str "Protocol not supported")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESOCKTNOSUPPORT =>
              M.pure (mk_str "Socket type not supported")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPFNOSUPPORT =>
              M.pure (mk_str "Protocol family not supported")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EAFNOSUPPORT =>
              M.pure (mk_str "Address family not supported by protocol")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EADDRINUSE =>
              M.pure (mk_str "Address already in use")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EADDRNOTAVAIL =>
              M.pure (mk_str "Cannot assign requested address")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENETDOWN =>
              M.pure (mk_str "Network is down")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENETUNREACH =>
              M.pure (mk_str "Network is unreachable")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENETRESET =>
              M.pure (mk_str "Network dropped connection because of reset")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECONNABORTED =>
              M.pure (mk_str "Software caused connection abort")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECONNRESET =>
              M.pure (mk_str "Connection reset by peer")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOBUFS =>
              M.pure (mk_str "No buffer space available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EISCONN =>
              M.pure (mk_str "Transport endpoint is already connected")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTCONN =>
              M.pure (mk_str "Transport endpoint is not connected")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESHUTDOWN =>
              M.pure (mk_str "Cannot send after transport endpoint shutdown")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ETOOMANYREFS =>
              M.pure (mk_str "Too many references: cannot splice")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ETIMEDOUT =>
              M.pure (mk_str "Connection timed out")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECONNREFUSED =>
              M.pure (mk_str "Connection refused")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EHOSTDOWN => M.pure (mk_str "Host is down")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EHOSTUNREACH =>
              M.pure (mk_str "No route to host")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECHRNG =>
              M.pure (mk_str "Channel number out of range")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EL2NSYNC =>
              M.pure (mk_str "Level 2 not synchronized")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EL3HLT => M.pure (mk_str "Level 3 halted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EL3RST => M.pure (mk_str "Level 3 reset")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELNRNG =>
              M.pure (mk_str "Link number out of range")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EUNATCH =>
              M.pure (mk_str "Protocol driver not attached")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOCSI =>
              M.pure (mk_str "No CSI structure available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EL2HLT => M.pure (mk_str "Level 2 halted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADE => M.pure (mk_str "Invalid exchange")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADR =>
              M.pure (mk_str "Invalid request descriptor")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EXFULL => M.pure (mk_str "Exchange full")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOANO => M.pure (mk_str "No anode")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADRQC =>
              M.pure (mk_str "Invalid request code")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADSLT => M.pure (mk_str "Invalid slot")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBFONT =>
              M.pure (mk_str "Bad font file format")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOSTR =>
              M.pure (mk_str "Device not a stream")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENODATA =>
              M.pure (mk_str "No data available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ETIME => M.pure (mk_str "Timer expired")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOSR =>
              M.pure (mk_str "Out of streams resources")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENONET =>
              M.pure (mk_str "Machine is not on the network")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOPKG =>
              M.pure (mk_str "Package not installed")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EREMOTE =>
              M.pure (mk_str "Object is remote")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOLINK =>
              M.pure (mk_str "Link has been severed")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EADV => M.pure (mk_str "Advertise error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESRMNT => M.pure (mk_str "Srmount error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECOMM =>
              M.pure (mk_str "Communication error on send")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EPROTO => M.pure (mk_str "Protocol error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EMULTIHOP =>
              M.pure (mk_str "Multihop attempted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EDOTDOT =>
              M.pure (mk_str "RFS specific error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADMSG =>
              M.pure (mk_str "Not a data message")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EOVERFLOW =>
              M.pure (mk_str "Value too large for defined data type")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTUNIQ =>
              M.pure (mk_str "Name not unique on network")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EBADFD =>
              M.pure (mk_str "File descriptor in bad state")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EREMCHG =>
              M.pure (mk_str "Remote address changed")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELIBACC =>
              M.pure (mk_str "Can not access a needed shared library")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELIBBAD =>
              M.pure (mk_str "Accessing a corrupted shared library")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELIBSCN =>
              M.pure (mk_str ".lib section in a.out corrupted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELIBMAX =>
              M.pure (mk_str "Attempting to link in too many shared libraries")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ELIBEXEC =>
              M.pure (mk_str "Cannot exec a shared library directly")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EILSEQ =>
              M.pure (mk_str "Illegal byte sequence")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ERESTART =>
              M.pure (mk_str "Interrupted system call should be restarted")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESTRPIPE =>
              M.pure (mk_str "Streams pipe error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EUSERS => M.pure (mk_str "Too many users")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EOPNOTSUPP =>
              M.pure (mk_str "Operation not supported on transport endpoint")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ESTALE =>
              M.pure (mk_str "Stale file handle")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EUCLEAN =>
              M.pure (mk_str "Structure needs cleaning")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTNAM =>
              M.pure (mk_str "Not a XENIX named type file")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENAVAIL =>
              M.pure (mk_str "No XENIX semaphores available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EISNAM =>
              M.pure (mk_str "Is a named type file")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EREMOTEIO =>
              M.pure (mk_str "Remote I/O error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EDQUOT => M.pure (mk_str "Quota exceeded")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOMEDIUM =>
              M.pure (mk_str "No medium found")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EMEDIUMTYPE =>
              M.pure (mk_str "Wrong medium type")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ECANCELED =>
              M.pure (mk_str "Operation canceled")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOKEY =>
              M.pure (mk_str "Required key not available")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EKEYEXPIRED =>
              M.pure (mk_str "Key has expired")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EKEYREVOKED =>
              M.pure (mk_str "Key has been revoked")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EKEYREJECTED =>
              M.pure (mk_str "Key was rejected by service")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EOWNERDEAD => M.pure (mk_str "Owner died")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ENOTRECOVERABLE =>
              M.pure (mk_str "State not recoverable")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.ERFKILL =>
              M.pure (mk_str "Operation not possible due to RF-kill")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | nix.errno.consts.Errno.EHWPOISON =>
              M.pure (mk_str "Memory page has hardware error")
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t))
        ] in
    M.read α0.
  
  Module consts.
    Module Errno.
      Inductive t : Set :=
      | UnknownErrno
      | EPERM
      | ENOENT
      | ESRCH
      | EINTR
      | EIO
      | ENXIO
      | E2BIG
      | ENOEXEC
      | EBADF
      | ECHILD
      | EAGAIN
      | ENOMEM
      | EACCES
      | EFAULT
      | ENOTBLK
      | EBUSY
      | EEXIST
      | EXDEV
      | ENODEV
      | ENOTDIR
      | EISDIR
      | EINVAL
      | ENFILE
      | EMFILE
      | ENOTTY
      | ETXTBSY
      | EFBIG
      | ENOSPC
      | ESPIPE
      | EROFS
      | EMLINK
      | EPIPE
      | EDOM
      | ERANGE
      | EDEADLK
      | ENAMETOOLONG
      | ENOLCK
      | ENOSYS
      | ENOTEMPTY
      | ELOOP
      | ENOMSG
      | EIDRM
      | ECHRNG
      | EL2NSYNC
      | EL3HLT
      | EL3RST
      | ELNRNG
      | EUNATCH
      | ENOCSI
      | EL2HLT
      | EBADE
      | EBADR
      | EXFULL
      | ENOANO
      | EBADRQC
      | EBADSLT
      | EBFONT
      | ENOSTR
      | ENODATA
      | ETIME
      | ENOSR
      | ENONET
      | ENOPKG
      | EREMOTE
      | ENOLINK
      | EADV
      | ESRMNT
      | ECOMM
      | EPROTO
      | EMULTIHOP
      | EDOTDOT
      | EBADMSG
      | EOVERFLOW
      | ENOTUNIQ
      | EBADFD
      | EREMCHG
      | ELIBACC
      | ELIBBAD
      | ELIBSCN
      | ELIBMAX
      | ELIBEXEC
      | EILSEQ
      | ERESTART
      | ESTRPIPE
      | EUSERS
      | ENOTSOCK
      | EDESTADDRREQ
      | EMSGSIZE
      | EPROTOTYPE
      | ENOPROTOOPT
      | EPROTONOSUPPORT
      | ESOCKTNOSUPPORT
      | EOPNOTSUPP
      | EPFNOSUPPORT
      | EAFNOSUPPORT
      | EADDRINUSE
      | EADDRNOTAVAIL
      | ENETDOWN
      | ENETUNREACH
      | ENETRESET
      | ECONNABORTED
      | ECONNRESET
      | ENOBUFS
      | EISCONN
      | ENOTCONN
      | ESHUTDOWN
      | ETOOMANYREFS
      | ETIMEDOUT
      | ECONNREFUSED
      | EHOSTDOWN
      | EHOSTUNREACH
      | EALREADY
      | EINPROGRESS
      | ESTALE
      | EUCLEAN
      | ENOTNAM
      | ENAVAIL
      | EISNAM
      | EREMOTEIO
      | EDQUOT
      | ENOMEDIUM
      | EMEDIUMTYPE
      | ECANCELED
      | ENOKEY
      | EKEYEXPIRED
      | EKEYREVOKED
      | EKEYREJECTED
      | EOWNERDEAD
      | ENOTRECOVERABLE
      | ERFKILL
      | EHWPOISON.
      
      Definition UnknownErrno_discriminant : isize.t := Integer.of_Z 0.
    End Errno.
    
    Module  Impl_core_clone_Clone_for_nix_errno_consts_Errno_t.
    Section Impl_core_clone_Clone_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      (*
          Clone
      *)
      Definition clone (self : ref Self) : M nix.errno.consts.Errno.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.errno.consts.Errno.t := M.read self in
        M.read (deref α0).
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_nix_errno_consts_Errno_t.
    End Impl_core_clone_Clone_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_marker_Copy_for_nix_errno_consts_Errno_t.
    Section Impl_core_marker_Copy_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_nix_errno_consts_Errno_t.
    End Impl_core_marker_Copy_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_fmt_Debug_for_nix_errno_consts_Errno_t.
    Section Impl_core_fmt_Debug_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      (*
          Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
        let* α1 : M.Val (ref str.t) :=
          match_operator
            self
            [
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.UnknownErrno =>
                  let* α0 : ref str.t := M.read (mk_str "UnknownErrno") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPERM =>
                  let* α0 : ref str.t := M.read (mk_str "EPERM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOENT =>
                  let* α0 : ref str.t := M.read (mk_str "ENOENT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESRCH =>
                  let* α0 : ref str.t := M.read (mk_str "ESRCH") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EINTR =>
                  let* α0 : ref str.t := M.read (mk_str "EINTR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EIO =>
                  let* α0 : ref str.t := M.read (mk_str "EIO") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENXIO =>
                  let* α0 : ref str.t := M.read (mk_str "ENXIO") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.E2BIG =>
                  let* α0 : ref str.t := M.read (mk_str "E2BIG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOEXEC =>
                  let* α0 : ref str.t := M.read (mk_str "ENOEXEC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADF =>
                  let* α0 : ref str.t := M.read (mk_str "EBADF") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECHILD =>
                  let* α0 : ref str.t := M.read (mk_str "ECHILD") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EAGAIN =>
                  let* α0 : ref str.t := M.read (mk_str "EAGAIN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOMEM =>
                  let* α0 : ref str.t := M.read (mk_str "ENOMEM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EACCES =>
                  let* α0 : ref str.t := M.read (mk_str "EACCES") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EFAULT =>
                  let* α0 : ref str.t := M.read (mk_str "EFAULT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTBLK =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTBLK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBUSY =>
                  let* α0 : ref str.t := M.read (mk_str "EBUSY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EEXIST =>
                  let* α0 : ref str.t := M.read (mk_str "EEXIST") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EXDEV =>
                  let* α0 : ref str.t := M.read (mk_str "EXDEV") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENODEV =>
                  let* α0 : ref str.t := M.read (mk_str "ENODEV") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTDIR =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTDIR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EISDIR =>
                  let* α0 : ref str.t := M.read (mk_str "EISDIR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EINVAL =>
                  let* α0 : ref str.t := M.read (mk_str "EINVAL") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENFILE =>
                  let* α0 : ref str.t := M.read (mk_str "ENFILE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EMFILE =>
                  let* α0 : ref str.t := M.read (mk_str "EMFILE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTTY =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTTY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ETXTBSY =>
                  let* α0 : ref str.t := M.read (mk_str "ETXTBSY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EFBIG =>
                  let* α0 : ref str.t := M.read (mk_str "EFBIG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOSPC =>
                  let* α0 : ref str.t := M.read (mk_str "ENOSPC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESPIPE =>
                  let* α0 : ref str.t := M.read (mk_str "ESPIPE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EROFS =>
                  let* α0 : ref str.t := M.read (mk_str "EROFS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EMLINK =>
                  let* α0 : ref str.t := M.read (mk_str "EMLINK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPIPE =>
                  let* α0 : ref str.t := M.read (mk_str "EPIPE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EDOM =>
                  let* α0 : ref str.t := M.read (mk_str "EDOM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ERANGE =>
                  let* α0 : ref str.t := M.read (mk_str "ERANGE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EDEADLK =>
                  let* α0 : ref str.t := M.read (mk_str "EDEADLK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENAMETOOLONG =>
                  let* α0 : ref str.t := M.read (mk_str "ENAMETOOLONG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOLCK =>
                  let* α0 : ref str.t := M.read (mk_str "ENOLCK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOSYS =>
                  let* α0 : ref str.t := M.read (mk_str "ENOSYS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTEMPTY =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTEMPTY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELOOP =>
                  let* α0 : ref str.t := M.read (mk_str "ELOOP") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOMSG =>
                  let* α0 : ref str.t := M.read (mk_str "ENOMSG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EIDRM =>
                  let* α0 : ref str.t := M.read (mk_str "EIDRM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECHRNG =>
                  let* α0 : ref str.t := M.read (mk_str "ECHRNG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EL2NSYNC =>
                  let* α0 : ref str.t := M.read (mk_str "EL2NSYNC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EL3HLT =>
                  let* α0 : ref str.t := M.read (mk_str "EL3HLT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EL3RST =>
                  let* α0 : ref str.t := M.read (mk_str "EL3RST") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELNRNG =>
                  let* α0 : ref str.t := M.read (mk_str "ELNRNG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EUNATCH =>
                  let* α0 : ref str.t := M.read (mk_str "EUNATCH") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOCSI =>
                  let* α0 : ref str.t := M.read (mk_str "ENOCSI") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EL2HLT =>
                  let* α0 : ref str.t := M.read (mk_str "EL2HLT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADE =>
                  let* α0 : ref str.t := M.read (mk_str "EBADE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADR =>
                  let* α0 : ref str.t := M.read (mk_str "EBADR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EXFULL =>
                  let* α0 : ref str.t := M.read (mk_str "EXFULL") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOANO =>
                  let* α0 : ref str.t := M.read (mk_str "ENOANO") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADRQC =>
                  let* α0 : ref str.t := M.read (mk_str "EBADRQC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADSLT =>
                  let* α0 : ref str.t := M.read (mk_str "EBADSLT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBFONT =>
                  let* α0 : ref str.t := M.read (mk_str "EBFONT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOSTR =>
                  let* α0 : ref str.t := M.read (mk_str "ENOSTR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENODATA =>
                  let* α0 : ref str.t := M.read (mk_str "ENODATA") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ETIME =>
                  let* α0 : ref str.t := M.read (mk_str "ETIME") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOSR =>
                  let* α0 : ref str.t := M.read (mk_str "ENOSR") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENONET =>
                  let* α0 : ref str.t := M.read (mk_str "ENONET") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOPKG =>
                  let* α0 : ref str.t := M.read (mk_str "ENOPKG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EREMOTE =>
                  let* α0 : ref str.t := M.read (mk_str "EREMOTE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOLINK =>
                  let* α0 : ref str.t := M.read (mk_str "ENOLINK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EADV =>
                  let* α0 : ref str.t := M.read (mk_str "EADV") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESRMNT =>
                  let* α0 : ref str.t := M.read (mk_str "ESRMNT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECOMM =>
                  let* α0 : ref str.t := M.read (mk_str "ECOMM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPROTO =>
                  let* α0 : ref str.t := M.read (mk_str "EPROTO") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EMULTIHOP =>
                  let* α0 : ref str.t := M.read (mk_str "EMULTIHOP") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EDOTDOT =>
                  let* α0 : ref str.t := M.read (mk_str "EDOTDOT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADMSG =>
                  let* α0 : ref str.t := M.read (mk_str "EBADMSG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EOVERFLOW =>
                  let* α0 : ref str.t := M.read (mk_str "EOVERFLOW") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTUNIQ =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTUNIQ") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EBADFD =>
                  let* α0 : ref str.t := M.read (mk_str "EBADFD") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EREMCHG =>
                  let* α0 : ref str.t := M.read (mk_str "EREMCHG") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELIBACC =>
                  let* α0 : ref str.t := M.read (mk_str "ELIBACC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELIBBAD =>
                  let* α0 : ref str.t := M.read (mk_str "ELIBBAD") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELIBSCN =>
                  let* α0 : ref str.t := M.read (mk_str "ELIBSCN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELIBMAX =>
                  let* α0 : ref str.t := M.read (mk_str "ELIBMAX") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ELIBEXEC =>
                  let* α0 : ref str.t := M.read (mk_str "ELIBEXEC") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EILSEQ =>
                  let* α0 : ref str.t := M.read (mk_str "EILSEQ") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ERESTART =>
                  let* α0 : ref str.t := M.read (mk_str "ERESTART") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESTRPIPE =>
                  let* α0 : ref str.t := M.read (mk_str "ESTRPIPE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EUSERS =>
                  let* α0 : ref str.t := M.read (mk_str "EUSERS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTSOCK =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTSOCK") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EDESTADDRREQ =>
                  let* α0 : ref str.t := M.read (mk_str "EDESTADDRREQ") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EMSGSIZE =>
                  let* α0 : ref str.t := M.read (mk_str "EMSGSIZE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPROTOTYPE =>
                  let* α0 : ref str.t := M.read (mk_str "EPROTOTYPE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOPROTOOPT =>
                  let* α0 : ref str.t := M.read (mk_str "ENOPROTOOPT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPROTONOSUPPORT =>
                  let* α0 : ref str.t := M.read (mk_str "EPROTONOSUPPORT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESOCKTNOSUPPORT =>
                  let* α0 : ref str.t := M.read (mk_str "ESOCKTNOSUPPORT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EOPNOTSUPP =>
                  let* α0 : ref str.t := M.read (mk_str "EOPNOTSUPP") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EPFNOSUPPORT =>
                  let* α0 : ref str.t := M.read (mk_str "EPFNOSUPPORT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EAFNOSUPPORT =>
                  let* α0 : ref str.t := M.read (mk_str "EAFNOSUPPORT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EADDRINUSE =>
                  let* α0 : ref str.t := M.read (mk_str "EADDRINUSE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EADDRNOTAVAIL =>
                  let* α0 : ref str.t := M.read (mk_str "EADDRNOTAVAIL") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENETDOWN =>
                  let* α0 : ref str.t := M.read (mk_str "ENETDOWN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENETUNREACH =>
                  let* α0 : ref str.t := M.read (mk_str "ENETUNREACH") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENETRESET =>
                  let* α0 : ref str.t := M.read (mk_str "ENETRESET") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECONNABORTED =>
                  let* α0 : ref str.t := M.read (mk_str "ECONNABORTED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECONNRESET =>
                  let* α0 : ref str.t := M.read (mk_str "ECONNRESET") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOBUFS =>
                  let* α0 : ref str.t := M.read (mk_str "ENOBUFS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EISCONN =>
                  let* α0 : ref str.t := M.read (mk_str "EISCONN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTCONN =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTCONN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESHUTDOWN =>
                  let* α0 : ref str.t := M.read (mk_str "ESHUTDOWN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ETOOMANYREFS =>
                  let* α0 : ref str.t := M.read (mk_str "ETOOMANYREFS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ETIMEDOUT =>
                  let* α0 : ref str.t := M.read (mk_str "ETIMEDOUT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECONNREFUSED =>
                  let* α0 : ref str.t := M.read (mk_str "ECONNREFUSED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EHOSTDOWN =>
                  let* α0 : ref str.t := M.read (mk_str "EHOSTDOWN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EHOSTUNREACH =>
                  let* α0 : ref str.t := M.read (mk_str "EHOSTUNREACH") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EALREADY =>
                  let* α0 : ref str.t := M.read (mk_str "EALREADY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EINPROGRESS =>
                  let* α0 : ref str.t := M.read (mk_str "EINPROGRESS") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ESTALE =>
                  let* α0 : ref str.t := M.read (mk_str "ESTALE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EUCLEAN =>
                  let* α0 : ref str.t := M.read (mk_str "EUCLEAN") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTNAM =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTNAM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENAVAIL =>
                  let* α0 : ref str.t := M.read (mk_str "ENAVAIL") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EISNAM =>
                  let* α0 : ref str.t := M.read (mk_str "EISNAM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EREMOTEIO =>
                  let* α0 : ref str.t := M.read (mk_str "EREMOTEIO") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EDQUOT =>
                  let* α0 : ref str.t := M.read (mk_str "EDQUOT") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOMEDIUM =>
                  let* α0 : ref str.t := M.read (mk_str "ENOMEDIUM") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EMEDIUMTYPE =>
                  let* α0 : ref str.t := M.read (mk_str "EMEDIUMTYPE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ECANCELED =>
                  let* α0 : ref str.t := M.read (mk_str "ECANCELED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOKEY =>
                  let* α0 : ref str.t := M.read (mk_str "ENOKEY") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EKEYEXPIRED =>
                  let* α0 : ref str.t := M.read (mk_str "EKEYEXPIRED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EKEYREVOKED =>
                  let* α0 : ref str.t := M.read (mk_str "EKEYREVOKED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EKEYREJECTED =>
                  let* α0 : ref str.t := M.read (mk_str "EKEYREJECTED") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EOWNERDEAD =>
                  let* α0 : ref str.t := M.read (mk_str "EOWNERDEAD") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ENOTRECOVERABLE =>
                  let* α0 : ref str.t := M.read (mk_str "ENOTRECOVERABLE") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.ERFKILL =>
                  let* α0 : ref str.t := M.read (mk_str "ERFKILL") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t));
              fun γ =>
                (let* γ :=
                  let* α0 := M.read γ in
                  M.pure (deref α0) in
                let* α0 := M.read γ in
                match α0 with
                | nix.errno.consts.Errno.EHWPOISON =>
                  let* α0 : ref str.t := M.read (mk_str "EHWPOISON") in
                  M.alloc α0
                | _ => M.break_match
                end) :
                M (M.Val (ref str.t))
            ] in
        let* α2 : ref str.t := M.read α1 in
        M.call (core.fmt.Formatter.t::["write_str"] α0 α2).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_nix_errno_consts_Errno_t.
    End Impl_core_fmt_Debug_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_marker_StructuralEq_for_nix_errno_consts_Errno_t.
    Section Impl_core_marker_StructuralEq_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralEq_for_nix_errno_consts_Errno_t.
    End Impl_core_marker_StructuralEq_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_cmp_Eq_for_nix_errno_consts_Errno_t.
    Section Impl_core_cmp_Eq_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      (*
          Eq
      *)
      Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
        let* self := M.alloc self in
        M.pure tt.
      
      Global Instance AssociatedFunction_assert_receiver_is_total_eq :
        Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
        Notations.double_colon := assert_receiver_is_total_eq;
      }.
      
      Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
        core.cmp.Eq.assert_receiver_is_total_eq :=
          Datatypes.Some assert_receiver_is_total_eq;
      }.
    End Impl_core_cmp_Eq_for_nix_errno_consts_Errno_t.
    End Impl_core_cmp_Eq_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_nix_errno_consts_Errno_t.
    Section Impl_core_marker_StructuralPartialEq_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_nix_errno_consts_Errno_t.
    End Impl_core_marker_StructuralPartialEq_for_nix_errno_consts_Errno_t.
    
    Module  Impl_core_cmp_PartialEq_for_nix_errno_consts_Errno_t.
    Section Impl_core_cmp_PartialEq_for_nix_errno_consts_Errno_t.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      (*
          PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref nix.errno.consts.Errno.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* __self_tag : M.Val i32.t :=
          let* α0 : ref nix.errno.consts.Errno.t := M.read self in
          let* α1 : i32.t := M.call (core.intrinsics.discriminant_value α0) in
          M.alloc α1 in
        let* __arg1_tag : M.Val i32.t :=
          let* α0 : ref nix.errno.consts.Errno.t := M.read other in
          let* α1 : i32.t := M.call (core.intrinsics.discriminant_value α0) in
          M.alloc α1 in
        let* α0 : i32.t := M.read __self_tag in
        let* α1 : i32.t := M.read __arg1_tag in
        let* α0 : M.Val bool.t := M.alloc (BinOp.Pure.eq α0 α1) in
        M.read α0.
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_nix_errno_consts_Errno_t.
    End Impl_core_cmp_PartialEq_for_nix_errno_consts_Errno_t.
    
    Module  Impl_nix_errno_consts_Errno_t_2.
    Section Impl_nix_errno_consts_Errno_t_2.
      Definition Self : Set := nix.errno.consts.Errno.t.
      
      (*
              pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
      *)
      
      Definition EWOULDBLOCK : nix.errno.consts.Errno.t :=
        M.run (M.alloc nix.errno.consts.Errno.EAGAIN).
      
      Global Instance AssociatedFunction_EWOULDBLOCK :
        Notations.DoubleColon Self "EWOULDBLOCK" := {
        Notations.double_colon := EWOULDBLOCK;
      }.
      
      (*
              pub const EDEADLOCK: Errno = Errno::EDEADLK;
      *)
      
      Definition EDEADLOCK : nix.errno.consts.Errno.t :=
        M.run (M.alloc nix.errno.consts.Errno.EDEADLK).
      
      Global Instance AssociatedFunction_EDEADLOCK :
        Notations.DoubleColon Self "EDEADLOCK" := {
        Notations.double_colon := EDEADLOCK;
      }.
      
      (*
              pub const ENOTSUP: Errno = Errno::EOPNOTSUPP;
      *)
      
      Definition ENOTSUP : nix.errno.consts.Errno.t :=
        M.run (M.alloc nix.errno.consts.Errno.EOPNOTSUPP).
      
      Global Instance AssociatedFunction_ENOTSUP :
        Notations.DoubleColon Self "ENOTSUP" := {
        Notations.double_colon := ENOTSUP;
      }.
    End Impl_nix_errno_consts_Errno_t_2.
    End Impl_nix_errno_consts_Errno_t_2.
    
    (*
        pub const fn from_i32(e: i32) -> Errno {
            use self::Errno::*;
    
            match e {
                libc::EPERM => EPERM,
                libc::ENOENT => ENOENT,
                libc::ESRCH => ESRCH,
                libc::EINTR => EINTR,
                libc::EIO => EIO,
                libc::ENXIO => ENXIO,
                libc::E2BIG => E2BIG,
                libc::ENOEXEC => ENOEXEC,
                libc::EBADF => EBADF,
                libc::ECHILD => ECHILD,
                libc::EAGAIN => EAGAIN,
                libc::ENOMEM => ENOMEM,
                libc::EACCES => EACCES,
                libc::EFAULT => EFAULT,
                libc::ENOTBLK => ENOTBLK,
                libc::EBUSY => EBUSY,
                libc::EEXIST => EEXIST,
                libc::EXDEV => EXDEV,
                libc::ENODEV => ENODEV,
                libc::ENOTDIR => ENOTDIR,
                libc::EISDIR => EISDIR,
                libc::EINVAL => EINVAL,
                libc::ENFILE => ENFILE,
                libc::EMFILE => EMFILE,
                libc::ENOTTY => ENOTTY,
                libc::ETXTBSY => ETXTBSY,
                libc::EFBIG => EFBIG,
                libc::ENOSPC => ENOSPC,
                libc::ESPIPE => ESPIPE,
                libc::EROFS => EROFS,
                libc::EMLINK => EMLINK,
                libc::EPIPE => EPIPE,
                libc::EDOM => EDOM,
                libc::ERANGE => ERANGE,
                libc::EDEADLK => EDEADLK,
                libc::ENAMETOOLONG => ENAMETOOLONG,
                libc::ENOLCK => ENOLCK,
                libc::ENOSYS => ENOSYS,
                libc::ENOTEMPTY => ENOTEMPTY,
                libc::ELOOP => ELOOP,
                libc::ENOMSG => ENOMSG,
                libc::EIDRM => EIDRM,
                libc::ECHRNG => ECHRNG,
                libc::EL2NSYNC => EL2NSYNC,
                libc::EL3HLT => EL3HLT,
                libc::EL3RST => EL3RST,
                libc::ELNRNG => ELNRNG,
                libc::EUNATCH => EUNATCH,
                libc::ENOCSI => ENOCSI,
                libc::EL2HLT => EL2HLT,
                libc::EBADE => EBADE,
                libc::EBADR => EBADR,
                libc::EXFULL => EXFULL,
                libc::ENOANO => ENOANO,
                libc::EBADRQC => EBADRQC,
                libc::EBADSLT => EBADSLT,
                libc::EBFONT => EBFONT,
                libc::ENOSTR => ENOSTR,
                libc::ENODATA => ENODATA,
                libc::ETIME => ETIME,
                libc::ENOSR => ENOSR,
                libc::ENONET => ENONET,
                libc::ENOPKG => ENOPKG,
                libc::EREMOTE => EREMOTE,
                libc::ENOLINK => ENOLINK,
                libc::EADV => EADV,
                libc::ESRMNT => ESRMNT,
                libc::ECOMM => ECOMM,
                libc::EPROTO => EPROTO,
                libc::EMULTIHOP => EMULTIHOP,
                libc::EDOTDOT => EDOTDOT,
                libc::EBADMSG => EBADMSG,
                libc::EOVERFLOW => EOVERFLOW,
                libc::ENOTUNIQ => ENOTUNIQ,
                libc::EBADFD => EBADFD,
                libc::EREMCHG => EREMCHG,
                libc::ELIBACC => ELIBACC,
                libc::ELIBBAD => ELIBBAD,
                libc::ELIBSCN => ELIBSCN,
                libc::ELIBMAX => ELIBMAX,
                libc::ELIBEXEC => ELIBEXEC,
                libc::EILSEQ => EILSEQ,
                libc::ERESTART => ERESTART,
                libc::ESTRPIPE => ESTRPIPE,
                libc::EUSERS => EUSERS,
                libc::ENOTSOCK => ENOTSOCK,
                libc::EDESTADDRREQ => EDESTADDRREQ,
                libc::EMSGSIZE => EMSGSIZE,
                libc::EPROTOTYPE => EPROTOTYPE,
                libc::ENOPROTOOPT => ENOPROTOOPT,
                libc::EPROTONOSUPPORT => EPROTONOSUPPORT,
                libc::ESOCKTNOSUPPORT => ESOCKTNOSUPPORT,
                libc::EOPNOTSUPP => EOPNOTSUPP,
                libc::EPFNOSUPPORT => EPFNOSUPPORT,
                libc::EAFNOSUPPORT => EAFNOSUPPORT,
                libc::EADDRINUSE => EADDRINUSE,
                libc::EADDRNOTAVAIL => EADDRNOTAVAIL,
                libc::ENETDOWN => ENETDOWN,
                libc::ENETUNREACH => ENETUNREACH,
                libc::ENETRESET => ENETRESET,
                libc::ECONNABORTED => ECONNABORTED,
                libc::ECONNRESET => ECONNRESET,
                libc::ENOBUFS => ENOBUFS,
                libc::EISCONN => EISCONN,
                libc::ENOTCONN => ENOTCONN,
                libc::ESHUTDOWN => ESHUTDOWN,
                libc::ETOOMANYREFS => ETOOMANYREFS,
                libc::ETIMEDOUT => ETIMEDOUT,
                libc::ECONNREFUSED => ECONNREFUSED,
                libc::EHOSTDOWN => EHOSTDOWN,
                libc::EHOSTUNREACH => EHOSTUNREACH,
                libc::EALREADY => EALREADY,
                libc::EINPROGRESS => EINPROGRESS,
                libc::ESTALE => ESTALE,
                libc::EUCLEAN => EUCLEAN,
                libc::ENOTNAM => ENOTNAM,
                libc::ENAVAIL => ENAVAIL,
                libc::EISNAM => EISNAM,
                libc::EREMOTEIO => EREMOTEIO,
                libc::EDQUOT => EDQUOT,
                libc::ENOMEDIUM => ENOMEDIUM,
                libc::EMEDIUMTYPE => EMEDIUMTYPE,
                libc::ECANCELED => ECANCELED,
                libc::ENOKEY => ENOKEY,
                libc::EKEYEXPIRED => EKEYEXPIRED,
                libc::EKEYREVOKED => EKEYREVOKED,
                libc::EKEYREJECTED => EKEYREJECTED,
                libc::EOWNERDEAD => EOWNERDEAD,
                libc::ENOTRECOVERABLE => ENOTRECOVERABLE,
                #[cfg(not(any(target_os = "android", target_arch = "mips")))]
                libc::ERFKILL => ERFKILL,
                #[cfg(not(any(target_os = "android", target_arch = "mips")))]
                libc::EHWPOISON => EHWPOISON,
                _ => UnknownErrno,
            }
        }
    *)
    Definition from_i32 (e : i32.t) : M nix.errno.consts.Errno.t :=
      let* e := M.alloc e in
      let* α0 : M.Val nix.errno.consts.Errno.t :=
        match_operator
          e
          [
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPERM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOENT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESRCH) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EINTR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EIO) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENXIO) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.E2BIG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOEXEC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADF) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECHILD) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EAGAIN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOMEM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EACCES) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EFAULT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTBLK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBUSY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EEXIST) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EXDEV) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENODEV) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTDIR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EISDIR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EINVAL) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENFILE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EMFILE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTTY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ETXTBSY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EFBIG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOSPC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESPIPE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EROFS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EMLINK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPIPE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EDOM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ERANGE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EDEADLK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENAMETOOLONG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOLCK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOSYS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTEMPTY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELOOP) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOMSG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EIDRM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECHRNG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EL2NSYNC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EL3HLT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EL3RST) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELNRNG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EUNATCH) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOCSI) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EL2HLT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EXFULL) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOANO) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADRQC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADSLT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBFONT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOSTR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENODATA) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ETIME) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOSR) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENONET) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOPKG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EREMOTE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOLINK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EADV) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESRMNT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECOMM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPROTO) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EMULTIHOP) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EDOTDOT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADMSG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EOVERFLOW) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTUNIQ) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EBADFD) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EREMCHG) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELIBACC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELIBBAD) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELIBSCN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELIBMAX) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ELIBEXEC) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EILSEQ) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ERESTART) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESTRPIPE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EUSERS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTSOCK) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EDESTADDRREQ) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EMSGSIZE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPROTOTYPE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOPROTOOPT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPROTONOSUPPORT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESOCKTNOSUPPORT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EOPNOTSUPP) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EPFNOSUPPORT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EAFNOSUPPORT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EADDRINUSE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EADDRNOTAVAIL) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENETDOWN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENETUNREACH) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENETRESET) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECONNABORTED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECONNRESET) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOBUFS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EISCONN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTCONN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESHUTDOWN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ETOOMANYREFS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ETIMEDOUT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECONNREFUSED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EHOSTDOWN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EHOSTUNREACH) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EALREADY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EINPROGRESS) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ESTALE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EUCLEAN) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTNAM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENAVAIL) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EISNAM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EREMOTEIO) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EDQUOT) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOMEDIUM) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EMEDIUMTYPE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ECANCELED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOKEY) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EKEYEXPIRED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EKEYREVOKED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EKEYREJECTED) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EOWNERDEAD) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ENOTRECOVERABLE) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.ERFKILL) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.EHWPOISON) :
              M (M.Val nix.errno.consts.Errno.t);
            fun γ =>
              (M.alloc nix.errno.consts.Errno.UnknownErrno) :
              M (M.Val nix.errno.consts.Errno.t)
          ] in
      M.read α0.
  End consts.
End errno.

Module fcntl.
  
End fcntl.

Module sys.
  Module signal.
    Module sigevent.
      
    End sigevent.
  End signal.
  
  Module sysinfo.
    Module  SysInfo.
    Section SysInfo.
      Record t : Set := {
        x0 : libc.unix.linux_like.linux.gnu.b64.sysinfo.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End SysInfo.
    End SysInfo.
    
    Module  Impl_core_marker_Copy_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_marker_Copy_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_marker_Copy_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_clone_Clone_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_clone_Clone_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M nix.sys.sysinfo.SysInfo.t :=
        let* self := M.alloc self in
        let* α0 : M.Val nix.sys.sysinfo.SysInfo.t :=
          match_operator
            (DeclaredButUndefinedVariable
              (A :=
                core.clone.AssertParamIsClone.t
                  libc.unix.linux_like.linux.gnu.b64.sysinfo.t))
            [
              fun γ =>
                (let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
                M.pure (deref α0)) :
                M (M.Val nix.sys.sysinfo.SysInfo.t)
            ] in
        M.read α0.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_clone_Clone_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_fmt_Debug_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_fmt_Debug_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
        let* α1 : ref str.t := M.read (mk_str "SysInfo") in
        let* α2 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α3 : M.Val (ref libc.unix.linux_like.linux.gnu.b64.sysinfo.t) :=
          M.alloc (borrow (nix.sys.sysinfo.SysInfo.Get_0 (deref α2))) in
        M.call
          (core.fmt.Formatter.t::["debug_tuple_field1_finish"]
            α0
            α1
            (pointer_coercion "Unsize" (borrow α3))).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_fmt_Debug_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_marker_StructuralEq_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_marker_StructuralEq_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralEq_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_marker_StructuralEq_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_cmp_Eq_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_cmp_Eq_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
      Eq
      *)
      Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
        let* self := M.alloc self in
        let* α0 : M.Val unit :=
          match_operator
            (DeclaredButUndefinedVariable
              (A :=
                core.cmp.AssertParamIsEq.t
                  libc.unix.linux_like.linux.gnu.b64.sysinfo.t))
            [ fun γ => (M.alloc tt) : M (M.Val unit) ] in
        M.read α0.
      
      Global Instance AssociatedFunction_assert_receiver_is_total_eq :
        Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
        Notations.double_colon := assert_receiver_is_total_eq;
      }.
      
      Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
        core.cmp.Eq.assert_receiver_is_total_eq :=
          Datatypes.Some assert_receiver_is_total_eq;
      }.
    End Impl_core_cmp_Eq_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_cmp_Eq_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_hash_Hash_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_hash_Hash_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
      Hash
      *)
      Definition hash
          {__H : Set}
          (self : ref Self)
          (state : mut_ref __H)
          : M unit :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        let* α0 :
            (ref libc.unix.linux_like.linux.gnu.b64.sysinfo.t) ->
              (mut_ref __H) ->
              M unit :=
          ltac:(M.get_method (fun ℐ =>
            core.hash.Hash.hash
              (Self := libc.unix.linux_like.linux.gnu.b64.sysinfo.t)
              (H := __H)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : mut_ref __H := M.read state in
        M.call (α0 (borrow (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) α2).
      
      Global Instance AssociatedFunction_hash {__H : Set} :
        Notations.DoubleColon Self "hash" := {
        Notations.double_colon := hash (__H := __H);
      }.
      
      Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
        core.hash.Hash.hash {__H : Set} := hash (__H := __H);
        core.hash.Hash.hash_slice := Datatypes.None;
      }.
    End Impl_core_hash_Hash_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_hash_Hash_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_marker_StructuralPartialEq_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_sysinfo_SysInfo_t.
    
    Module  Impl_core_cmp_PartialEq_for_nix_sys_sysinfo_SysInfo_t.
    Section Impl_core_cmp_PartialEq_for_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref nix.sys.sysinfo.SysInfo.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 :
            (ref libc.unix.linux_like.linux.gnu.b64.sysinfo.t) ->
              (ref libc.unix.linux_like.linux.gnu.b64.sysinfo.t) ->
              M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := libc.unix.linux_like.linux.gnu.b64.sysinfo.t)
              (Rhs := libc.unix.linux_like.linux.gnu.b64.sysinfo.t)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : ref nix.sys.sysinfo.SysInfo.t := M.read other in
        M.call
          (α0
            (borrow (nix.sys.sysinfo.SysInfo.Get_0 (deref α1)))
            (borrow (nix.sys.sysinfo.SysInfo.Get_0 (deref α2)))).
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_nix_sys_sysinfo_SysInfo_t.
    End Impl_core_cmp_PartialEq_for_nix_sys_sysinfo_SysInfo_t.
    
    Ltac mem_blocks_t :=
      exact ltac:(libc.unix.linux_like.linux.gnu.b64.x86_64.not_x32.c_ulong).
    
    Module  Impl_nix_sys_sysinfo_SysInfo_t.
    Section Impl_nix_sys_sysinfo_SysInfo_t.
      Definition Self : Set := nix.sys.sysinfo.SysInfo.t.
      
      (*
          pub fn load_average(&self) -> (f64, f64, f64) {
              (
                  self.0.loads[0] as f64 / (1 << SI_LOAD_SHIFT) as f64,
                  self.0.loads[1] as f64 / (1 << SI_LOAD_SHIFT) as f64,
                  self.0.loads[2] as f64 / (1 << SI_LOAD_SHIFT) as f64,
              )
          }
      *)
      Definition load_average (self : ref Self) : M ((f64.t * f64.t) * f64.t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_loads
                (nix.sys.sysinfo.SysInfo.Get_0 (deref α0)))[M.alloc
                ((Integer.of_Z 0) : usize.t)] in
        let* α2 : u32.t := M.read libc.unix.linux_like.SI_LOAD_SHIFT in
        let* α3 : i32.t := BinOp.Panic.shl ((Integer.of_Z 1) : i32.t) α2 in
        let* α4 : f64.t := BinOp.Panic.div (rust_cast α1) (rust_cast α3) in
        let* α5 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α6 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_loads
                (nix.sys.sysinfo.SysInfo.Get_0 (deref α5)))[M.alloc
                ((Integer.of_Z 1) : usize.t)] in
        let* α7 : u32.t := M.read libc.unix.linux_like.SI_LOAD_SHIFT in
        let* α8 : i32.t := BinOp.Panic.shl ((Integer.of_Z 1) : i32.t) α7 in
        let* α9 : f64.t := BinOp.Panic.div (rust_cast α6) (rust_cast α8) in
        let* α10 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α11 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_loads
                (nix.sys.sysinfo.SysInfo.Get_0 (deref α10)))[M.alloc
                ((Integer.of_Z 2) : usize.t)] in
        let* α12 : u32.t := M.read libc.unix.linux_like.SI_LOAD_SHIFT in
        let* α13 : i32.t := BinOp.Panic.shl ((Integer.of_Z 1) : i32.t) α12 in
        let* α14 : f64.t := BinOp.Panic.div (rust_cast α11) (rust_cast α13) in
        M.pure (α4, α9, α14).
      
      Global Instance AssociatedFunction_load_average :
        Notations.DoubleColon Self "load_average" := {
        Notations.double_colon := load_average;
      }.
      
      (*
          pub fn uptime(&self) -> Duration {
              // Truncate negative values to 0
              Duration::from_secs(cmp::max(self.0.uptime, 0) as u64)
          }
      *)
      Definition uptime (self : ref Self) : M core.time.Duration.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : i64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_uptime
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α0))) in
        let* α2 : i64.t :=
          M.call (core.cmp.max α1 ((Integer.of_Z 0) : i64.t)) in
        M.call (core.time.Duration.t::["from_secs"] (rust_cast α2)).
      
      Global Instance AssociatedFunction_uptime :
        Notations.DoubleColon Self "uptime" := {
        Notations.double_colon := uptime;
      }.
      
      (*
          pub fn process_count(&self) -> u16 {
              self.0.procs
          }
      *)
      Definition process_count (self : ref Self) : M u16.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        M.read
          (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_procs
            (nix.sys.sysinfo.SysInfo.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_process_count :
        Notations.DoubleColon Self "process_count" := {
        Notations.double_colon := process_count;
      }.
      
      (*
          pub fn swap_total(&self) -> u64 {
              self.scale_mem(self.0.totalswap)
          }
      *)
      Definition swap_total (self : ref Self) : M u64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_totalswap
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) in
        M.call (nix.sys.sysinfo.SysInfo.t::["scale_mem"] α0 α2).
      
      Global Instance AssociatedFunction_swap_total :
        Notations.DoubleColon Self "swap_total" := {
        Notations.double_colon := swap_total;
      }.
      
      (*
          pub fn swap_free(&self) -> u64 {
              self.scale_mem(self.0.freeswap)
          }
      *)
      Definition swap_free (self : ref Self) : M u64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_freeswap
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) in
        M.call (nix.sys.sysinfo.SysInfo.t::["scale_mem"] α0 α2).
      
      Global Instance AssociatedFunction_swap_free :
        Notations.DoubleColon Self "swap_free" := {
        Notations.double_colon := swap_free;
      }.
      
      (*
          pub fn ram_total(&self) -> u64 {
              self.scale_mem(self.0.totalram)
          }
      *)
      Definition ram_total (self : ref Self) : M u64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_totalram
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) in
        M.call (nix.sys.sysinfo.SysInfo.t::["scale_mem"] α0 α2).
      
      Global Instance AssociatedFunction_ram_total :
        Notations.DoubleColon Self "ram_total" := {
        Notations.double_colon := ram_total;
      }.
      
      (*
          pub fn ram_unused(&self) -> u64 {
              self.scale_mem(self.0.freeram)
          }
      *)
      Definition ram_unused (self : ref Self) : M u64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : u64.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_freeram
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) in
        M.call (nix.sys.sysinfo.SysInfo.t::["scale_mem"] α0 α2).
      
      Global Instance AssociatedFunction_ram_unused :
        Notations.DoubleColon Self "ram_unused" := {
        Notations.double_colon := ram_unused;
      }.
      
      (*
          fn scale_mem(&self, units: mem_blocks_t) -> u64 {
              units as u64 * self.0.mem_unit as u64
          }
      *)
      Definition scale_mem
          (self : ref Self)
          (units : ltac:(nix.sys.sysinfo.mem_blocks_t))
          : M u64.t :=
        let* self := M.alloc self in
        let* units := M.alloc units in
        let* α0 : u64.t := M.read (use units) in
        let* α1 : ref nix.sys.sysinfo.SysInfo.t := M.read self in
        let* α2 : u32.t :=
          M.read
            (libc.unix.linux_like.linux.gnu.b64.sysinfo.Get_mem_unit
              (nix.sys.sysinfo.SysInfo.Get_0 (deref α1))) in
        BinOp.Panic.mul α0 (rust_cast α2).
      
      Global Instance AssociatedFunction_scale_mem :
        Notations.DoubleColon Self "scale_mem" := {
        Notations.double_colon := scale_mem;
      }.
    End Impl_nix_sys_sysinfo_SysInfo_t.
    End Impl_nix_sys_sysinfo_SysInfo_t.
    
    (*
    pub fn sysinfo() -> Result<SysInfo> {
        let mut info = mem::MaybeUninit::uninit();
        let res = unsafe { libc::sysinfo(info.as_mut_ptr()) };
        Errno::result(res).map(|_| unsafe { SysInfo(info.assume_init()) })
    }
    *)
    Definition sysinfo : M ltac:(nix.Result nix.sys.sysinfo.SysInfo.t) :=
      let* info :
          M.Val
            (core.mem.maybe_uninit.MaybeUninit.t
              libc.unix.linux_like.linux.gnu.b64.sysinfo.t) :=
        let* α0 :
            core.mem.maybe_uninit.MaybeUninit.t
              libc.unix.linux_like.linux.gnu.b64.sysinfo.t :=
          M.call
            (core.mem.maybe_uninit.MaybeUninit.t
                libc.unix.linux_like.linux.gnu.b64.sysinfo.t)::["uninit"] in
        M.alloc α0 in
      let* res : M.Val i32.t :=
        let* α0 : mut_ref libc.unix.linux_like.linux.gnu.b64.sysinfo.t :=
          M.call
            ((core.mem.maybe_uninit.MaybeUninit.t
                  libc.unix.linux_like.linux.gnu.b64.sysinfo.t)::["as_mut_ptr"]
              (borrow_mut info)) in
        let* α1 : i32.t := M.call (libc.unix.linux_like.linux.sysinfo α0) in
        M.alloc α1 in
      let* α0 : i32.t := M.read res in
      let* α1 : core.result.Result.t i32.t nix.errno.consts.Errno.t :=
        M.call (nix.errno.consts.Errno.t::["result"] α0) in
      let* α2 :
          core.result.Result.t
            nix.sys.sysinfo.SysInfo.t
            nix.errno.consts.Errno.t :=
        M.call
          ((core.result.Result.t i32.t nix.errno.consts.Errno.t)::["map"]
            α1
            (fun (α0 : i32.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* α0 :
                        core.mem.maybe_uninit.MaybeUninit.t
                          libc.unix.linux_like.linux.gnu.b64.sysinfo.t :=
                      M.read info in
                    let* α1 : libc.unix.linux_like.linux.gnu.b64.sysinfo.t :=
                      M.call
                        ((core.mem.maybe_uninit.MaybeUninit.t
                              libc.unix.linux_like.linux.gnu.b64.sysinfo.t)::["assume_init"]
                          α0) in
                    M.pure (nix.sys.sysinfo.SysInfo.Build_t α1)) :
                    M nix.sys.sysinfo.SysInfo.t
                ]) :
              M nix.sys.sysinfo.SysInfo.t)) in
      let* α0 :
          M.Val
            (core.result.Result.t
              nix.sys.sysinfo.SysInfo.t
              nix.errno.consts.Errno.t) :=
        M.alloc α2 in
      M.read α0.
  End sysinfo.
  
  Module time.
    (*
    const fn zero_init_timespec() -> timespec {
        // `std::mem::MaybeUninit::zeroed()` is not yet a const fn
        // (https://github.com/rust-lang/rust/issues/91850) so we will instead initialize an array of
        // the appropriate size to zero and then transmute it to a timespec value.
        unsafe { std::mem::transmute([0u8; std::mem::size_of::<timespec>()]) }
    }
    *)
    Definition zero_init_timespec : M libc.unix.timespec.t :=
      M.call (core.intrinsics.transmute (repeat ((Integer.of_Z 0) : u8.t) 16)).
    
    Module  TimeValLike.
    Section TimeValLike.
      Class Trait (Self : Set) : Type := {
        seconds : i64.t -> M Self;
        milliseconds : i64.t -> M Self;
        microseconds : i64.t -> M Self;
        nanoseconds : i64.t -> M Self;
        num_seconds : (ref Self) -> M i64.t;
        num_milliseconds : (ref Self) -> M i64.t;
        num_microseconds : (ref Self) -> M i64.t;
        num_nanoseconds : (ref Self) -> M i64.t;
      }.
      
    End TimeValLike.
    End TimeValLike.
    
    Module  TimeSpec.
    Section TimeSpec.
      Record t : Set := {
        x0 : libc.unix.timespec.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End TimeSpec.
    End TimeSpec.
    
    Module  Impl_core_clone_Clone_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_clone_Clone_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* α0 : M.Val nix.sys.time.TimeSpec.t :=
          match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t libc.unix.timespec.t))
            [
              fun γ =>
                (let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
                M.pure (deref α0)) :
                M (M.Val nix.sys.time.TimeSpec.t)
            ] in
        M.read α0.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_nix_sys_time_TimeSpec_t.
    End Impl_core_clone_Clone_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_marker_Copy_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_marker_Copy_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_nix_sys_time_TimeSpec_t.
    End Impl_core_marker_Copy_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_fmt_Debug_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_fmt_Debug_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
        let* α1 : ref str.t := M.read (mk_str "TimeSpec") in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α3 : M.Val (ref libc.unix.timespec.t) :=
          M.alloc (borrow (nix.sys.time.TimeSpec.Get_0 (deref α2))) in
        M.call
          (core.fmt.Formatter.t::["debug_tuple_field1_finish"]
            α0
            α1
            (pointer_coercion "Unsize" (borrow α3))).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_nix_sys_time_TimeSpec_t.
    End Impl_core_fmt_Debug_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_marker_StructuralEq_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_marker_StructuralEq_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralEq_for_nix_sys_time_TimeSpec_t.
    End Impl_core_marker_StructuralEq_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_cmp_Eq_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_cmp_Eq_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
      Eq
      *)
      Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
        let* self := M.alloc self in
        let* α0 : M.Val unit :=
          match_operator
            (DeclaredButUndefinedVariable
              (A := core.cmp.AssertParamIsEq.t libc.unix.timespec.t))
            [ fun γ => (M.alloc tt) : M (M.Val unit) ] in
        M.read α0.
      
      Global Instance AssociatedFunction_assert_receiver_is_total_eq :
        Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
        Notations.double_colon := assert_receiver_is_total_eq;
      }.
      
      Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
        core.cmp.Eq.assert_receiver_is_total_eq :=
          Datatypes.Some assert_receiver_is_total_eq;
      }.
    End Impl_core_cmp_Eq_for_nix_sys_time_TimeSpec_t.
    End Impl_core_cmp_Eq_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_hash_Hash_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_hash_Hash_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
      Hash
      *)
      Definition hash
          {__H : Set}
          (self : ref Self)
          (state : mut_ref __H)
          : M unit :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        let* α0 : (ref libc.unix.timespec.t) -> (mut_ref __H) -> M unit :=
          ltac:(M.get_method (fun ℐ =>
            core.hash.Hash.hash
              (Self := libc.unix.timespec.t)
              (H := __H)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α2 : mut_ref __H := M.read state in
        M.call (α0 (borrow (nix.sys.time.TimeSpec.Get_0 (deref α1))) α2).
      
      Global Instance AssociatedFunction_hash {__H : Set} :
        Notations.DoubleColon Self "hash" := {
        Notations.double_colon := hash (__H := __H);
      }.
      
      Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
        core.hash.Hash.hash {__H : Set} := hash (__H := __H);
        core.hash.Hash.hash_slice := Datatypes.None;
      }.
    End Impl_core_hash_Hash_for_nix_sys_time_TimeSpec_t.
    End Impl_core_hash_Hash_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeSpec_t.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_cmp_PartialEq_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_cmp_PartialEq_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref nix.sys.time.TimeSpec.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 :
            (ref libc.unix.timespec.t) ->
              (ref libc.unix.timespec.t) ->
              M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := libc.unix.timespec.t)
              (Rhs := libc.unix.timespec.t)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read other in
        M.call
          (α0
            (borrow (nix.sys.time.TimeSpec.Get_0 (deref α1)))
            (borrow (nix.sys.time.TimeSpec.Get_0 (deref α2)))).
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_nix_sys_time_TimeSpec_t.
    End Impl_core_cmp_PartialEq_for_nix_sys_time_TimeSpec_t.
    
    Definition NANOS_PER_SEC : M.Val i64.t :=
      M.run (M.alloc ((Integer.of_Z 1000000000) : i64.t)).
    
    Definition SECS_PER_MINUTE : M.Val i64.t :=
      M.run (M.alloc ((Integer.of_Z 60) : i64.t)).
    
    Definition SECS_PER_HOUR : M.Val i64.t :=
      M.run (M.alloc ((Integer.of_Z 3600) : i64.t)).
    
    Definition TS_MAX_SECONDS : M.Val i64.t :=
      M.run
        (let* α0 : i64.t := M.read core.num.MAX in
        let* α1 : i64.t := M.read nix.sys.time.NANOS_PER_SEC in
        let* α2 : i64.t := BinOp.Panic.div α0 α1 in
        let* α3 : i64.t := BinOp.Panic.sub α2 ((Integer.of_Z 1) : i64.t) in
        M.alloc α3).
    
    Definition TS_MIN_SECONDS : M.Val i64.t :=
      M.run
        (let* α0 : i64.t := M.read nix.sys.time.TS_MAX_SECONDS in
        let* α1 : i64.t := UnOp.neg α0 in
        M.alloc α1).
    
    Ltac timespec_tv_nsec_t :=
      exact ltac:(libc.unix.linux_like.linux.gnu.b64.x86_64.not_x32.c_long).
    
    Module  Impl_core_convert_From_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_convert_From_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn from(ts: timespec) -> Self {
              Self(ts)
          }
      *)
      Definition from (ts : libc.unix.timespec.t) : M Self :=
        let* ts := M.alloc ts in
        let* α0 : libc.unix.timespec.t := M.read ts in
        M.pure (nix.sys.time.TimeSpec.Build_t α0).
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := libc.unix.timespec.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_convert_From_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_convert_From_core_time_Duration_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_convert_From_core_time_Duration_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn from(duration: Duration) -> Self {
              Self::from_duration(duration)
          }
      *)
      Definition from (duration : core.time.Duration.t) : M Self :=
        let* duration := M.alloc duration in
        let* α0 : core.time.Duration.t := M.read duration in
        M.call (nix.sys.time.TimeSpec.t::["from_duration"] α0).
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := core.time.Duration.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_core_time_Duration_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_convert_From_core_time_Duration_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_convert_From_nix_sys_time_TimeSpec_t_for_core_time_Duration_t.
    Section Impl_core_convert_From_nix_sys_time_TimeSpec_t_for_core_time_Duration_t.
      Definition Self : Set := core.time.Duration.t.
      
      (*
          fn from(timespec: TimeSpec) -> Self {
              Duration::new(timespec.0.tv_sec as u64, timespec.0.tv_nsec as u32)
          }
      *)
      Definition from (timespec : nix.sys.time.TimeSpec.t) : M Self :=
        let* timespec := M.alloc timespec in
        let* α0 : i64.t :=
          M.read
            (libc.unix.timespec.Get_tv_sec
              (nix.sys.time.TimeSpec.Get_0 timespec)) in
        let* α1 : i64.t :=
          M.read
            (libc.unix.timespec.Get_tv_nsec
              (nix.sys.time.TimeSpec.Get_0 timespec)) in
        M.call (core.time.Duration.t::["new"] (rust_cast α0) (rust_cast α1)).
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := nix.sys.time.TimeSpec.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_nix_sys_time_TimeSpec_t_for_core_time_Duration_t.
    End Impl_core_convert_From_nix_sys_time_TimeSpec_t_for_core_time_Duration_t.
    
    Module  Impl_core_convert_AsRef_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_convert_AsRef_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn as_ref(&self) -> &timespec {
              &self.0
          }
      *)
      Definition as_ref (self : ref Self) : M (ref libc.unix.timespec.t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        M.pure (borrow (nix.sys.time.TimeSpec.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_as_ref :
        Notations.DoubleColon Self "as_ref" := {
        Notations.double_colon := as_ref;
      }.
      
      Global Instance ℐ :
        core.convert.AsRef.Trait Self (T := libc.unix.timespec.t) := {
        core.convert.AsRef.as_ref := as_ref;
      }.
    End Impl_core_convert_AsRef_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_convert_AsRef_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_convert_AsMut_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_convert_AsMut_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn as_mut(&mut self) -> &mut timespec {
              &mut self.0
          }
      *)
      Definition as_mut
          (self : mut_ref Self)
          : M (mut_ref libc.unix.timespec.t) :=
        let* self := M.alloc self in
        let* α0 : mut_ref nix.sys.time.TimeSpec.t := M.read self in
        M.pure (borrow_mut (nix.sys.time.TimeSpec.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_as_mut :
        Notations.DoubleColon Self "as_mut" := {
        Notations.double_colon := as_mut;
      }.
      
      Global Instance ℐ :
        core.convert.AsMut.Trait Self (T := libc.unix.timespec.t) := {
        core.convert.AsMut.as_mut := as_mut;
      }.
    End Impl_core_convert_AsMut_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_convert_AsMut_libc_unix_timespec_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_cmp_Ord_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_cmp_Ord_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn cmp(&self, other: &TimeSpec) -> cmp::Ordering {
              if self.tv_sec() == other.tv_sec() {
                  self.tv_nsec().cmp(&other.tv_nsec())
              } else {
                  self.tv_sec().cmp(&other.tv_sec())
              }
          }
      *)
      Definition cmp
          (self : ref Self)
          (other : ref nix.sys.time.TimeSpec.t)
          : M core.cmp.Ordering.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read other in
        let* α3 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α2) in
        let* α4 : M.Val bool.t := M.alloc (BinOp.Pure.eq α1 α3) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val core.cmp.Ordering.t :=
          if α5 then
            let* α0 : (ref i64.t) -> (ref i64.t) -> M core.cmp.Ordering.t :=
              ltac:(M.get_method (fun ℐ =>
                core.cmp.Ord.cmp (Self := i64.t) (Trait := ℐ))) in
            let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α2 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α1) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            let* α4 : ref nix.sys.time.TimeSpec.t := M.read other in
            let* α5 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α4) in
            let* α6 : M.Val i64.t := M.alloc α5 in
            let* α7 : core.cmp.Ordering.t :=
              M.call (α0 (borrow α3) (borrow α6)) in
            M.alloc α7
          else
            let* α0 : (ref i64.t) -> (ref i64.t) -> M core.cmp.Ordering.t :=
              ltac:(M.get_method (fun ℐ =>
                core.cmp.Ord.cmp (Self := i64.t) (Trait := ℐ))) in
            let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α2 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α1) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            let* α4 : ref nix.sys.time.TimeSpec.t := M.read other in
            let* α5 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α4) in
            let* α6 : M.Val i64.t := M.alloc α5 in
            let* α7 : core.cmp.Ordering.t :=
              M.call (α0 (borrow α3) (borrow α6)) in
            M.alloc α7 in
        M.read α6.
      
      Global Instance AssociatedFunction_cmp :
        Notations.DoubleColon Self "cmp" := {
        Notations.double_colon := cmp;
      }.
      
      Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
        core.cmp.Ord.cmp := cmp;
        core.cmp.Ord.max := Datatypes.None;
        core.cmp.Ord.min := Datatypes.None;
        core.cmp.Ord.clamp := Datatypes.None;
      }.
    End Impl_core_cmp_Ord_for_nix_sys_time_TimeSpec_t.
    End Impl_core_cmp_Ord_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn partial_cmp(&self, other: &TimeSpec) -> Option<cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp
          (self : ref Self)
          (other : ref nix.sys.time.TimeSpec.t)
          : M (core.option.Option.t core.cmp.Ordering.t) :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 :
            (ref nix.sys.time.TimeSpec.t) ->
              (ref nix.sys.time.TimeSpec.t) ->
              M core.cmp.Ordering.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.Ord.cmp (Self := nix.sys.time.TimeSpec.t) (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read other in
        let* α3 : core.cmp.Ordering.t := M.call (α0 α1 α2) in
        M.pure (core.option.Option.Some α3).
      
      Global Instance AssociatedFunction_partial_cmp :
        Notations.DoubleColon Self "partial_cmp" := {
        Notations.double_colon := partial_cmp;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialOrd.Required.Trait Self
          (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
        core.cmp.PartialOrd.partial_cmp := partial_cmp;
        core.cmp.PartialOrd.lt := Datatypes.None;
        core.cmp.PartialOrd.le := Datatypes.None;
        core.cmp.PartialOrd.gt := Datatypes.None;
        core.cmp.PartialOrd.ge := Datatypes.None;
      }.
    End Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeSpec_t.
    End Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeSpec_t.
    Section Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn seconds(seconds: i64) -> TimeSpec {
              assert!(
                  (TS_MIN_SECONDS..=TS_MAX_SECONDS).contains(&seconds),
                  "TimeSpec out of bounds; seconds={seconds}",
              );
              let mut ts = zero_init_timespec();
              ts.tv_sec = seconds as time_t;
              TimeSpec(ts)
          }
      *)
      Definition seconds (seconds : i64.t) : M nix.sys.time.TimeSpec.t :=
        let* seconds := M.alloc seconds in
        let* _ : M.Val unit :=
          let* α0 : i64.t := M.read nix.sys.time.TS_MIN_SECONDS in
          let* α1 : i64.t := M.read nix.sys.time.TS_MAX_SECONDS in
          let* α2 : core.ops.range.RangeInclusive.t i64.t :=
            M.call ((core.ops.range.RangeInclusive.t i64.t)::["new"] α0 α1) in
          let* α3 : M.Val (core.ops.range.RangeInclusive.t i64.t) :=
            M.alloc α2 in
          let* α4 : bool.t :=
            M.call
              ((core.ops.range.RangeInclusive.t i64.t)::["contains"]
                (borrow α3)
                (borrow seconds)) in
          let* α5 : M.Val bool.t := M.alloc (UnOp.not α4) in
          let* α6 : bool.t := M.read (use α5) in
          if α6 then
            let* α0 : ref str.t :=
              M.read (mk_str "TimeSpec out of bounds; seconds=") in
            let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
            let* α2 : core.fmt.rt.Argument.t :=
              M.call
                (core.fmt.rt.Argument.t::["new_display"] (borrow seconds)) in
            let* α3 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α2 ] in
            let* α4 : core.fmt.Arguments.t :=
              M.call
                (core.fmt.Arguments.t::["new_v1"]
                  (pointer_coercion "Unsize" (borrow α1))
                  (pointer_coercion "Unsize" (borrow α3))) in
            let* α5 : never.t := M.call (core.panicking.panic_fmt α4) in
            let* α6 : unit := never_to_any α5 in
            M.alloc α6
          else
            M.alloc tt in
        let* ts : M.Val libc.unix.timespec.t :=
          let* α0 : libc.unix.timespec.t :=
            M.call nix.sys.time.zero_init_timespec in
          M.alloc α0 in
        let* _ : M.Val unit :=
          let* α0 : i64.t := M.read (use seconds) in
          assign (libc.unix.timespec.Get_tv_sec ts) α0 in
        let* α0 : libc.unix.timespec.t := M.read ts in
        let* α0 : M.Val nix.sys.time.TimeSpec.t :=
          M.alloc (nix.sys.time.TimeSpec.Build_t α0) in
        M.read α0.
      
      Global Instance AssociatedFunction_seconds :
        Notations.DoubleColon Self "seconds" := {
        Notations.double_colon := seconds;
      }.
      
      (*
          fn milliseconds(milliseconds: i64) -> TimeSpec {
              let nanoseconds = milliseconds
                  .checked_mul(1_000_000)
                  .expect("TimeSpec::milliseconds out of bounds");
      
              TimeSpec::nanoseconds(nanoseconds)
          }
      *)
      Definition milliseconds
          (milliseconds : i64.t)
          : M nix.sys.time.TimeSpec.t :=
        let* milliseconds := M.alloc milliseconds in
        let* nanoseconds : M.Val i64.t :=
          let* α0 : i64.t := M.read milliseconds in
          let* α1 : core.option.Option.t i64.t :=
            M.call
              (i64.t::["checked_mul"] α0 ((Integer.of_Z 1000000) : i64.t)) in
          let* α2 : ref str.t :=
            M.read (mk_str "TimeSpec::milliseconds out of bounds") in
          let* α3 : i64.t :=
            M.call ((core.option.Option.t i64.t)::["expect"] α1 α2) in
          M.alloc α3 in
        let* α0 : i64.t := M.read nanoseconds in
        let* α1 : nix.sys.time.TimeSpec.t := M.call (nanoseconds α0) in
        let* α0 : M.Val nix.sys.time.TimeSpec.t := M.alloc α1 in
        M.read α0.
      
      Global Instance AssociatedFunction_milliseconds :
        Notations.DoubleColon Self "milliseconds" := {
        Notations.double_colon := milliseconds;
      }.
      
      (*
          fn microseconds(microseconds: i64) -> TimeSpec {
              let nanoseconds = microseconds
                  .checked_mul(1_000)
                  .expect("TimeSpec::milliseconds out of bounds");
      
              TimeSpec::nanoseconds(nanoseconds)
          }
      *)
      Definition microseconds
          (microseconds : i64.t)
          : M nix.sys.time.TimeSpec.t :=
        let* microseconds := M.alloc microseconds in
        let* nanoseconds : M.Val i64.t :=
          let* α0 : i64.t := M.read microseconds in
          let* α1 : core.option.Option.t i64.t :=
            M.call (i64.t::["checked_mul"] α0 ((Integer.of_Z 1000) : i64.t)) in
          let* α2 : ref str.t :=
            M.read (mk_str "TimeSpec::milliseconds out of bounds") in
          let* α3 : i64.t :=
            M.call ((core.option.Option.t i64.t)::["expect"] α1 α2) in
          M.alloc α3 in
        let* α0 : i64.t := M.read nanoseconds in
        let* α1 : nix.sys.time.TimeSpec.t := M.call (nanoseconds α0) in
        let* α0 : M.Val nix.sys.time.TimeSpec.t := M.alloc α1 in
        M.read α0.
      
      Global Instance AssociatedFunction_microseconds :
        Notations.DoubleColon Self "microseconds" := {
        Notations.double_colon := microseconds;
      }.
      
      (*
          fn nanoseconds(nanoseconds: i64) -> TimeSpec {
              let (secs, nanos) = div_mod_floor_64(nanoseconds, NANOS_PER_SEC);
              assert!(
                  (TS_MIN_SECONDS..=TS_MAX_SECONDS).contains(&secs),
                  "TimeSpec out of bounds"
              );
              let mut ts = zero_init_timespec();
              ts.tv_sec = secs as time_t;
              ts.tv_nsec = nanos as timespec_tv_nsec_t;
              TimeSpec(ts)
          }
      *)
      Definition nanoseconds
          (nanoseconds : i64.t)
          : M nix.sys.time.TimeSpec.t :=
        let* nanoseconds := M.alloc nanoseconds in
        let* α0 : i64.t := M.read nanoseconds in
        let* α1 : i64.t := M.read nix.sys.time.NANOS_PER_SEC in
        let* α2 : i64.t * i64.t :=
          M.call (nix.sys.time.div_mod_floor_64 α0 α1) in
        let* α3 : M.Val (i64.t * i64.t) := M.alloc α2 in
        let* α4 : M.Val nix.sys.time.TimeSpec.t :=
          match_operator
            α3
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let* secs := M.copy γ0_0 in
                  let* nanos := M.copy γ0_1 in
                  let* _ : M.Val unit :=
                    let* α0 : i64.t := M.read nix.sys.time.TS_MIN_SECONDS in
                    let* α1 : i64.t := M.read nix.sys.time.TS_MAX_SECONDS in
                    let* α2 : core.ops.range.RangeInclusive.t i64.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["new"]
                          α0
                          α1) in
                    let* α3 : M.Val (core.ops.range.RangeInclusive.t i64.t) :=
                      M.alloc α2 in
                    let* α4 : bool.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["contains"]
                          (borrow α3)
                          (borrow secs)) in
                    let* α5 : M.Val bool.t := M.alloc (UnOp.not α4) in
                    let* α6 : bool.t := M.read (use α5) in
                    if α6 then
                      let* α0 : ref str.t :=
                        M.read (mk_str "TimeSpec out of bounds") in
                      let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                      let* α2 : core.fmt.Arguments.t :=
                        M.call
                          (core.fmt.Arguments.t::["new_const"]
                            (pointer_coercion "Unsize" (borrow α1))) in
                      let* α3 : never.t :=
                        M.call (core.panicking.panic_fmt α2) in
                      let* α4 : unit := never_to_any α3 in
                      M.alloc α4
                    else
                      M.alloc tt in
                  let* ts : M.Val libc.unix.timespec.t :=
                    let* α0 : libc.unix.timespec.t :=
                      M.call nix.sys.time.zero_init_timespec in
                    M.alloc α0 in
                  let* _ : M.Val unit :=
                    let* α0 : i64.t := M.read (use secs) in
                    assign (libc.unix.timespec.Get_tv_sec ts) α0 in
                  let* _ : M.Val unit :=
                    let* α0 : i64.t := M.read (use nanos) in
                    assign (libc.unix.timespec.Get_tv_nsec ts) α0 in
                  let* α0 : libc.unix.timespec.t := M.read ts in
                  M.alloc (nix.sys.time.TimeSpec.Build_t α0)
                end) :
                M (M.Val nix.sys.time.TimeSpec.t)
            ] in
        M.read α4.
      
      Global Instance AssociatedFunction_nanoseconds :
        Notations.DoubleColon Self "nanoseconds" := {
        Notations.double_colon := nanoseconds;
      }.
      
      (*
          fn num_seconds(&self) -> i64 {
              if self.tv_sec() < 0 && self.tv_nsec() > 0 {
                  (self.tv_sec() + 1) as i64
              } else {
                  self.tv_sec() as i64
              }
          }
      *)
      Definition num_seconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α3 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α2) in
        let* α4 : M.Val bool.t :=
          M.alloc
            (BinOp.Pure.and
              (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t))
              (BinOp.Pure.gt α3 ((Integer.of_Z 0) : i64.t))) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val i64.t :=
          if α5 then
            let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
            let* α2 : i64.t := BinOp.Panic.add α1 ((Integer.of_Z 1) : i64.t) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            M.pure (use α3)
          else
            let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
            let* α2 : M.Val i64.t := M.alloc α1 in
            M.pure (use α2) in
        M.read α6.
      
      Global Instance AssociatedFunction_num_seconds :
        Notations.DoubleColon Self "num_seconds" := {
        Notations.double_colon := num_seconds;
      }.
      
      (*
          fn num_milliseconds(&self) -> i64 {
              self.num_nanoseconds() / 1_000_000
          }
      *)
      Definition num_milliseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α1 : i64.t := M.call (num_nanoseconds α0) in
        BinOp.Panic.div α1 ((Integer.of_Z 1000000) : i64.t).
      
      Global Instance AssociatedFunction_num_milliseconds :
        Notations.DoubleColon Self "num_milliseconds" := {
        Notations.double_colon := num_milliseconds;
      }.
      
      (*
          fn num_microseconds(&self) -> i64 {
              self.num_nanoseconds() / 1_000
          }
      *)
      Definition num_microseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α1 : i64.t := M.call (num_nanoseconds α0) in
        BinOp.Panic.div α1 ((Integer.of_Z 1000) : i64.t).
      
      Global Instance AssociatedFunction_num_microseconds :
        Notations.DoubleColon Self "num_microseconds" := {
        Notations.double_colon := num_microseconds;
      }.
      
      (*
          fn num_nanoseconds(&self) -> i64 {
              let secs = self.num_seconds() * 1_000_000_000;
              let nsec = self.nanos_mod_sec();
              secs + nsec as i64
          }
      *)
      Definition num_nanoseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* secs : M.Val i64.t :=
          let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
          let* α1 : i64.t := M.call (num_seconds α0) in
          let* α2 : i64.t :=
            BinOp.Panic.mul α1 ((Integer.of_Z 1000000000) : i64.t) in
          M.alloc α2 in
        let* nsec : M.Val i64.t :=
          let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
          let* α1 : i64.t :=
            M.call (nix.sys.time.TimeSpec.t::["nanos_mod_sec"] α0) in
          M.alloc α1 in
        let* α0 : i64.t := M.read secs in
        let* α1 : i64.t := M.read (use nsec) in
        let* α2 : i64.t := BinOp.Panic.add α0 α1 in
        let* α0 : M.Val i64.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_num_nanoseconds :
        Notations.DoubleColon Self "num_nanoseconds" := {
        Notations.double_colon := num_nanoseconds;
      }.
      
      Global Instance ℐ : nix.sys.time.TimeValLike.Required.Trait Self := {
        nix.sys.time.TimeValLike.seconds := seconds;
        nix.sys.time.TimeValLike.milliseconds := milliseconds;
        nix.sys.time.TimeValLike.microseconds := microseconds;
        nix.sys.time.TimeValLike.nanoseconds := nanoseconds;
        nix.sys.time.TimeValLike.num_seconds := num_seconds;
        nix.sys.time.TimeValLike.num_milliseconds := num_milliseconds;
        nix.sys.time.TimeValLike.num_microseconds := num_microseconds;
        nix.sys.time.TimeValLike.num_nanoseconds := num_nanoseconds;
        nix.sys.time.TimeValLike.zero := Datatypes.None;
        nix.sys.time.TimeValLike.hours := Datatypes.None;
        nix.sys.time.TimeValLike.minutes := Datatypes.None;
        nix.sys.time.TimeValLike.num_hours := Datatypes.None;
        nix.sys.time.TimeValLike.num_minutes := Datatypes.None;
      }.
    End Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeSpec_t.
    End Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_nix_sys_time_TimeSpec_t.
    Section Impl_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          pub const UTIME_OMIT: TimeSpec =
              TimeSpec::new(0, libc::UTIME_OMIT as timespec_tv_nsec_t);
      *)
      
      Definition UTIME_OMIT : nix.sys.time.TimeSpec.t :=
        M.run
          (let* α0 : i64.t := M.read (use libc.unix.linux_like.UTIME_OMIT) in
          let* α1 : nix.sys.time.TimeSpec.t :=
            M.call
              (nix.sys.time.TimeSpec.t::["new"]
                ((Integer.of_Z 0) : i64.t)
                α0) in
          M.alloc α1).
      
      Global Instance AssociatedFunction_UTIME_OMIT :
        Notations.DoubleColon Self "UTIME_OMIT" := {
        Notations.double_colon := UTIME_OMIT;
      }.
      
      (*
          pub const UTIME_NOW: TimeSpec =
              TimeSpec::new(0, libc::UTIME_NOW as timespec_tv_nsec_t);
      *)
      
      Definition UTIME_NOW : nix.sys.time.TimeSpec.t :=
        M.run
          (let* α0 : i64.t := M.read (use libc.unix.linux_like.UTIME_NOW) in
          let* α1 : nix.sys.time.TimeSpec.t :=
            M.call
              (nix.sys.time.TimeSpec.t::["new"]
                ((Integer.of_Z 0) : i64.t)
                α0) in
          M.alloc α1).
      
      Global Instance AssociatedFunction_UTIME_NOW :
        Notations.DoubleColon Self "UTIME_NOW" := {
        Notations.double_colon := UTIME_NOW;
      }.
      
      (*
          pub const fn new(seconds: time_t, nanoseconds: timespec_tv_nsec_t) -> Self {
              let mut ts = zero_init_timespec();
              ts.tv_sec = seconds;
              ts.tv_nsec = nanoseconds;
              Self(ts)
          }
      *)
      Definition new
          (seconds : ltac:(libc.unix.linux_like.linux.gnu.b64.time_t))
          (nanoseconds : ltac:(nix.sys.time.timespec_tv_nsec_t))
          : M Self :=
        let* seconds := M.alloc seconds in
        let* nanoseconds := M.alloc nanoseconds in
        let* ts : M.Val libc.unix.timespec.t :=
          let* α0 : libc.unix.timespec.t :=
            M.call nix.sys.time.zero_init_timespec in
          M.alloc α0 in
        let* _ : M.Val unit :=
          let* α0 : i64.t := M.read seconds in
          assign (libc.unix.timespec.Get_tv_sec ts) α0 in
        let* _ : M.Val unit :=
          let* α0 : i64.t := M.read nanoseconds in
          assign (libc.unix.timespec.Get_tv_nsec ts) α0 in
        let* α0 : libc.unix.timespec.t := M.read ts in
        let* α0 : M.Val nix.sys.time.TimeSpec.t :=
          M.alloc (nix.sys.time.TimeSpec.Build_t α0) in
        M.read α0.
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          fn nanos_mod_sec(&self) -> timespec_tv_nsec_t {
              if self.tv_sec() < 0 && self.tv_nsec() > 0 {
                  self.tv_nsec() - NANOS_PER_SEC as timespec_tv_nsec_t
              } else {
                  self.tv_nsec()
              }
          }
      *)
      Definition nanos_mod_sec
          (self : ref Self)
          : M ltac:(nix.sys.time.timespec_tv_nsec_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeSpec.t := M.read self in
        let* α3 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α2) in
        let* α4 : M.Val bool.t :=
          M.alloc
            (BinOp.Pure.and
              (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t))
              (BinOp.Pure.gt α3 ((Integer.of_Z 0) : i64.t))) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val i64.t :=
          if α5 then
            let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α0) in
            let* α2 : i64.t := M.read (use nix.sys.time.NANOS_PER_SEC) in
            let* α3 : i64.t := BinOp.Panic.sub α1 α2 in
            M.alloc α3
          else
            let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeSpec.t::["tv_nsec"] α0) in
            M.alloc α1 in
        M.read α6.
      
      Global Instance AssociatedFunction_nanos_mod_sec :
        Notations.DoubleColon Self "nanos_mod_sec" := {
        Notations.double_colon := nanos_mod_sec;
      }.
      
      (*
          pub const fn tv_sec(&self) -> time_t {
              self.0.tv_sec
          }
      *)
      Definition tv_sec
          (self : ref Self)
          : M ltac:(libc.unix.linux_like.linux.gnu.b64.time_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        M.read
          (libc.unix.timespec.Get_tv_sec
            (nix.sys.time.TimeSpec.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_tv_sec :
        Notations.DoubleColon Self "tv_sec" := {
        Notations.double_colon := tv_sec;
      }.
      
      (*
          pub const fn tv_nsec(&self) -> timespec_tv_nsec_t {
              self.0.tv_nsec
          }
      *)
      Definition tv_nsec
          (self : ref Self)
          : M ltac:(nix.sys.time.timespec_tv_nsec_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
        M.read
          (libc.unix.timespec.Get_tv_nsec
            (nix.sys.time.TimeSpec.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_tv_nsec :
        Notations.DoubleColon Self "tv_nsec" := {
        Notations.double_colon := tv_nsec;
      }.
      
      (*
          pub const fn from_duration(duration: Duration) -> Self {
              let mut ts = zero_init_timespec();
              ts.tv_sec = duration.as_secs() as time_t;
              ts.tv_nsec = duration.subsec_nanos() as timespec_tv_nsec_t;
              TimeSpec(ts)
          }
      *)
      Definition from_duration (duration : core.time.Duration.t) : M Self :=
        let* duration := M.alloc duration in
        let* ts : M.Val libc.unix.timespec.t :=
          let* α0 : libc.unix.timespec.t :=
            M.call nix.sys.time.zero_init_timespec in
          M.alloc α0 in
        let* _ : M.Val unit :=
          let* α0 : u64.t :=
            M.call (core.time.Duration.t::["as_secs"] (borrow duration)) in
          assign (libc.unix.timespec.Get_tv_sec ts) (rust_cast α0) in
        let* _ : M.Val unit :=
          let* α0 : u32.t :=
            M.call (core.time.Duration.t::["subsec_nanos"] (borrow duration)) in
          assign (libc.unix.timespec.Get_tv_nsec ts) (rust_cast α0) in
        let* α0 : libc.unix.timespec.t := M.read ts in
        let* α0 : M.Val nix.sys.time.TimeSpec.t :=
          M.alloc (nix.sys.time.TimeSpec.Build_t α0) in
        M.read α0.
      
      Global Instance AssociatedFunction_from_duration :
        Notations.DoubleColon Self "from_duration" := {
        Notations.double_colon := from_duration;
      }.
      
      (*
          pub const fn from_timespec(timespec: timespec) -> Self {
              Self(timespec)
          }
      *)
      Definition from_timespec (timespec : libc.unix.timespec.t) : M Self :=
        let* timespec := M.alloc timespec in
        let* α0 : libc.unix.timespec.t := M.read timespec in
        M.pure (nix.sys.time.TimeSpec.Build_t α0).
      
      Global Instance AssociatedFunction_from_timespec :
        Notations.DoubleColon Self "from_timespec" := {
        Notations.double_colon := from_timespec;
      }.
    End Impl_nix_sys_time_TimeSpec_t.
    End Impl_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_ops_arith_Neg_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_ops_arith_Neg_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          type Output = TimeSpec;
      *)
      Definition Output : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn neg(self) -> TimeSpec {
              TimeSpec::nanoseconds(-self.num_nanoseconds())
          }
      *)
      Definition neg (self : Self) : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* α0 : i64.t -> M nix.sys.time.TimeSpec.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : i64.t := UnOp.neg α2 in
        M.call (α0 α3).
      
      Global Instance AssociatedFunction_neg :
        Notations.DoubleColon Self "neg" := {
        Notations.double_colon := neg;
      }.
      
      Global Instance ℐ : core.ops.arith.Neg.Trait Self := {
        core.ops.arith.Neg.Output := Output;
        core.ops.arith.Neg.neg := neg;
      }.
    End Impl_core_ops_arith_Neg_for_nix_sys_time_TimeSpec_t.
    End Impl_core_ops_arith_Neg_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_ops_arith_Add_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_ops_arith_Add_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          type Output = TimeSpec;
      *)
      Definition Output : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn add(self, rhs: TimeSpec) -> TimeSpec {
              TimeSpec::nanoseconds(self.num_nanoseconds() + rhs.num_nanoseconds())
          }
      *)
      Definition add
          (self : Self)
          (rhs : nix.sys.time.TimeSpec.t)
          : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* α0 : i64.t -> M nix.sys.time.TimeSpec.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α4 : i64.t := M.call (α3 (borrow rhs)) in
        let* α5 : i64.t := BinOp.Panic.add α2 α4 in
        M.call (α0 α5).
      
      Global Instance AssociatedFunction_add :
        Notations.DoubleColon Self "add" := {
        Notations.double_colon := add;
      }.
      
      Global Instance ℐ :
        core.ops.arith.Add.Trait Self
          (Rhs := core.ops.arith.Add.Default.Rhs Self) := {
        core.ops.arith.Add.Output := Output;
        core.ops.arith.Add.add := add;
      }.
    End Impl_core_ops_arith_Add_for_nix_sys_time_TimeSpec_t.
    End Impl_core_ops_arith_Add_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_ops_arith_Sub_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_ops_arith_Sub_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          type Output = TimeSpec;
      *)
      Definition Output : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn sub(self, rhs: TimeSpec) -> TimeSpec {
              TimeSpec::nanoseconds(self.num_nanoseconds() - rhs.num_nanoseconds())
          }
      *)
      Definition sub
          (self : Self)
          (rhs : nix.sys.time.TimeSpec.t)
          : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* α0 : i64.t -> M nix.sys.time.TimeSpec.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α4 : i64.t := M.call (α3 (borrow rhs)) in
        let* α5 : i64.t := BinOp.Panic.sub α2 α4 in
        M.call (α0 α5).
      
      Global Instance AssociatedFunction_sub :
        Notations.DoubleColon Self "sub" := {
        Notations.double_colon := sub;
      }.
      
      Global Instance ℐ :
        core.ops.arith.Sub.Trait Self
          (Rhs := core.ops.arith.Sub.Default.Rhs Self) := {
        core.ops.arith.Sub.Output := Output;
        core.ops.arith.Sub.sub := sub;
      }.
    End Impl_core_ops_arith_Sub_for_nix_sys_time_TimeSpec_t.
    End Impl_core_ops_arith_Sub_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          type Output = TimeSpec;
      *)
      Definition Output : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn mul(self, rhs: i32) -> TimeSpec {
              let usec = self
                  .num_nanoseconds()
                  .checked_mul(i64::from(rhs))
                  .expect("TimeSpec multiply out of bounds");
      
              TimeSpec::nanoseconds(usec)
          }
      *)
      Definition mul (self : Self) (rhs : i32.t) : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* usec : M.Val i64.t :=
          let* α0 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              nix.sys.time.TimeValLike.num_nanoseconds
                (Self := nix.sys.time.TimeSpec.t)
                (Trait := ℐ))) in
          let* α1 : i64.t := M.call (α0 (borrow self)) in
          let* α2 : i32.t -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := i64.t)
                (T := i32.t)
                (Trait := ℐ))) in
          let* α3 : i32.t := M.read rhs in
          let* α4 : i64.t := M.call (α2 α3) in
          let* α5 : core.option.Option.t i64.t :=
            M.call (i64.t::["checked_mul"] α1 α4) in
          let* α6 : ref str.t :=
            M.read (mk_str "TimeSpec multiply out of bounds") in
          let* α7 : i64.t :=
            M.call ((core.option.Option.t i64.t)::["expect"] α5 α6) in
          M.alloc α7 in
        let* α0 : i64.t -> M nix.sys.time.TimeSpec.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α1 : i64.t := M.read usec in
        let* α2 : nix.sys.time.TimeSpec.t := M.call (α0 α1) in
        let* α0 : M.Val nix.sys.time.TimeSpec.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_mul :
        Notations.DoubleColon Self "mul" := {
        Notations.double_colon := mul;
      }.
      
      Global Instance ℐ : core.ops.arith.Mul.Trait Self (Rhs := i32.t) := {
        core.ops.arith.Mul.Output := Output;
        core.ops.arith.Mul.mul := mul;
      }.
    End Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          type Output = TimeSpec;
      *)
      Definition Output : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn div(self, rhs: i32) -> TimeSpec {
              let usec = self.num_nanoseconds() / i64::from(rhs);
              TimeSpec::nanoseconds(usec)
          }
      *)
      Definition div (self : Self) (rhs : i32.t) : M nix.sys.time.TimeSpec.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* usec : M.Val i64.t :=
          let* α0 : (ref nix.sys.time.TimeSpec.t) -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              nix.sys.time.TimeValLike.num_nanoseconds
                (Self := nix.sys.time.TimeSpec.t)
                (Trait := ℐ))) in
          let* α1 : i64.t := M.call (α0 (borrow self)) in
          let* α2 : i32.t -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := i64.t)
                (T := i32.t)
                (Trait := ℐ))) in
          let* α3 : i32.t := M.read rhs in
          let* α4 : i64.t := M.call (α2 α3) in
          let* α5 : i64.t := BinOp.Panic.div α1 α4 in
          M.alloc α5 in
        let* α0 : i64.t -> M nix.sys.time.TimeSpec.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.nanoseconds
              (Self := nix.sys.time.TimeSpec.t)
              (Trait := ℐ))) in
        let* α1 : i64.t := M.read usec in
        let* α2 : nix.sys.time.TimeSpec.t := M.call (α0 α1) in
        let* α0 : M.Val nix.sys.time.TimeSpec.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_div :
        Notations.DoubleColon Self "div" := {
        Notations.double_colon := div;
      }.
      
      Global Instance ℐ : core.ops.arith.Div.Trait Self (Rhs := i32.t) := {
        core.ops.arith.Div.Output := Output;
        core.ops.arith.Div.div := div;
      }.
    End Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeSpec_t.
    End Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeSpec_t.
    
    Module  Impl_core_fmt_Display_for_nix_sys_time_TimeSpec_t.
    Section Impl_core_fmt_Display_for_nix_sys_time_TimeSpec_t.
      Definition Self : Set := nix.sys.time.TimeSpec.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
              let (abs, sign) = if self.tv_sec() < 0 {
                  (-*self, "-")
              } else {
                  ( *self, "")
              };
      
              let sec = abs.tv_sec();
      
              write!(f, "{sign}")?;
      
              if abs.tv_nsec() == 0 {
                  if sec == 1 {
                      write!(f, "1 second")?;
                  } else {
                      write!(f, "{sec} seconds")?;
                  }
              } else if abs.tv_nsec() % 1_000_000 == 0 {
                  write!(f, "{sec}.{:03} seconds", abs.tv_nsec() / 1_000_000)?;
              } else if abs.tv_nsec() % 1_000 == 0 {
                  write!(f, "{sec}.{:06} seconds", abs.tv_nsec() / 1_000)?;
              } else {
                  write!(f, "{sec}.{:09} seconds", abs.tv_nsec())?;
              }
      
              Ok(())
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let return_ := M.return_ (R := ltac:(core.fmt.Result)) in
        M.catch_return
          (let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
          let* α1 : i64.t := M.call (nix.sys.time.TimeSpec.t::["tv_sec"] α0) in
          let* α2 : M.Val bool.t :=
            M.alloc (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t)) in
          let* α3 : bool.t := M.read (use α2) in
          let* α4 : M.Val (nix.sys.time.TimeSpec.t * (ref str.t)) :=
            if α3 then
              let* α0 : nix.sys.time.TimeSpec.t -> M _ :=
                ltac:(M.get_method (fun ℐ =>
                  core.ops.arith.Neg.neg
                    (Self := nix.sys.time.TimeSpec.t)
                    (Trait := ℐ))) in
              let* α1 : ref nix.sys.time.TimeSpec.t := M.read self in
              let* α2 : nix.sys.time.TimeSpec.t := M.read (deref α1) in
              let* α3 : nix.sys.time.TimeSpec.t := M.call (α0 α2) in
              let* α4 : ref str.t := M.read (mk_str "-") in
              M.alloc (α3, α4)
            else
              let* α0 : ref nix.sys.time.TimeSpec.t := M.read self in
              let* α1 : nix.sys.time.TimeSpec.t := M.read (deref α0) in
              let* α2 : ref str.t := M.read (mk_str "") in
              M.alloc (α1, α2) in
          let* α5 : M.Val (core.result.Result.t unit core.fmt.Error.t) :=
            match_operator
              α4
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | (_, _) =>
                    let γ0_0 := Tuple.Access.left γ in
                    let γ0_1 := Tuple.Access.right γ in
                    let* abs := M.copy γ0_0 in
                    let* sign := M.copy γ0_1 in
                    let* sec : M.Val i64.t :=
                      let* α0 : i64.t :=
                        M.call
                          (nix.sys.time.TimeSpec.t::["tv_sec"] (borrow abs)) in
                      M.alloc α0 in
                    let* _ : M.Val unit :=
                      let* α0 :
                          (core.result.Result.t unit core.fmt.Error.t) ->
                            M (core.ops.control_flow.ControlFlow.t _ _) :=
                        ltac:(M.get_method (fun ℐ =>
                          core.ops.try_trait.Try.branch
                            (Self := core.result.Result.t unit core.fmt.Error.t)
                            (Trait := ℐ))) in
                      let* α1 : mut_ref core.fmt.Formatter.t := M.read f in
                      let* α2 : ref str.t := M.read (mk_str "") in
                      let* α3 : M.Val (array (ref str.t)) := M.alloc [ α2 ] in
                      let* α4 : core.fmt.rt.Argument.t :=
                        M.call
                          (core.fmt.rt.Argument.t::["new_display"]
                            (borrow sign)) in
                      let* α5 : M.Val (array core.fmt.rt.Argument.t) :=
                        M.alloc [ α4 ] in
                      let* α6 : core.fmt.Arguments.t :=
                        M.call
                          (core.fmt.Arguments.t::["new_v1"]
                            (pointer_coercion "Unsize" (borrow α3))
                            (pointer_coercion "Unsize" (borrow α5))) in
                      let* α7 : core.result.Result.t unit core.fmt.Error.t :=
                        M.call (core.fmt.Formatter.t::["write_fmt"] α1 α6) in
                      let* α8 :
                          core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              core.fmt.Error.t)
                            unit :=
                        M.call (α0 α7) in
                      let* α9 :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                core.fmt.Error.t)
                              unit) :=
                        M.alloc α8 in
                      match_operator
                        α9
                        [
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.ops.control_flow.ControlFlow.Break _ =>
                              let γ0_0 :=
                                core.ops.control_flow.ControlFlow.Get_Break_0
                                  γ in
                              let* residual := M.copy γ0_0 in
                              let* α0 :
                                  (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    ->
                                    M
                                      (core.result.Result.t
                                        unit
                                        core.fmt.Error.t) :=
                                ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t
                                        unit
                                        core.fmt.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        core.fmt.Error.t)
                                    (Trait := ℐ))) in
                              let* α1 :
                                  core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t :=
                                M.read residual in
                              let* α2 :
                                  core.result.Result.t unit core.fmt.Error.t :=
                                M.call (α0 α1) in
                              let* α3 : M.Val never.t := return_ α2 in
                              let* α4 := M.read α3 in
                              let* α5 : unit := never_to_any α4 in
                              M.alloc α5
                            | _ => M.break_match
                            end) :
                            M (M.Val unit);
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.ops.control_flow.ControlFlow.Continue _ =>
                              let γ0_0 :=
                                core.ops.control_flow.ControlFlow.Get_Continue_0
                                  γ in
                              let* val := M.copy γ0_0 in
                              M.pure val
                            | _ => M.break_match
                            end) :
                            M (M.Val unit)
                        ] in
                    let* _ : M.Val unit :=
                      let* α0 : i64.t :=
                        M.call
                          (nix.sys.time.TimeSpec.t::["tv_nsec"] (borrow abs)) in
                      let* α1 : M.Val bool.t :=
                        M.alloc (BinOp.Pure.eq α0 ((Integer.of_Z 0) : i64.t)) in
                      let* α2 : bool.t := M.read (use α1) in
                      if α2 then
                        let* α0 : i64.t := M.read sec in
                        let* α1 : M.Val bool.t :=
                          M.alloc
                            (BinOp.Pure.eq α0 ((Integer.of_Z 1) : i64.t)) in
                        let* α2 : bool.t := M.read (use α1) in
                        if α2 then
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "1 second") in
                            let* α3 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2 ] in
                            let* α4 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_const"]
                                  (pointer_coercion "Unsize" (borrow α3))) in
                            let* α5 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α4) in
                            let* α6 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α5) in
                            let* α7 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α6 in
                            match_operator
                              α7
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                        else
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "") in
                            let* α3 : ref str.t := M.read (mk_str " seconds") in
                            let* α4 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2; α3 ] in
                            let* α5 : core.fmt.rt.Argument.t :=
                              M.call
                                (core.fmt.rt.Argument.t::["new_display"]
                                  (borrow sec)) in
                            let* α6 : M.Val (array core.fmt.rt.Argument.t) :=
                              M.alloc [ α5 ] in
                            let* α7 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_v1"]
                                  (pointer_coercion "Unsize" (borrow α4))
                                  (pointer_coercion "Unsize" (borrow α6))) in
                            let* α8 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α7) in
                            let* α9 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α8) in
                            let* α10 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α9 in
                            match_operator
                              α10
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                      else
                        let* α0 : i64.t :=
                          M.call
                            (nix.sys.time.TimeSpec.t::["tv_nsec"]
                              (borrow abs)) in
                        let* α1 : i64.t :=
                          BinOp.Panic.rem α0 ((Integer.of_Z 1000000) : i64.t) in
                        let* α2 : M.Val bool.t :=
                          M.alloc
                            (BinOp.Pure.eq α1 ((Integer.of_Z 0) : i64.t)) in
                        let* α3 : bool.t := M.read (use α2) in
                        if α3 then
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "") in
                            let* α3 : ref str.t := M.read (mk_str ".") in
                            let* α4 : ref str.t := M.read (mk_str " seconds") in
                            let* α5 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2; α3; α4 ] in
                            let* α6 : i64.t :=
                              M.call
                                (nix.sys.time.TimeSpec.t::["tv_nsec"]
                                  (borrow abs)) in
                            let* α7 : i64.t :=
                              BinOp.Panic.div
                                α6
                                ((Integer.of_Z 1000000) : i64.t) in
                            let* α8 : M.Val i64.t := M.alloc α7 in
                            let* α9 : M.Val ((ref i64.t) * (ref i64.t)) :=
                              M.alloc (borrow α8, borrow sec) in
                            let* α10 : M.Val (array core.fmt.rt.Argument.t) :=
                              match_operator
                                α9
                                [
                                  fun γ =>
                                    (let* args := M.copy γ in
                                    let* α0 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α1 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α0) in
                                    let* α2 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α3 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α2) in
                                    M.alloc [ α1; α3 ]) :
                                    M (M.Val (array core.fmt.rt.Argument.t))
                                ] in
                            let* α11 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 0) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 0) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  core.fmt.rt.Count.Implied) in
                            let* α12 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 1) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 8) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  (core.fmt.rt.Count.Is
                                    ((Integer.of_Z 3) : usize.t))) in
                            let* α13 :
                                M.Val (array core.fmt.rt.Placeholder.t) :=
                              M.alloc [ α11; α12 ] in
                            let* α14 : core.fmt.rt.UnsafeArg.t :=
                              M.call core.fmt.rt.UnsafeArg.t::["new"] in
                            let* α15 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_v1_formatted"]
                                  (pointer_coercion "Unsize" (borrow α5))
                                  (pointer_coercion "Unsize" (borrow α10))
                                  (pointer_coercion "Unsize" (borrow α13))
                                  α14) in
                            let* α16 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α15) in
                            let* α17 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α16) in
                            let* α18 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α17 in
                            match_operator
                              α18
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                        else
                          let* α0 : i64.t :=
                            M.call
                              (nix.sys.time.TimeSpec.t::["tv_nsec"]
                                (borrow abs)) in
                          let* α1 : i64.t :=
                            BinOp.Panic.rem α0 ((Integer.of_Z 1000) : i64.t) in
                          let* α2 : M.Val bool.t :=
                            M.alloc
                              (BinOp.Pure.eq α1 ((Integer.of_Z 0) : i64.t)) in
                          let* α3 : bool.t := M.read (use α2) in
                          if α3 then
                            let* _ : M.Val unit :=
                              let* α0 :
                                  (core.result.Result.t unit core.fmt.Error.t)
                                    ->
                                    M
                                      (core.ops.control_flow.ControlFlow.t
                                        _
                                        _) :=
                                ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.Try.branch
                                    (Self :=
                                      core.result.Result.t
                                        unit
                                        core.fmt.Error.t)
                                    (Trait := ℐ))) in
                              let* α1 : mut_ref core.fmt.Formatter.t :=
                                M.read f in
                              let* α2 : ref str.t := M.read (mk_str "") in
                              let* α3 : ref str.t := M.read (mk_str ".") in
                              let* α4 : ref str.t :=
                                M.read (mk_str " seconds") in
                              let* α5 : M.Val (array (ref str.t)) :=
                                M.alloc [ α2; α3; α4 ] in
                              let* α6 : i64.t :=
                                M.call
                                  (nix.sys.time.TimeSpec.t::["tv_nsec"]
                                    (borrow abs)) in
                              let* α7 : i64.t :=
                                BinOp.Panic.div
                                  α6
                                  ((Integer.of_Z 1000) : i64.t) in
                              let* α8 : M.Val i64.t := M.alloc α7 in
                              let* α9 : M.Val ((ref i64.t) * (ref i64.t)) :=
                                M.alloc (borrow α8, borrow sec) in
                              let* α10 : M.Val (array core.fmt.rt.Argument.t) :=
                                match_operator
                                  α9
                                  [
                                    fun γ =>
                                      (let* args := M.copy γ in
                                      let* α0 : ref i64.t :=
                                        M.read "Unknown Field" in
                                      let* α1 : core.fmt.rt.Argument.t :=
                                        M.call
                                          (core.fmt.rt.Argument.t::["new_display"]
                                            α0) in
                                      let* α2 : ref i64.t :=
                                        M.read "Unknown Field" in
                                      let* α3 : core.fmt.rt.Argument.t :=
                                        M.call
                                          (core.fmt.rt.Argument.t::["new_display"]
                                            α2) in
                                      M.alloc [ α1; α3 ]) :
                                      M (M.Val (array core.fmt.rt.Argument.t))
                                  ] in
                              let* α11 : core.fmt.rt.Placeholder.t :=
                                M.call
                                  (core.fmt.rt.Placeholder.t::["new"]
                                    ((Integer.of_Z 0) : usize.t)
                                    " "%char
                                    core.fmt.rt.Alignment.Unknown
                                    ((Integer.of_Z 0) : u32.t)
                                    core.fmt.rt.Count.Implied
                                    core.fmt.rt.Count.Implied) in
                              let* α12 : core.fmt.rt.Placeholder.t :=
                                M.call
                                  (core.fmt.rt.Placeholder.t::["new"]
                                    ((Integer.of_Z 1) : usize.t)
                                    " "%char
                                    core.fmt.rt.Alignment.Unknown
                                    ((Integer.of_Z 8) : u32.t)
                                    core.fmt.rt.Count.Implied
                                    (core.fmt.rt.Count.Is
                                      ((Integer.of_Z 6) : usize.t))) in
                              let* α13 :
                                  M.Val (array core.fmt.rt.Placeholder.t) :=
                                M.alloc [ α11; α12 ] in
                              let* α14 : core.fmt.rt.UnsafeArg.t :=
                                M.call core.fmt.rt.UnsafeArg.t::["new"] in
                              let* α15 : core.fmt.Arguments.t :=
                                M.call
                                  (core.fmt.Arguments.t::["new_v1_formatted"]
                                    (pointer_coercion "Unsize" (borrow α5))
                                    (pointer_coercion "Unsize" (borrow α10))
                                    (pointer_coercion "Unsize" (borrow α13))
                                    α14) in
                              let* α16 :
                                  core.result.Result.t unit core.fmt.Error.t :=
                                M.call
                                  (core.fmt.Formatter.t::["write_fmt"]
                                    α1
                                    α15) in
                              let* α17 :
                                  core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit :=
                                M.call (α0 α16) in
                              let* α18 :
                                  M.Val
                                    (core.ops.control_flow.ControlFlow.t
                                      (core.result.Result.t
                                        core.convert.Infallible.t
                                        core.fmt.Error.t)
                                      unit) :=
                                M.alloc α17 in
                              match_operator
                                α18
                                [
                                  fun γ =>
                                    (let* α0 := M.read γ in
                                    match α0 with
                                    |
                                        core.ops.control_flow.ControlFlow.Break
                                          _
                                        =>
                                      let γ0_0 :=
                                        core.ops.control_flow.ControlFlow.Get_Break_0
                                          γ in
                                      let* residual := M.copy γ0_0 in
                                      let* α0 :
                                          (core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                            ->
                                            M
                                              (core.result.Result.t
                                                unit
                                                core.fmt.Error.t) :=
                                        ltac:(M.get_method (fun ℐ =>
                                          core.ops.try_trait.FromResidual.from_residual
                                            (Self :=
                                              core.result.Result.t
                                                unit
                                                core.fmt.Error.t)
                                            (R :=
                                              core.result.Result.t
                                                core.convert.Infallible.t
                                                core.fmt.Error.t)
                                            (Trait := ℐ))) in
                                      let* α1 :
                                          core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t :=
                                        M.read residual in
                                      let* α2 :
                                          core.result.Result.t
                                            unit
                                            core.fmt.Error.t :=
                                        M.call (α0 α1) in
                                      let* α3 : M.Val never.t := return_ α2 in
                                      let* α4 := M.read α3 in
                                      let* α5 : unit := never_to_any α4 in
                                      M.alloc α5
                                    | _ => M.break_match
                                    end) :
                                    M (M.Val unit);
                                  fun γ =>
                                    (let* α0 := M.read γ in
                                    match α0 with
                                    |
                                        core.ops.control_flow.ControlFlow.Continue
                                          _
                                        =>
                                      let γ0_0 :=
                                        core.ops.control_flow.ControlFlow.Get_Continue_0
                                          γ in
                                      let* val := M.copy γ0_0 in
                                      M.pure val
                                    | _ => M.break_match
                                    end) :
                                    M (M.Val unit)
                                ] in
                            M.alloc tt
                          else
                            let* _ : M.Val unit :=
                              let* α0 :
                                  (core.result.Result.t unit core.fmt.Error.t)
                                    ->
                                    M
                                      (core.ops.control_flow.ControlFlow.t
                                        _
                                        _) :=
                                ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.Try.branch
                                    (Self :=
                                      core.result.Result.t
                                        unit
                                        core.fmt.Error.t)
                                    (Trait := ℐ))) in
                              let* α1 : mut_ref core.fmt.Formatter.t :=
                                M.read f in
                              let* α2 : ref str.t := M.read (mk_str "") in
                              let* α3 : ref str.t := M.read (mk_str ".") in
                              let* α4 : ref str.t :=
                                M.read (mk_str " seconds") in
                              let* α5 : M.Val (array (ref str.t)) :=
                                M.alloc [ α2; α3; α4 ] in
                              let* α6 : i64.t :=
                                M.call
                                  (nix.sys.time.TimeSpec.t::["tv_nsec"]
                                    (borrow abs)) in
                              let* α7 : M.Val i64.t := M.alloc α6 in
                              let* α8 : M.Val ((ref i64.t) * (ref i64.t)) :=
                                M.alloc (borrow α7, borrow sec) in
                              let* α9 : M.Val (array core.fmt.rt.Argument.t) :=
                                match_operator
                                  α8
                                  [
                                    fun γ =>
                                      (let* args := M.copy γ in
                                      let* α0 : ref i64.t :=
                                        M.read "Unknown Field" in
                                      let* α1 : core.fmt.rt.Argument.t :=
                                        M.call
                                          (core.fmt.rt.Argument.t::["new_display"]
                                            α0) in
                                      let* α2 : ref i64.t :=
                                        M.read "Unknown Field" in
                                      let* α3 : core.fmt.rt.Argument.t :=
                                        M.call
                                          (core.fmt.rt.Argument.t::["new_display"]
                                            α2) in
                                      M.alloc [ α1; α3 ]) :
                                      M (M.Val (array core.fmt.rt.Argument.t))
                                  ] in
                              let* α10 : core.fmt.rt.Placeholder.t :=
                                M.call
                                  (core.fmt.rt.Placeholder.t::["new"]
                                    ((Integer.of_Z 0) : usize.t)
                                    " "%char
                                    core.fmt.rt.Alignment.Unknown
                                    ((Integer.of_Z 0) : u32.t)
                                    core.fmt.rt.Count.Implied
                                    core.fmt.rt.Count.Implied) in
                              let* α11 : core.fmt.rt.Placeholder.t :=
                                M.call
                                  (core.fmt.rt.Placeholder.t::["new"]
                                    ((Integer.of_Z 1) : usize.t)
                                    " "%char
                                    core.fmt.rt.Alignment.Unknown
                                    ((Integer.of_Z 8) : u32.t)
                                    core.fmt.rt.Count.Implied
                                    (core.fmt.rt.Count.Is
                                      ((Integer.of_Z 9) : usize.t))) in
                              let* α12 :
                                  M.Val (array core.fmt.rt.Placeholder.t) :=
                                M.alloc [ α10; α11 ] in
                              let* α13 : core.fmt.rt.UnsafeArg.t :=
                                M.call core.fmt.rt.UnsafeArg.t::["new"] in
                              let* α14 : core.fmt.Arguments.t :=
                                M.call
                                  (core.fmt.Arguments.t::["new_v1_formatted"]
                                    (pointer_coercion "Unsize" (borrow α5))
                                    (pointer_coercion "Unsize" (borrow α9))
                                    (pointer_coercion "Unsize" (borrow α12))
                                    α13) in
                              let* α15 :
                                  core.result.Result.t unit core.fmt.Error.t :=
                                M.call
                                  (core.fmt.Formatter.t::["write_fmt"]
                                    α1
                                    α14) in
                              let* α16 :
                                  core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit :=
                                M.call (α0 α15) in
                              let* α17 :
                                  M.Val
                                    (core.ops.control_flow.ControlFlow.t
                                      (core.result.Result.t
                                        core.convert.Infallible.t
                                        core.fmt.Error.t)
                                      unit) :=
                                M.alloc α16 in
                              match_operator
                                α17
                                [
                                  fun γ =>
                                    (let* α0 := M.read γ in
                                    match α0 with
                                    |
                                        core.ops.control_flow.ControlFlow.Break
                                          _
                                        =>
                                      let γ0_0 :=
                                        core.ops.control_flow.ControlFlow.Get_Break_0
                                          γ in
                                      let* residual := M.copy γ0_0 in
                                      let* α0 :
                                          (core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                            ->
                                            M
                                              (core.result.Result.t
                                                unit
                                                core.fmt.Error.t) :=
                                        ltac:(M.get_method (fun ℐ =>
                                          core.ops.try_trait.FromResidual.from_residual
                                            (Self :=
                                              core.result.Result.t
                                                unit
                                                core.fmt.Error.t)
                                            (R :=
                                              core.result.Result.t
                                                core.convert.Infallible.t
                                                core.fmt.Error.t)
                                            (Trait := ℐ))) in
                                      let* α1 :
                                          core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t :=
                                        M.read residual in
                                      let* α2 :
                                          core.result.Result.t
                                            unit
                                            core.fmt.Error.t :=
                                        M.call (α0 α1) in
                                      let* α3 : M.Val never.t := return_ α2 in
                                      let* α4 := M.read α3 in
                                      let* α5 : unit := never_to_any α4 in
                                      M.alloc α5
                                    | _ => M.break_match
                                    end) :
                                    M (M.Val unit);
                                  fun γ =>
                                    (let* α0 := M.read γ in
                                    match α0 with
                                    |
                                        core.ops.control_flow.ControlFlow.Continue
                                          _
                                        =>
                                      let γ0_0 :=
                                        core.ops.control_flow.ControlFlow.Get_Continue_0
                                          γ in
                                      let* val := M.copy γ0_0 in
                                      M.pure val
                                    | _ => M.break_match
                                    end) :
                                    M (M.Val unit)
                                ] in
                            M.alloc tt in
                    M.alloc (core.result.Result.Ok tt)
                  end) :
                  M (M.Val (core.result.Result.t unit core.fmt.Error.t))
              ] in
          M.read α5).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_nix_sys_time_TimeSpec_t.
    End Impl_core_fmt_Display_for_nix_sys_time_TimeSpec_t.
    
    Module  TimeVal.
    Section TimeVal.
      Record t : Set := {
        x0 : libc.unix.timeval.t;
      }.
      
      Definition Get_0 :=
        Ref.map (fun α => Some α.(x0)) (fun β α => Some (α <| x0 := β |>)).
    End TimeVal.
    End TimeVal.
    
    Module  Impl_core_clone_Clone_for_nix_sys_time_TimeVal_t.
    Section Impl_core_clone_Clone_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
      Clone
      *)
      Definition clone (self : ref Self) : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* α0 : M.Val nix.sys.time.TimeVal.t :=
          match_operator
            (DeclaredButUndefinedVariable
              (A := core.clone.AssertParamIsClone.t libc.unix.timeval.t))
            [
              fun γ =>
                (let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
                M.pure (deref α0)) :
                M (M.Val nix.sys.time.TimeVal.t)
            ] in
        M.read α0.
      
      Global Instance AssociatedFunction_clone :
        Notations.DoubleColon Self "clone" := {
        Notations.double_colon := clone;
      }.
      
      Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
        core.clone.Clone.clone := clone;
        core.clone.Clone.clone_from := Datatypes.None;
      }.
    End Impl_core_clone_Clone_for_nix_sys_time_TimeVal_t.
    End Impl_core_clone_Clone_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_marker_Copy_for_nix_sys_time_TimeVal_t.
    Section Impl_core_marker_Copy_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      Global Instance ℐ : core.marker.Copy.Trait Self := {
      }.
    End Impl_core_marker_Copy_for_nix_sys_time_TimeVal_t.
    End Impl_core_marker_Copy_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_fmt_Debug_for_nix_sys_time_TimeVal_t.
    Section Impl_core_fmt_Debug_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
      Debug
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let* α0 : mut_ref core.fmt.Formatter.t := M.read f in
        let* α1 : ref str.t := M.read (mk_str "TimeVal") in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α3 : M.Val (ref libc.unix.timeval.t) :=
          M.alloc (borrow (nix.sys.time.TimeVal.Get_0 (deref α2))) in
        M.call
          (core.fmt.Formatter.t::["debug_tuple_field1_finish"]
            α0
            α1
            (pointer_coercion "Unsize" (borrow α3))).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Debug.Trait Self := {
        core.fmt.Debug.fmt := fmt;
      }.
    End Impl_core_fmt_Debug_for_nix_sys_time_TimeVal_t.
    End Impl_core_fmt_Debug_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_marker_StructuralEq_for_nix_sys_time_TimeVal_t.
    Section Impl_core_marker_StructuralEq_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      Global Instance ℐ : core.marker.StructuralEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralEq_for_nix_sys_time_TimeVal_t.
    End Impl_core_marker_StructuralEq_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_cmp_Eq_for_nix_sys_time_TimeVal_t.
    Section Impl_core_cmp_Eq_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
      Eq
      *)
      Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
        let* self := M.alloc self in
        let* α0 : M.Val unit :=
          match_operator
            (DeclaredButUndefinedVariable
              (A := core.cmp.AssertParamIsEq.t libc.unix.timeval.t))
            [ fun γ => (M.alloc tt) : M (M.Val unit) ] in
        M.read α0.
      
      Global Instance AssociatedFunction_assert_receiver_is_total_eq :
        Notations.DoubleColon Self "assert_receiver_is_total_eq" := {
        Notations.double_colon := assert_receiver_is_total_eq;
      }.
      
      Global Instance ℐ : core.cmp.Eq.Required.Trait Self := {
        core.cmp.Eq.assert_receiver_is_total_eq :=
          Datatypes.Some assert_receiver_is_total_eq;
      }.
    End Impl_core_cmp_Eq_for_nix_sys_time_TimeVal_t.
    End Impl_core_cmp_Eq_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_hash_Hash_for_nix_sys_time_TimeVal_t.
    Section Impl_core_hash_Hash_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
      Hash
      *)
      Definition hash
          {__H : Set}
          (self : ref Self)
          (state : mut_ref __H)
          : M unit :=
        let* self := M.alloc self in
        let* state := M.alloc state in
        let* α0 : (ref libc.unix.timeval.t) -> (mut_ref __H) -> M unit :=
          ltac:(M.get_method (fun ℐ =>
            core.hash.Hash.hash
              (Self := libc.unix.timeval.t)
              (H := __H)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α2 : mut_ref __H := M.read state in
        M.call (α0 (borrow (nix.sys.time.TimeVal.Get_0 (deref α1))) α2).
      
      Global Instance AssociatedFunction_hash {__H : Set} :
        Notations.DoubleColon Self "hash" := {
        Notations.double_colon := hash (__H := __H);
      }.
      
      Global Instance ℐ : core.hash.Hash.Required.Trait Self := {
        core.hash.Hash.hash {__H : Set} := hash (__H := __H);
        core.hash.Hash.hash_slice := Datatypes.None;
      }.
    End Impl_core_hash_Hash_for_nix_sys_time_TimeVal_t.
    End Impl_core_hash_Hash_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeVal_t.
    Section Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      Global Instance ℐ : core.marker.StructuralPartialEq.Trait Self := {
      }.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeVal_t.
    End Impl_core_marker_StructuralPartialEq_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_cmp_PartialEq_for_nix_sys_time_TimeVal_t.
    Section Impl_core_cmp_PartialEq_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
      PartialEq
      *)
      Definition eq
          (self : ref Self)
          (other : ref nix.sys.time.TimeVal.t)
          : M bool.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 :
            (ref libc.unix.timeval.t) ->
              (ref libc.unix.timeval.t) ->
              M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := libc.unix.timeval.t)
              (Rhs := libc.unix.timeval.t)
              (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read other in
        M.call
          (α0
            (borrow (nix.sys.time.TimeVal.Get_0 (deref α1)))
            (borrow (nix.sys.time.TimeVal.Get_0 (deref α2)))).
      
      Global Instance AssociatedFunction_eq :
        Notations.DoubleColon Self "eq" := {
        Notations.double_colon := eq;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialEq.Required.Trait Self
          (Rhs := core.cmp.PartialEq.Default.Rhs Self) := {
        core.cmp.PartialEq.eq := eq;
        core.cmp.PartialEq.ne := Datatypes.None;
      }.
    End Impl_core_cmp_PartialEq_for_nix_sys_time_TimeVal_t.
    End Impl_core_cmp_PartialEq_for_nix_sys_time_TimeVal_t.
    
    Definition MICROS_PER_SEC : M.Val i64.t :=
      M.run (M.alloc ((Integer.of_Z 1000000) : i64.t)).
    
    Definition TV_MAX_SECONDS : M.Val i64.t :=
      M.run
        (let* α0 : i64.t := M.read core.num.MAX in
        let* α1 : i64.t := M.read nix.sys.time.MICROS_PER_SEC in
        let* α2 : i64.t := BinOp.Panic.div α0 α1 in
        let* α3 : i64.t := BinOp.Panic.sub α2 ((Integer.of_Z 1) : i64.t) in
        M.alloc α3).
    
    Definition TV_MIN_SECONDS : M.Val i64.t :=
      M.run
        (let* α0 : i64.t := M.read nix.sys.time.TV_MAX_SECONDS in
        let* α1 : i64.t := UnOp.neg α0 in
        M.alloc α1).
    
    Module  Impl_core_convert_AsRef_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    Section Impl_core_convert_AsRef_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn as_ref(&self) -> &timeval {
              &self.0
          }
      *)
      Definition as_ref (self : ref Self) : M (ref libc.unix.timeval.t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        M.pure (borrow (nix.sys.time.TimeVal.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_as_ref :
        Notations.DoubleColon Self "as_ref" := {
        Notations.double_colon := as_ref;
      }.
      
      Global Instance ℐ :
        core.convert.AsRef.Trait Self (T := libc.unix.timeval.t) := {
        core.convert.AsRef.as_ref := as_ref;
      }.
    End Impl_core_convert_AsRef_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    End Impl_core_convert_AsRef_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_convert_AsMut_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    Section Impl_core_convert_AsMut_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn as_mut(&mut self) -> &mut timeval {
              &mut self.0
          }
      *)
      Definition as_mut
          (self : mut_ref Self)
          : M (mut_ref libc.unix.timeval.t) :=
        let* self := M.alloc self in
        let* α0 : mut_ref nix.sys.time.TimeVal.t := M.read self in
        M.pure (borrow_mut (nix.sys.time.TimeVal.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_as_mut :
        Notations.DoubleColon Self "as_mut" := {
        Notations.double_colon := as_mut;
      }.
      
      Global Instance ℐ :
        core.convert.AsMut.Trait Self (T := libc.unix.timeval.t) := {
        core.convert.AsMut.as_mut := as_mut;
      }.
    End Impl_core_convert_AsMut_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    End Impl_core_convert_AsMut_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_cmp_Ord_for_nix_sys_time_TimeVal_t.
    Section Impl_core_cmp_Ord_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn cmp(&self, other: &TimeVal) -> cmp::Ordering {
              if self.tv_sec() == other.tv_sec() {
                  self.tv_usec().cmp(&other.tv_usec())
              } else {
                  self.tv_sec().cmp(&other.tv_sec())
              }
          }
      *)
      Definition cmp
          (self : ref Self)
          (other : ref nix.sys.time.TimeVal.t)
          : M core.cmp.Ordering.t :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read other in
        let* α3 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α2) in
        let* α4 : M.Val bool.t := M.alloc (BinOp.Pure.eq α1 α3) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val core.cmp.Ordering.t :=
          if α5 then
            let* α0 : (ref i64.t) -> (ref i64.t) -> M core.cmp.Ordering.t :=
              ltac:(M.get_method (fun ℐ =>
                core.cmp.Ord.cmp (Self := i64.t) (Trait := ℐ))) in
            let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α2 : i64.t :=
              M.call (nix.sys.time.TimeVal.t::["tv_usec"] α1) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            let* α4 : ref nix.sys.time.TimeVal.t := M.read other in
            let* α5 : i64.t :=
              M.call (nix.sys.time.TimeVal.t::["tv_usec"] α4) in
            let* α6 : M.Val i64.t := M.alloc α5 in
            let* α7 : core.cmp.Ordering.t :=
              M.call (α0 (borrow α3) (borrow α6)) in
            M.alloc α7
          else
            let* α0 : (ref i64.t) -> (ref i64.t) -> M core.cmp.Ordering.t :=
              ltac:(M.get_method (fun ℐ =>
                core.cmp.Ord.cmp (Self := i64.t) (Trait := ℐ))) in
            let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α2 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α1) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            let* α4 : ref nix.sys.time.TimeVal.t := M.read other in
            let* α5 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α4) in
            let* α6 : M.Val i64.t := M.alloc α5 in
            let* α7 : core.cmp.Ordering.t :=
              M.call (α0 (borrow α3) (borrow α6)) in
            M.alloc α7 in
        M.read α6.
      
      Global Instance AssociatedFunction_cmp :
        Notations.DoubleColon Self "cmp" := {
        Notations.double_colon := cmp;
      }.
      
      Global Instance ℐ : core.cmp.Ord.Required.Trait Self := {
        core.cmp.Ord.cmp := cmp;
        core.cmp.Ord.max := Datatypes.None;
        core.cmp.Ord.min := Datatypes.None;
        core.cmp.Ord.clamp := Datatypes.None;
      }.
    End Impl_core_cmp_Ord_for_nix_sys_time_TimeVal_t.
    End Impl_core_cmp_Ord_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeVal_t.
    Section Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn partial_cmp(&self, other: &TimeVal) -> Option<cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp
          (self : ref Self)
          (other : ref nix.sys.time.TimeVal.t)
          : M (core.option.Option.t core.cmp.Ordering.t) :=
        let* self := M.alloc self in
        let* other := M.alloc other in
        let* α0 :
            (ref nix.sys.time.TimeVal.t) ->
              (ref nix.sys.time.TimeVal.t) ->
              M core.cmp.Ordering.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.Ord.cmp (Self := nix.sys.time.TimeVal.t) (Trait := ℐ))) in
        let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read other in
        let* α3 : core.cmp.Ordering.t := M.call (α0 α1 α2) in
        M.pure (core.option.Option.Some α3).
      
      Global Instance AssociatedFunction_partial_cmp :
        Notations.DoubleColon Self "partial_cmp" := {
        Notations.double_colon := partial_cmp;
      }.
      
      Global Instance ℐ :
        core.cmp.PartialOrd.Required.Trait Self
          (Rhs := core.cmp.PartialOrd.Default.Rhs Self) := {
        core.cmp.PartialOrd.partial_cmp := partial_cmp;
        core.cmp.PartialOrd.lt := Datatypes.None;
        core.cmp.PartialOrd.le := Datatypes.None;
        core.cmp.PartialOrd.gt := Datatypes.None;
        core.cmp.PartialOrd.ge := Datatypes.None;
      }.
    End Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeVal_t.
    End Impl_core_cmp_PartialOrd_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeVal_t.
    Section Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn seconds(seconds: i64) -> TimeVal {
              assert!(
                  (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(&seconds),
                  "TimeVal out of bounds; seconds={seconds}"
              );
              #[cfg_attr(target_env = "musl", allow(deprecated))]
              // https://github.com/rust-lang/libc/issues/1848
              TimeVal(timeval {
                  tv_sec: seconds as time_t,
                  tv_usec: 0,
              })
          }
      *)
      Definition seconds (seconds : i64.t) : M nix.sys.time.TimeVal.t :=
        let* seconds := M.alloc seconds in
        let* _ : M.Val unit :=
          let* α0 : i64.t := M.read nix.sys.time.TV_MIN_SECONDS in
          let* α1 : i64.t := M.read nix.sys.time.TV_MAX_SECONDS in
          let* α2 : core.ops.range.RangeInclusive.t i64.t :=
            M.call ((core.ops.range.RangeInclusive.t i64.t)::["new"] α0 α1) in
          let* α3 : M.Val (core.ops.range.RangeInclusive.t i64.t) :=
            M.alloc α2 in
          let* α4 : bool.t :=
            M.call
              ((core.ops.range.RangeInclusive.t i64.t)::["contains"]
                (borrow α3)
                (borrow seconds)) in
          let* α5 : M.Val bool.t := M.alloc (UnOp.not α4) in
          let* α6 : bool.t := M.read (use α5) in
          if α6 then
            let* α0 : ref str.t :=
              M.read (mk_str "TimeVal out of bounds; seconds=") in
            let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
            let* α2 : core.fmt.rt.Argument.t :=
              M.call
                (core.fmt.rt.Argument.t::["new_display"] (borrow seconds)) in
            let* α3 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α2 ] in
            let* α4 : core.fmt.Arguments.t :=
              M.call
                (core.fmt.Arguments.t::["new_v1"]
                  (pointer_coercion "Unsize" (borrow α1))
                  (pointer_coercion "Unsize" (borrow α3))) in
            let* α5 : never.t := M.call (core.panicking.panic_fmt α4) in
            let* α6 : unit := never_to_any α5 in
            M.alloc α6
          else
            M.alloc tt in
        let* α0 : i64.t := M.read (use seconds) in
        let* α0 : M.Val nix.sys.time.TimeVal.t :=
          M.alloc
            (nix.sys.time.TimeVal.Build_t
              {|
                libc.unix.timeval.tv_sec := α0;
                libc.unix.timeval.tv_usec := (Integer.of_Z 0) : i64.t;
              |}) in
        M.read α0.
      
      Global Instance AssociatedFunction_seconds :
        Notations.DoubleColon Self "seconds" := {
        Notations.double_colon := seconds;
      }.
      
      (*
          fn milliseconds(milliseconds: i64) -> TimeVal {
              let microseconds = milliseconds
                  .checked_mul(1_000)
                  .expect("TimeVal::milliseconds out of bounds");
      
              TimeVal::microseconds(microseconds)
          }
      *)
      Definition milliseconds
          (milliseconds : i64.t)
          : M nix.sys.time.TimeVal.t :=
        let* milliseconds := M.alloc milliseconds in
        let* microseconds : M.Val i64.t :=
          let* α0 : i64.t := M.read milliseconds in
          let* α1 : core.option.Option.t i64.t :=
            M.call (i64.t::["checked_mul"] α0 ((Integer.of_Z 1000) : i64.t)) in
          let* α2 : ref str.t :=
            M.read (mk_str "TimeVal::milliseconds out of bounds") in
          let* α3 : i64.t :=
            M.call ((core.option.Option.t i64.t)::["expect"] α1 α2) in
          M.alloc α3 in
        let* α0 : i64.t := M.read microseconds in
        let* α1 : nix.sys.time.TimeVal.t := M.call (microseconds α0) in
        let* α0 : M.Val nix.sys.time.TimeVal.t := M.alloc α1 in
        M.read α0.
      
      Global Instance AssociatedFunction_milliseconds :
        Notations.DoubleColon Self "milliseconds" := {
        Notations.double_colon := milliseconds;
      }.
      
      (*
          fn microseconds(microseconds: i64) -> TimeVal {
              let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);
              assert!(
                  (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(&secs),
                  "TimeVal out of bounds"
              );
              #[cfg_attr(target_env = "musl", allow(deprecated))]
              // https://github.com/rust-lang/libc/issues/1848
              TimeVal(timeval {
                  tv_sec: secs as time_t,
                  tv_usec: micros as suseconds_t,
              })
          }
      *)
      Definition microseconds
          (microseconds : i64.t)
          : M nix.sys.time.TimeVal.t :=
        let* microseconds := M.alloc microseconds in
        let* α0 : i64.t := M.read microseconds in
        let* α1 : i64.t := M.read nix.sys.time.MICROS_PER_SEC in
        let* α2 : i64.t * i64.t :=
          M.call (nix.sys.time.div_mod_floor_64 α0 α1) in
        let* α3 : M.Val (i64.t * i64.t) := M.alloc α2 in
        let* α4 : M.Val nix.sys.time.TimeVal.t :=
          match_operator
            α3
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let* secs := M.copy γ0_0 in
                  let* micros := M.copy γ0_1 in
                  let* _ : M.Val unit :=
                    let* α0 : i64.t := M.read nix.sys.time.TV_MIN_SECONDS in
                    let* α1 : i64.t := M.read nix.sys.time.TV_MAX_SECONDS in
                    let* α2 : core.ops.range.RangeInclusive.t i64.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["new"]
                          α0
                          α1) in
                    let* α3 : M.Val (core.ops.range.RangeInclusive.t i64.t) :=
                      M.alloc α2 in
                    let* α4 : bool.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["contains"]
                          (borrow α3)
                          (borrow secs)) in
                    let* α5 : M.Val bool.t := M.alloc (UnOp.not α4) in
                    let* α6 : bool.t := M.read (use α5) in
                    if α6 then
                      let* α0 : ref str.t :=
                        M.read (mk_str "TimeVal out of bounds") in
                      let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                      let* α2 : core.fmt.Arguments.t :=
                        M.call
                          (core.fmt.Arguments.t::["new_const"]
                            (pointer_coercion "Unsize" (borrow α1))) in
                      let* α3 : never.t :=
                        M.call (core.panicking.panic_fmt α2) in
                      let* α4 : unit := never_to_any α3 in
                      M.alloc α4
                    else
                      M.alloc tt in
                  let* α0 : i64.t := M.read (use secs) in
                  let* α1 : i64.t := M.read (use micros) in
                  M.alloc
                    (nix.sys.time.TimeVal.Build_t
                      {|
                        libc.unix.timeval.tv_sec := α0;
                        libc.unix.timeval.tv_usec := α1;
                      |})
                end) :
                M (M.Val nix.sys.time.TimeVal.t)
            ] in
        M.read α4.
      
      Global Instance AssociatedFunction_microseconds :
        Notations.DoubleColon Self "microseconds" := {
        Notations.double_colon := microseconds;
      }.
      
      (*
          fn nanoseconds(nanoseconds: i64) -> TimeVal {
              let microseconds = nanoseconds / 1000;
              let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);
              assert!(
                  (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(&secs),
                  "TimeVal out of bounds"
              );
              #[cfg_attr(target_env = "musl", allow(deprecated))]
              // https://github.com/rust-lang/libc/issues/1848
              TimeVal(timeval {
                  tv_sec: secs as time_t,
                  tv_usec: micros as suseconds_t,
              })
          }
      *)
      Definition nanoseconds (nanoseconds : i64.t) : M nix.sys.time.TimeVal.t :=
        let* nanoseconds := M.alloc nanoseconds in
        let* microseconds : M.Val i64.t :=
          let* α0 : i64.t := M.read nanoseconds in
          let* α1 : i64.t := BinOp.Panic.div α0 ((Integer.of_Z 1000) : i64.t) in
          M.alloc α1 in
        let* α0 : i64.t := M.read microseconds in
        let* α1 : i64.t := M.read nix.sys.time.MICROS_PER_SEC in
        let* α2 : i64.t * i64.t :=
          M.call (nix.sys.time.div_mod_floor_64 α0 α1) in
        let* α3 : M.Val (i64.t * i64.t) := M.alloc α2 in
        let* α0 : M.Val nix.sys.time.TimeVal.t :=
          match_operator
            α3
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | (_, _) =>
                  let γ0_0 := Tuple.Access.left γ in
                  let γ0_1 := Tuple.Access.right γ in
                  let* secs := M.copy γ0_0 in
                  let* micros := M.copy γ0_1 in
                  let* _ : M.Val unit :=
                    let* α0 : i64.t := M.read nix.sys.time.TV_MIN_SECONDS in
                    let* α1 : i64.t := M.read nix.sys.time.TV_MAX_SECONDS in
                    let* α2 : core.ops.range.RangeInclusive.t i64.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["new"]
                          α0
                          α1) in
                    let* α3 : M.Val (core.ops.range.RangeInclusive.t i64.t) :=
                      M.alloc α2 in
                    let* α4 : bool.t :=
                      M.call
                        ((core.ops.range.RangeInclusive.t i64.t)::["contains"]
                          (borrow α3)
                          (borrow secs)) in
                    let* α5 : M.Val bool.t := M.alloc (UnOp.not α4) in
                    let* α6 : bool.t := M.read (use α5) in
                    if α6 then
                      let* α0 : ref str.t :=
                        M.read (mk_str "TimeVal out of bounds") in
                      let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                      let* α2 : core.fmt.Arguments.t :=
                        M.call
                          (core.fmt.Arguments.t::["new_const"]
                            (pointer_coercion "Unsize" (borrow α1))) in
                      let* α3 : never.t :=
                        M.call (core.panicking.panic_fmt α2) in
                      let* α4 : unit := never_to_any α3 in
                      M.alloc α4
                    else
                      M.alloc tt in
                  let* α0 : i64.t := M.read (use secs) in
                  let* α1 : i64.t := M.read (use micros) in
                  M.alloc
                    (nix.sys.time.TimeVal.Build_t
                      {|
                        libc.unix.timeval.tv_sec := α0;
                        libc.unix.timeval.tv_usec := α1;
                      |})
                end) :
                M (M.Val nix.sys.time.TimeVal.t)
            ] in
        M.read α0.
      
      Global Instance AssociatedFunction_nanoseconds :
        Notations.DoubleColon Self "nanoseconds" := {
        Notations.double_colon := nanoseconds;
      }.
      
      (*
          fn num_seconds(&self) -> i64 {
              if self.tv_sec() < 0 && self.tv_usec() > 0 {
                  (self.tv_sec() + 1) as i64
              } else {
                  self.tv_sec() as i64
              }
          }
      *)
      Definition num_seconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α3 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_usec"] α2) in
        let* α4 : M.Val bool.t :=
          M.alloc
            (BinOp.Pure.and
              (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t))
              (BinOp.Pure.gt α3 ((Integer.of_Z 0) : i64.t))) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val i64.t :=
          if α5 then
            let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
            let* α2 : i64.t := BinOp.Panic.add α1 ((Integer.of_Z 1) : i64.t) in
            let* α3 : M.Val i64.t := M.alloc α2 in
            M.pure (use α3)
          else
            let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
            let* α2 : M.Val i64.t := M.alloc α1 in
            M.pure (use α2) in
        M.read α6.
      
      Global Instance AssociatedFunction_num_seconds :
        Notations.DoubleColon Self "num_seconds" := {
        Notations.double_colon := num_seconds;
      }.
      
      (*
          fn num_milliseconds(&self) -> i64 {
              self.num_microseconds() / 1_000
          }
      *)
      Definition num_milliseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α1 : i64.t := M.call (num_microseconds α0) in
        BinOp.Panic.div α1 ((Integer.of_Z 1000) : i64.t).
      
      Global Instance AssociatedFunction_num_milliseconds :
        Notations.DoubleColon Self "num_milliseconds" := {
        Notations.double_colon := num_milliseconds;
      }.
      
      (*
          fn num_microseconds(&self) -> i64 {
              let secs = self.num_seconds() * 1_000_000;
              let usec = self.micros_mod_sec();
              secs + usec as i64
          }
      *)
      Definition num_microseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* secs : M.Val i64.t :=
          let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
          let* α1 : i64.t := M.call (num_seconds α0) in
          let* α2 : i64.t :=
            BinOp.Panic.mul α1 ((Integer.of_Z 1000000) : i64.t) in
          M.alloc α2 in
        let* usec : M.Val i64.t :=
          let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
          let* α1 : i64.t :=
            M.call (nix.sys.time.TimeVal.t::["micros_mod_sec"] α0) in
          M.alloc α1 in
        let* α0 : i64.t := M.read secs in
        let* α1 : i64.t := M.read (use usec) in
        let* α2 : i64.t := BinOp.Panic.add α0 α1 in
        let* α0 : M.Val i64.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_num_microseconds :
        Notations.DoubleColon Self "num_microseconds" := {
        Notations.double_colon := num_microseconds;
      }.
      
      (*
          fn num_nanoseconds(&self) -> i64 {
              self.num_microseconds() * 1_000
          }
      *)
      Definition num_nanoseconds (self : ref Self) : M i64.t :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α1 : i64.t := M.call (num_microseconds α0) in
        BinOp.Panic.mul α1 ((Integer.of_Z 1000) : i64.t).
      
      Global Instance AssociatedFunction_num_nanoseconds :
        Notations.DoubleColon Self "num_nanoseconds" := {
        Notations.double_colon := num_nanoseconds;
      }.
      
      Global Instance ℐ : nix.sys.time.TimeValLike.Required.Trait Self := {
        nix.sys.time.TimeValLike.seconds := seconds;
        nix.sys.time.TimeValLike.milliseconds := milliseconds;
        nix.sys.time.TimeValLike.microseconds := microseconds;
        nix.sys.time.TimeValLike.nanoseconds := nanoseconds;
        nix.sys.time.TimeValLike.num_seconds := num_seconds;
        nix.sys.time.TimeValLike.num_milliseconds := num_milliseconds;
        nix.sys.time.TimeValLike.num_microseconds := num_microseconds;
        nix.sys.time.TimeValLike.num_nanoseconds := num_nanoseconds;
        nix.sys.time.TimeValLike.zero := Datatypes.None;
        nix.sys.time.TimeValLike.hours := Datatypes.None;
        nix.sys.time.TimeValLike.minutes := Datatypes.None;
        nix.sys.time.TimeValLike.num_hours := Datatypes.None;
        nix.sys.time.TimeValLike.num_minutes := Datatypes.None;
      }.
    End Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeVal_t.
    End Impl_nix_sys_time_TimeValLike_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_nix_sys_time_TimeVal_t.
    Section Impl_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          pub const fn new(seconds: time_t, microseconds: suseconds_t) -> Self {
              Self(timeval {
                  tv_sec: seconds,
                  tv_usec: microseconds,
              })
          }
      *)
      Definition new
          (seconds : ltac:(libc.unix.linux_like.linux.gnu.b64.time_t))
          (microseconds
            :
            ltac:(libc.unix.linux_like.linux.gnu.b64.x86_64.suseconds_t))
          : M Self :=
        let* seconds := M.alloc seconds in
        let* microseconds := M.alloc microseconds in
        let* α0 : i64.t := M.read seconds in
        let* α1 : i64.t := M.read microseconds in
        M.pure
          (nix.sys.time.TimeVal.Build_t
            {| libc.unix.timeval.tv_sec := α0; libc.unix.timeval.tv_usec := α1;
            |}).
      
      Global Instance AssociatedFunction_new :
        Notations.DoubleColon Self "new" := {
        Notations.double_colon := new;
      }.
      
      (*
          fn micros_mod_sec(&self) -> suseconds_t {
              if self.tv_sec() < 0 && self.tv_usec() > 0 {
                  self.tv_usec() - MICROS_PER_SEC as suseconds_t
              } else {
                  self.tv_usec()
              }
          }
      *)
      Definition micros_mod_sec
          (self : ref Self)
          : M ltac:(libc.unix.linux_like.linux.gnu.b64.x86_64.suseconds_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
        let* α2 : ref nix.sys.time.TimeVal.t := M.read self in
        let* α3 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_usec"] α2) in
        let* α4 : M.Val bool.t :=
          M.alloc
            (BinOp.Pure.and
              (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t))
              (BinOp.Pure.gt α3 ((Integer.of_Z 0) : i64.t))) in
        let* α5 : bool.t := M.read (use α4) in
        let* α6 : M.Val i64.t :=
          if α5 then
            let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeVal.t::["tv_usec"] α0) in
            let* α2 : i64.t := M.read (use nix.sys.time.MICROS_PER_SEC) in
            let* α3 : i64.t := BinOp.Panic.sub α1 α2 in
            M.alloc α3
          else
            let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
            let* α1 : i64.t :=
              M.call (nix.sys.time.TimeVal.t::["tv_usec"] α0) in
            M.alloc α1 in
        M.read α6.
      
      Global Instance AssociatedFunction_micros_mod_sec :
        Notations.DoubleColon Self "micros_mod_sec" := {
        Notations.double_colon := micros_mod_sec;
      }.
      
      (*
          pub const fn tv_sec(&self) -> time_t {
              self.0.tv_sec
          }
      *)
      Definition tv_sec
          (self : ref Self)
          : M ltac:(libc.unix.linux_like.linux.gnu.b64.time_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        M.read
          (libc.unix.timeval.Get_tv_sec
            (nix.sys.time.TimeVal.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_tv_sec :
        Notations.DoubleColon Self "tv_sec" := {
        Notations.double_colon := tv_sec;
      }.
      
      (*
          pub const fn tv_usec(&self) -> suseconds_t {
              self.0.tv_usec
          }
      *)
      Definition tv_usec
          (self : ref Self)
          : M ltac:(libc.unix.linux_like.linux.gnu.b64.x86_64.suseconds_t) :=
        let* self := M.alloc self in
        let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
        M.read
          (libc.unix.timeval.Get_tv_usec
            (nix.sys.time.TimeVal.Get_0 (deref α0))).
      
      Global Instance AssociatedFunction_tv_usec :
        Notations.DoubleColon Self "tv_usec" := {
        Notations.double_colon := tv_usec;
      }.
    End Impl_nix_sys_time_TimeVal_t.
    End Impl_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_ops_arith_Neg_for_nix_sys_time_TimeVal_t.
    Section Impl_core_ops_arith_Neg_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          type Output = TimeVal;
      *)
      Definition Output : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn neg(self) -> TimeVal {
              TimeVal::microseconds(-self.num_microseconds())
          }
      *)
      Definition neg (self : Self) : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* α0 : i64.t -> M nix.sys.time.TimeVal.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : i64.t := UnOp.neg α2 in
        M.call (α0 α3).
      
      Global Instance AssociatedFunction_neg :
        Notations.DoubleColon Self "neg" := {
        Notations.double_colon := neg;
      }.
      
      Global Instance ℐ : core.ops.arith.Neg.Trait Self := {
        core.ops.arith.Neg.Output := Output;
        core.ops.arith.Neg.neg := neg;
      }.
    End Impl_core_ops_arith_Neg_for_nix_sys_time_TimeVal_t.
    End Impl_core_ops_arith_Neg_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_ops_arith_Add_for_nix_sys_time_TimeVal_t.
    Section Impl_core_ops_arith_Add_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          type Output = TimeVal;
      *)
      Definition Output : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn add(self, rhs: TimeVal) -> TimeVal {
              TimeVal::microseconds(self.num_microseconds() + rhs.num_microseconds())
          }
      *)
      Definition add
          (self : Self)
          (rhs : nix.sys.time.TimeVal.t)
          : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* α0 : i64.t -> M nix.sys.time.TimeVal.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α4 : i64.t := M.call (α3 (borrow rhs)) in
        let* α5 : i64.t := BinOp.Panic.add α2 α4 in
        M.call (α0 α5).
      
      Global Instance AssociatedFunction_add :
        Notations.DoubleColon Self "add" := {
        Notations.double_colon := add;
      }.
      
      Global Instance ℐ :
        core.ops.arith.Add.Trait Self
          (Rhs := core.ops.arith.Add.Default.Rhs Self) := {
        core.ops.arith.Add.Output := Output;
        core.ops.arith.Add.add := add;
      }.
    End Impl_core_ops_arith_Add_for_nix_sys_time_TimeVal_t.
    End Impl_core_ops_arith_Add_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_ops_arith_Sub_for_nix_sys_time_TimeVal_t.
    Section Impl_core_ops_arith_Sub_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          type Output = TimeVal;
      *)
      Definition Output : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn sub(self, rhs: TimeVal) -> TimeVal {
              TimeVal::microseconds(self.num_microseconds() - rhs.num_microseconds())
          }
      *)
      Definition sub
          (self : Self)
          (rhs : nix.sys.time.TimeVal.t)
          : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* α0 : i64.t -> M nix.sys.time.TimeVal.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α1 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α2 : i64.t := M.call (α1 (borrow self)) in
        let* α3 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.num_microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α4 : i64.t := M.call (α3 (borrow rhs)) in
        let* α5 : i64.t := BinOp.Panic.sub α2 α4 in
        M.call (α0 α5).
      
      Global Instance AssociatedFunction_sub :
        Notations.DoubleColon Self "sub" := {
        Notations.double_colon := sub;
      }.
      
      Global Instance ℐ :
        core.ops.arith.Sub.Trait Self
          (Rhs := core.ops.arith.Sub.Default.Rhs Self) := {
        core.ops.arith.Sub.Output := Output;
        core.ops.arith.Sub.sub := sub;
      }.
    End Impl_core_ops_arith_Sub_for_nix_sys_time_TimeVal_t.
    End Impl_core_ops_arith_Sub_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeVal_t.
    Section Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          type Output = TimeVal;
      *)
      Definition Output : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn mul(self, rhs: i32) -> TimeVal {
              let usec = self
                  .num_microseconds()
                  .checked_mul(i64::from(rhs))
                  .expect("TimeVal multiply out of bounds");
      
              TimeVal::microseconds(usec)
          }
      *)
      Definition mul (self : Self) (rhs : i32.t) : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* usec : M.Val i64.t :=
          let* α0 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              nix.sys.time.TimeValLike.num_microseconds
                (Self := nix.sys.time.TimeVal.t)
                (Trait := ℐ))) in
          let* α1 : i64.t := M.call (α0 (borrow self)) in
          let* α2 : i32.t -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := i64.t)
                (T := i32.t)
                (Trait := ℐ))) in
          let* α3 : i32.t := M.read rhs in
          let* α4 : i64.t := M.call (α2 α3) in
          let* α5 : core.option.Option.t i64.t :=
            M.call (i64.t::["checked_mul"] α1 α4) in
          let* α6 : ref str.t :=
            M.read (mk_str "TimeVal multiply out of bounds") in
          let* α7 : i64.t :=
            M.call ((core.option.Option.t i64.t)::["expect"] α5 α6) in
          M.alloc α7 in
        let* α0 : i64.t -> M nix.sys.time.TimeVal.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α1 : i64.t := M.read usec in
        let* α2 : nix.sys.time.TimeVal.t := M.call (α0 α1) in
        let* α0 : M.Val nix.sys.time.TimeVal.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_mul :
        Notations.DoubleColon Self "mul" := {
        Notations.double_colon := mul;
      }.
      
      Global Instance ℐ : core.ops.arith.Mul.Trait Self (Rhs := i32.t) := {
        core.ops.arith.Mul.Output := Output;
        core.ops.arith.Mul.mul := mul;
      }.
    End Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeVal_t.
    End Impl_core_ops_arith_Mul_i32_t_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeVal_t.
    Section Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          type Output = TimeVal;
      *)
      Definition Output : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn div(self, rhs: i32) -> TimeVal {
              let usec = self.num_microseconds() / i64::from(rhs);
              TimeVal::microseconds(usec)
          }
      *)
      Definition div (self : Self) (rhs : i32.t) : M nix.sys.time.TimeVal.t :=
        let* self := M.alloc self in
        let* rhs := M.alloc rhs in
        let* usec : M.Val i64.t :=
          let* α0 : (ref nix.sys.time.TimeVal.t) -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              nix.sys.time.TimeValLike.num_microseconds
                (Self := nix.sys.time.TimeVal.t)
                (Trait := ℐ))) in
          let* α1 : i64.t := M.call (α0 (borrow self)) in
          let* α2 : i32.t -> M i64.t :=
            ltac:(M.get_method (fun ℐ =>
              core.convert.From.from
                (Self := i64.t)
                (T := i32.t)
                (Trait := ℐ))) in
          let* α3 : i32.t := M.read rhs in
          let* α4 : i64.t := M.call (α2 α3) in
          let* α5 : i64.t := BinOp.Panic.div α1 α4 in
          M.alloc α5 in
        let* α0 : i64.t -> M nix.sys.time.TimeVal.t :=
          ltac:(M.get_method (fun ℐ =>
            nix.sys.time.TimeValLike.microseconds
              (Self := nix.sys.time.TimeVal.t)
              (Trait := ℐ))) in
        let* α1 : i64.t := M.read usec in
        let* α2 : nix.sys.time.TimeVal.t := M.call (α0 α1) in
        let* α0 : M.Val nix.sys.time.TimeVal.t := M.alloc α2 in
        M.read α0.
      
      Global Instance AssociatedFunction_div :
        Notations.DoubleColon Self "div" := {
        Notations.double_colon := div;
      }.
      
      Global Instance ℐ : core.ops.arith.Div.Trait Self (Rhs := i32.t) := {
        core.ops.arith.Div.Output := Output;
        core.ops.arith.Div.div := div;
      }.
    End Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeVal_t.
    End Impl_core_ops_arith_Div_i32_t_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_fmt_Display_for_nix_sys_time_TimeVal_t.
    Section Impl_core_fmt_Display_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
              let (abs, sign) = if self.tv_sec() < 0 {
                  (-*self, "-")
              } else {
                  ( *self, "")
              };
      
              let sec = abs.tv_sec();
      
              write!(f, "{sign}")?;
      
              if abs.tv_usec() == 0 {
                  if sec == 1 {
                      write!(f, "1 second")?;
                  } else {
                      write!(f, "{sec} seconds")?;
                  }
              } else if abs.tv_usec() % 1000 == 0 {
                  write!(f, "{sec}.{:03} seconds", abs.tv_usec() / 1000)?;
              } else {
                  write!(f, "{sec}.{:06} seconds", abs.tv_usec())?;
              }
      
              Ok(())
          }
      *)
      Definition fmt
          (self : ref Self)
          (f : mut_ref core.fmt.Formatter.t)
          : M ltac:(core.fmt.Result) :=
        let* self := M.alloc self in
        let* f := M.alloc f in
        let return_ := M.return_ (R := ltac:(core.fmt.Result)) in
        M.catch_return
          (let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
          let* α1 : i64.t := M.call (nix.sys.time.TimeVal.t::["tv_sec"] α0) in
          let* α2 : M.Val bool.t :=
            M.alloc (BinOp.Pure.lt α1 ((Integer.of_Z 0) : i64.t)) in
          let* α3 : bool.t := M.read (use α2) in
          let* α4 : M.Val (nix.sys.time.TimeVal.t * (ref str.t)) :=
            if α3 then
              let* α0 : nix.sys.time.TimeVal.t -> M _ :=
                ltac:(M.get_method (fun ℐ =>
                  core.ops.arith.Neg.neg
                    (Self := nix.sys.time.TimeVal.t)
                    (Trait := ℐ))) in
              let* α1 : ref nix.sys.time.TimeVal.t := M.read self in
              let* α2 : nix.sys.time.TimeVal.t := M.read (deref α1) in
              let* α3 : nix.sys.time.TimeVal.t := M.call (α0 α2) in
              let* α4 : ref str.t := M.read (mk_str "-") in
              M.alloc (α3, α4)
            else
              let* α0 : ref nix.sys.time.TimeVal.t := M.read self in
              let* α1 : nix.sys.time.TimeVal.t := M.read (deref α0) in
              let* α2 : ref str.t := M.read (mk_str "") in
              M.alloc (α1, α2) in
          let* α5 : M.Val (core.result.Result.t unit core.fmt.Error.t) :=
            match_operator
              α4
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | (_, _) =>
                    let γ0_0 := Tuple.Access.left γ in
                    let γ0_1 := Tuple.Access.right γ in
                    let* abs := M.copy γ0_0 in
                    let* sign := M.copy γ0_1 in
                    let* sec : M.Val i64.t :=
                      let* α0 : i64.t :=
                        M.call
                          (nix.sys.time.TimeVal.t::["tv_sec"] (borrow abs)) in
                      M.alloc α0 in
                    let* _ : M.Val unit :=
                      let* α0 :
                          (core.result.Result.t unit core.fmt.Error.t) ->
                            M (core.ops.control_flow.ControlFlow.t _ _) :=
                        ltac:(M.get_method (fun ℐ =>
                          core.ops.try_trait.Try.branch
                            (Self := core.result.Result.t unit core.fmt.Error.t)
                            (Trait := ℐ))) in
                      let* α1 : mut_ref core.fmt.Formatter.t := M.read f in
                      let* α2 : ref str.t := M.read (mk_str "") in
                      let* α3 : M.Val (array (ref str.t)) := M.alloc [ α2 ] in
                      let* α4 : core.fmt.rt.Argument.t :=
                        M.call
                          (core.fmt.rt.Argument.t::["new_display"]
                            (borrow sign)) in
                      let* α5 : M.Val (array core.fmt.rt.Argument.t) :=
                        M.alloc [ α4 ] in
                      let* α6 : core.fmt.Arguments.t :=
                        M.call
                          (core.fmt.Arguments.t::["new_v1"]
                            (pointer_coercion "Unsize" (borrow α3))
                            (pointer_coercion "Unsize" (borrow α5))) in
                      let* α7 : core.result.Result.t unit core.fmt.Error.t :=
                        M.call (core.fmt.Formatter.t::["write_fmt"] α1 α6) in
                      let* α8 :
                          core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              core.fmt.Error.t)
                            unit :=
                        M.call (α0 α7) in
                      let* α9 :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                core.fmt.Error.t)
                              unit) :=
                        M.alloc α8 in
                      match_operator
                        α9
                        [
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.ops.control_flow.ControlFlow.Break _ =>
                              let γ0_0 :=
                                core.ops.control_flow.ControlFlow.Get_Break_0
                                  γ in
                              let* residual := M.copy γ0_0 in
                              let* α0 :
                                  (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    ->
                                    M
                                      (core.result.Result.t
                                        unit
                                        core.fmt.Error.t) :=
                                ltac:(M.get_method (fun ℐ =>
                                  core.ops.try_trait.FromResidual.from_residual
                                    (Self :=
                                      core.result.Result.t
                                        unit
                                        core.fmt.Error.t)
                                    (R :=
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        core.fmt.Error.t)
                                    (Trait := ℐ))) in
                              let* α1 :
                                  core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t :=
                                M.read residual in
                              let* α2 :
                                  core.result.Result.t unit core.fmt.Error.t :=
                                M.call (α0 α1) in
                              let* α3 : M.Val never.t := return_ α2 in
                              let* α4 := M.read α3 in
                              let* α5 : unit := never_to_any α4 in
                              M.alloc α5
                            | _ => M.break_match
                            end) :
                            M (M.Val unit);
                          fun γ =>
                            (let* α0 := M.read γ in
                            match α0 with
                            | core.ops.control_flow.ControlFlow.Continue _ =>
                              let γ0_0 :=
                                core.ops.control_flow.ControlFlow.Get_Continue_0
                                  γ in
                              let* val := M.copy γ0_0 in
                              M.pure val
                            | _ => M.break_match
                            end) :
                            M (M.Val unit)
                        ] in
                    let* _ : M.Val unit :=
                      let* α0 : i64.t :=
                        M.call
                          (nix.sys.time.TimeVal.t::["tv_usec"] (borrow abs)) in
                      let* α1 : M.Val bool.t :=
                        M.alloc (BinOp.Pure.eq α0 ((Integer.of_Z 0) : i64.t)) in
                      let* α2 : bool.t := M.read (use α1) in
                      if α2 then
                        let* α0 : i64.t := M.read sec in
                        let* α1 : M.Val bool.t :=
                          M.alloc
                            (BinOp.Pure.eq α0 ((Integer.of_Z 1) : i64.t)) in
                        let* α2 : bool.t := M.read (use α1) in
                        if α2 then
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "1 second") in
                            let* α3 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2 ] in
                            let* α4 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_const"]
                                  (pointer_coercion "Unsize" (borrow α3))) in
                            let* α5 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α4) in
                            let* α6 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α5) in
                            let* α7 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α6 in
                            match_operator
                              α7
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                        else
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "") in
                            let* α3 : ref str.t := M.read (mk_str " seconds") in
                            let* α4 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2; α3 ] in
                            let* α5 : core.fmt.rt.Argument.t :=
                              M.call
                                (core.fmt.rt.Argument.t::["new_display"]
                                  (borrow sec)) in
                            let* α6 : M.Val (array core.fmt.rt.Argument.t) :=
                              M.alloc [ α5 ] in
                            let* α7 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_v1"]
                                  (pointer_coercion "Unsize" (borrow α4))
                                  (pointer_coercion "Unsize" (borrow α6))) in
                            let* α8 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α7) in
                            let* α9 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α8) in
                            let* α10 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α9 in
                            match_operator
                              α10
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                      else
                        let* α0 : i64.t :=
                          M.call
                            (nix.sys.time.TimeVal.t::["tv_usec"]
                              (borrow abs)) in
                        let* α1 : i64.t :=
                          BinOp.Panic.rem α0 ((Integer.of_Z 1000) : i64.t) in
                        let* α2 : M.Val bool.t :=
                          M.alloc
                            (BinOp.Pure.eq α1 ((Integer.of_Z 0) : i64.t)) in
                        let* α3 : bool.t := M.read (use α2) in
                        if α3 then
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "") in
                            let* α3 : ref str.t := M.read (mk_str ".") in
                            let* α4 : ref str.t := M.read (mk_str " seconds") in
                            let* α5 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2; α3; α4 ] in
                            let* α6 : i64.t :=
                              M.call
                                (nix.sys.time.TimeVal.t::["tv_usec"]
                                  (borrow abs)) in
                            let* α7 : i64.t :=
                              BinOp.Panic.div
                                α6
                                ((Integer.of_Z 1000) : i64.t) in
                            let* α8 : M.Val i64.t := M.alloc α7 in
                            let* α9 : M.Val ((ref i64.t) * (ref i64.t)) :=
                              M.alloc (borrow α8, borrow sec) in
                            let* α10 : M.Val (array core.fmt.rt.Argument.t) :=
                              match_operator
                                α9
                                [
                                  fun γ =>
                                    (let* args := M.copy γ in
                                    let* α0 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α1 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α0) in
                                    let* α2 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α3 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α2) in
                                    M.alloc [ α1; α3 ]) :
                                    M (M.Val (array core.fmt.rt.Argument.t))
                                ] in
                            let* α11 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 0) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 0) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  core.fmt.rt.Count.Implied) in
                            let* α12 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 1) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 8) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  (core.fmt.rt.Count.Is
                                    ((Integer.of_Z 3) : usize.t))) in
                            let* α13 :
                                M.Val (array core.fmt.rt.Placeholder.t) :=
                              M.alloc [ α11; α12 ] in
                            let* α14 : core.fmt.rt.UnsafeArg.t :=
                              M.call core.fmt.rt.UnsafeArg.t::["new"] in
                            let* α15 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_v1_formatted"]
                                  (pointer_coercion "Unsize" (borrow α5))
                                  (pointer_coercion "Unsize" (borrow α10))
                                  (pointer_coercion "Unsize" (borrow α13))
                                  α14) in
                            let* α16 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α15) in
                            let* α17 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α16) in
                            let* α18 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α17 in
                            match_operator
                              α18
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt
                        else
                          let* _ : M.Val unit :=
                            let* α0 :
                                (core.result.Result.t unit core.fmt.Error.t) ->
                                  M (core.ops.control_flow.ControlFlow.t _ _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.ops.try_trait.Try.branch
                                  (Self :=
                                    core.result.Result.t unit core.fmt.Error.t)
                                  (Trait := ℐ))) in
                            let* α1 : mut_ref core.fmt.Formatter.t :=
                              M.read f in
                            let* α2 : ref str.t := M.read (mk_str "") in
                            let* α3 : ref str.t := M.read (mk_str ".") in
                            let* α4 : ref str.t := M.read (mk_str " seconds") in
                            let* α5 : M.Val (array (ref str.t)) :=
                              M.alloc [ α2; α3; α4 ] in
                            let* α6 : i64.t :=
                              M.call
                                (nix.sys.time.TimeVal.t::["tv_usec"]
                                  (borrow abs)) in
                            let* α7 : M.Val i64.t := M.alloc α6 in
                            let* α8 : M.Val ((ref i64.t) * (ref i64.t)) :=
                              M.alloc (borrow α7, borrow sec) in
                            let* α9 : M.Val (array core.fmt.rt.Argument.t) :=
                              match_operator
                                α8
                                [
                                  fun γ =>
                                    (let* args := M.copy γ in
                                    let* α0 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α1 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α0) in
                                    let* α2 : ref i64.t :=
                                      M.read "Unknown Field" in
                                    let* α3 : core.fmt.rt.Argument.t :=
                                      M.call
                                        (core.fmt.rt.Argument.t::["new_display"]
                                          α2) in
                                    M.alloc [ α1; α3 ]) :
                                    M (M.Val (array core.fmt.rt.Argument.t))
                                ] in
                            let* α10 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 0) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 0) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  core.fmt.rt.Count.Implied) in
                            let* α11 : core.fmt.rt.Placeholder.t :=
                              M.call
                                (core.fmt.rt.Placeholder.t::["new"]
                                  ((Integer.of_Z 1) : usize.t)
                                  " "%char
                                  core.fmt.rt.Alignment.Unknown
                                  ((Integer.of_Z 8) : u32.t)
                                  core.fmt.rt.Count.Implied
                                  (core.fmt.rt.Count.Is
                                    ((Integer.of_Z 6) : usize.t))) in
                            let* α12 :
                                M.Val (array core.fmt.rt.Placeholder.t) :=
                              M.alloc [ α10; α11 ] in
                            let* α13 : core.fmt.rt.UnsafeArg.t :=
                              M.call core.fmt.rt.UnsafeArg.t::["new"] in
                            let* α14 : core.fmt.Arguments.t :=
                              M.call
                                (core.fmt.Arguments.t::["new_v1_formatted"]
                                  (pointer_coercion "Unsize" (borrow α5))
                                  (pointer_coercion "Unsize" (borrow α9))
                                  (pointer_coercion "Unsize" (borrow α12))
                                  α13) in
                            let* α15 :
                                core.result.Result.t unit core.fmt.Error.t :=
                              M.call
                                (core.fmt.Formatter.t::["write_fmt"] α1 α14) in
                            let* α16 :
                                core.ops.control_flow.ControlFlow.t
                                  (core.result.Result.t
                                    core.convert.Infallible.t
                                    core.fmt.Error.t)
                                  unit :=
                              M.call (α0 α15) in
                            let* α17 :
                                M.Val
                                  (core.ops.control_flow.ControlFlow.t
                                    (core.result.Result.t
                                      core.convert.Infallible.t
                                      core.fmt.Error.t)
                                    unit) :=
                              M.alloc α16 in
                            match_operator
                              α17
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.ops.control_flow.ControlFlow.Break _ =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Break_0
                                        γ in
                                    let* residual := M.copy γ0_0 in
                                    let* α0 :
                                        (core.result.Result.t
                                            core.convert.Infallible.t
                                            core.fmt.Error.t)
                                          ->
                                          M
                                            (core.result.Result.t
                                              unit
                                              core.fmt.Error.t) :=
                                      ltac:(M.get_method (fun ℐ =>
                                        core.ops.try_trait.FromResidual.from_residual
                                          (Self :=
                                            core.result.Result.t
                                              unit
                                              core.fmt.Error.t)
                                          (R :=
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              core.fmt.Error.t)
                                          (Trait := ℐ))) in
                                    let* α1 :
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          core.fmt.Error.t :=
                                      M.read residual in
                                    let* α2 :
                                        core.result.Result.t
                                          unit
                                          core.fmt.Error.t :=
                                      M.call (α0 α1) in
                                    let* α3 : M.Val never.t := return_ α2 in
                                    let* α4 := M.read α3 in
                                    let* α5 : unit := never_to_any α4 in
                                    M.alloc α5
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  |
                                      core.ops.control_flow.ControlFlow.Continue
                                        _
                                      =>
                                    let γ0_0 :=
                                      core.ops.control_flow.ControlFlow.Get_Continue_0
                                        γ in
                                    let* val := M.copy γ0_0 in
                                    M.pure val
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt in
                    M.alloc (core.result.Result.Ok tt)
                  end) :
                  M (M.Val (core.result.Result.t unit core.fmt.Error.t))
              ] in
          M.read α5).
      
      Global Instance AssociatedFunction_fmt :
        Notations.DoubleColon Self "fmt" := {
        Notations.double_colon := fmt;
      }.
      
      Global Instance ℐ : core.fmt.Display.Trait Self := {
        core.fmt.Display.fmt := fmt;
      }.
    End Impl_core_fmt_Display_for_nix_sys_time_TimeVal_t.
    End Impl_core_fmt_Display_for_nix_sys_time_TimeVal_t.
    
    Module  Impl_core_convert_From_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    Section Impl_core_convert_From_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
      Definition Self : Set := nix.sys.time.TimeVal.t.
      
      (*
          fn from(tv: timeval) -> Self {
              TimeVal(tv)
          }
      *)
      Definition from (tv : libc.unix.timeval.t) : M Self :=
        let* tv := M.alloc tv in
        let* α0 : libc.unix.timeval.t := M.read tv in
        M.pure (nix.sys.time.TimeVal.Build_t α0).
      
      Global Instance AssociatedFunction_from :
        Notations.DoubleColon Self "from" := {
        Notations.double_colon := from;
      }.
      
      Global Instance ℐ :
        core.convert.From.Trait Self (T := libc.unix.timeval.t) := {
        core.convert.From.from := from;
      }.
    End Impl_core_convert_From_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    End Impl_core_convert_From_libc_unix_timeval_t_for_nix_sys_time_TimeVal_t.
    
    (*
    fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {
        (div_floor_64(this, other), mod_floor_64(this, other))
    }
    *)
    Definition div_mod_floor_64
        (this : i64.t)
        (other : i64.t)
        : M (i64.t * i64.t) :=
      let* this := M.alloc this in
      let* other := M.alloc other in
      let* α0 : i64.t := M.read this in
      let* α1 : i64.t := M.read other in
      let* α2 : i64.t := M.call (nix.sys.time.div_floor_64 α0 α1) in
      let* α3 : i64.t := M.read this in
      let* α4 : i64.t := M.read other in
      let* α5 : i64.t := M.call (nix.sys.time.mod_floor_64 α3 α4) in
      M.pure (α2, α5).
    
    (*
    fn div_floor_64(this: i64, other: i64) -> i64 {
        match div_rem_64(this, other) {
            (d, r) if (r > 0 && other < 0) || (r < 0 && other > 0) => d - 1,
            (d, _) => d,
        }
    }
    *)
    Definition div_floor_64 (this : i64.t) (other : i64.t) : M i64.t :=
      let* this := M.alloc this in
      let* other := M.alloc other in
      let* α0 : i64.t := M.read this in
      let* α1 : i64.t := M.read other in
      let* α2 : i64.t * i64.t := M.call (nix.sys.time.div_rem_64 α0 α1) in
      let* α3 : M.Val (i64.t * i64.t) := M.alloc α2 in
      let* α4 : M.Val i64.t :=
        match_operator
          α3
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | (_, _) =>
                let γ0_0 := Tuple.Access.left γ in
                let γ0_1 := Tuple.Access.right γ in
                let* d := M.copy γ0_0 in
                let* r := M.copy γ0_1 in
                let* α0 : i64.t := M.read d in
                let* α1 : i64.t :=
                  BinOp.Panic.sub α0 ((Integer.of_Z 1) : i64.t) in
                M.alloc α1
              end) :
              M (M.Val i64.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | (_, _) =>
                let γ0_0 := Tuple.Access.left γ in
                let γ0_1 := Tuple.Access.right γ in
                let* d := M.copy γ0_0 in
                M.pure d
              end) :
              M (M.Val i64.t)
          ] in
      M.read α4.
    
    (*
    fn mod_floor_64(this: i64, other: i64) -> i64 {
        match this % other {
            r if (r > 0 && other < 0) || (r < 0 && other > 0) => r + other,
            r => r,
        }
    }
    *)
    Definition mod_floor_64 (this : i64.t) (other : i64.t) : M i64.t :=
      let* this := M.alloc this in
      let* other := M.alloc other in
      let* α0 : i64.t := M.read this in
      let* α1 : i64.t := M.read other in
      let* α2 : i64.t := BinOp.Panic.rem α0 α1 in
      let* α3 : M.Val i64.t := M.alloc α2 in
      let* α4 : M.Val i64.t :=
        match_operator
          α3
          [
            fun γ =>
              (let* r := M.copy γ in
              let* α0 : i64.t := M.read r in
              let* α1 : i64.t := M.read other in
              let* α2 : i64.t := BinOp.Panic.add α0 α1 in
              M.alloc α2) :
              M (M.Val i64.t);
            fun γ =>
              (let* r := M.copy γ in
              M.pure r) :
              M (M.Val i64.t)
          ] in
      M.read α4.
    
    (*
    fn div_rem_64(this: i64, other: i64) -> (i64, i64) {
        (this / other, this % other)
    }
    *)
    Definition div_rem_64 (this : i64.t) (other : i64.t) : M (i64.t * i64.t) :=
      let* this := M.alloc this in
      let* other := M.alloc other in
      let* α0 : i64.t := M.read this in
      let* α1 : i64.t := M.read other in
      let* α2 : i64.t := BinOp.Panic.div α0 α1 in
      let* α3 : i64.t := M.read this in
      let* α4 : i64.t := M.read other in
      let* α5 : i64.t := BinOp.Panic.rem α3 α4 in
      M.pure (α2, α5).
  End time.
End sys.

Module unistd.
  (*
  pub fn close(fd: RawFd) -> Result<()> {
      let res = unsafe { libc::close(fd) };
      Errno::result(res).map(drop)
  }
  *)
  Definition close
      (fd : ltac:(std.os.fd.raw.RawFd))
      : M ltac:(nix.Result unit) :=
    let* fd := M.alloc fd in
    let* res : M.Val i32.t :=
      let* α0 : i32.t := M.read fd in
      let* α1 : i32.t := M.call (libc.unix.close α0) in
      M.alloc α1 in
    let* α0 : i32.t := M.read res in
    let* α1 : core.result.Result.t i32.t nix.errno.consts.Errno.t :=
      M.call (nix.errno.consts.Errno.t::["result"] α0) in
    let* α2 : core.result.Result.t unit nix.errno.consts.Errno.t :=
      M.call
        ((core.result.Result.t i32.t nix.errno.consts.Errno.t)::["map"]
          α1
          core.mem.drop) in
    let* α0 : M.Val (core.result.Result.t unit nix.errno.consts.Errno.t) :=
      M.alloc α2 in
    M.read α0.
  
  (*
  pub fn read(fd: RawFd, buf: &mut [u8]) -> Result<usize> {
      let res =
          unsafe { libc::read(fd, buf.as_mut_ptr().cast(), buf.len() as size_t) };
  
      Errno::result(res).map(|r| r as usize)
  }
  *)
  Definition read
      (fd : ltac:(std.os.fd.raw.RawFd))
      (buf : mut_ref (slice u8.t))
      : M ltac:(nix.Result usize.t) :=
    let* fd := M.alloc fd in
    let* buf := M.alloc buf in
    let* res : M.Val isize.t :=
      let* α0 : i32.t := M.read fd in
      let* α1 : mut_ref (slice u8.t) := M.read buf in
      let* α2 : mut_ref u8.t := M.call ((slice u8.t)::["as_mut_ptr"] α1) in
      let* α3 : mut_ref core.ffi.c_void.t :=
        M.call ((mut_ref u8.t)::["cast"] α2) in
      let* α4 : mut_ref (slice u8.t) := M.read buf in
      let* α5 : usize.t := M.call ((slice u8.t)::["len"] (borrow (deref α4))) in
      let* α6 : M.Val usize.t := M.alloc α5 in
      let* α7 : usize.t := M.read (use α6) in
      let* α8 : isize.t := M.call (libc.unix.read α0 α3 α7) in
      M.alloc α8 in
    let* α0 : isize.t := M.read res in
    let* α1 : core.result.Result.t isize.t nix.errno.consts.Errno.t :=
      M.call (nix.errno.consts.Errno.t::["result"] α0) in
    let* α2 : core.result.Result.t usize.t nix.errno.consts.Errno.t :=
      M.call
        ((core.result.Result.t isize.t nix.errno.consts.Errno.t)::["map"]
          α1
          (fun (α0 : isize.t) =>
            (let* α0 := M.alloc α0 in
            match_operator
              α0
              [
                fun γ =>
                  (let* r := M.copy γ in
                  let* α0 : isize.t := M.read r in
                  M.pure (rust_cast α0)) :
                  M usize.t
              ]) :
            M usize.t)) in
    let* α0 : M.Val (core.result.Result.t usize.t nix.errno.consts.Errno.t) :=
      M.alloc α2 in
    M.read α0.
  
  (*
  pub fn write<Fd: AsFd>(fd: Fd, buf: &[u8]) -> Result<usize> {
      let res = unsafe {
          libc::write(
              fd.as_fd().as_raw_fd(),
              buf.as_ptr().cast(),
              buf.len() as size_t,
          )
      };
  
      Errno::result(res).map(|r| r as usize)
  }
  *)
  Definition write
      {Fd : Set}
      (fd : Fd)
      (buf : ref (slice u8.t))
      : M ltac:(nix.Result usize.t) :=
    let* fd := M.alloc fd in
    let* buf := M.alloc buf in
    let* res : M.Val isize.t :=
      let* α0 : (ref std.os.fd.owned.BorrowedFd.t) -> M i32.t :=
        ltac:(M.get_method (fun ℐ =>
          std.os.fd.raw.AsRawFd.as_raw_fd
            (Self := std.os.fd.owned.BorrowedFd.t)
            (Trait := ℐ))) in
      let* α1 : (ref Fd) -> M std.os.fd.owned.BorrowedFd.t :=
        ltac:(M.get_method (fun ℐ =>
          std.os.fd.owned.AsFd.as_fd (Self := Fd) (Trait := ℐ))) in
      let* α2 : std.os.fd.owned.BorrowedFd.t := M.call (α1 (borrow fd)) in
      let* α3 : M.Val std.os.fd.owned.BorrowedFd.t := M.alloc α2 in
      let* α4 : i32.t := M.call (α0 (borrow α3)) in
      let* α5 : ref (slice u8.t) := M.read buf in
      let* α6 : ref u8.t := M.call ((slice u8.t)::["as_ptr"] α5) in
      let* α7 : ref core.ffi.c_void.t := M.call ((ref u8.t)::["cast"] α6) in
      let* α8 : ref (slice u8.t) := M.read buf in
      let* α9 : usize.t := M.call ((slice u8.t)::["len"] α8) in
      let* α10 : M.Val usize.t := M.alloc α9 in
      let* α11 : usize.t := M.read (use α10) in
      let* α12 : isize.t := M.call (libc.unix.write α4 α7 α11) in
      M.alloc α12 in
    let* α0 : isize.t := M.read res in
    let* α1 : core.result.Result.t isize.t nix.errno.consts.Errno.t :=
      M.call (nix.errno.consts.Errno.t::["result"] α0) in
    let* α2 : core.result.Result.t usize.t nix.errno.consts.Errno.t :=
      M.call
        ((core.result.Result.t isize.t nix.errno.consts.Errno.t)::["map"]
          α1
          (fun (α0 : isize.t) =>
            (let* α0 := M.alloc α0 in
            match_operator
              α0
              [
                fun γ =>
                  (let* r := M.copy γ in
                  let* α0 : isize.t := M.read r in
                  M.pure (rust_cast α0)) :
                  M usize.t
              ]) :
            M usize.t)) in
    let* α0 : M.Val (core.result.Result.t usize.t nix.errno.consts.Errno.t) :=
      M.alloc α2 in
    M.read α0.
  
  (*
  pub fn pipe() -> std::result::Result<(OwnedFd, OwnedFd), Error> {
      let mut fds = mem::MaybeUninit::<[OwnedFd; 2]>::uninit();
  
      let res = unsafe { libc::pipe(fds.as_mut_ptr().cast()) };
  
      Error::result(res)?;
  
      let [read, write] = unsafe { fds.assume_init() };
      Ok((read, write))
  }
  *)
  Definition pipe
      :
        M
          (core.result.Result.t
            (std.os.fd.owned.OwnedFd.t * std.os.fd.owned.OwnedFd.t)
            ltac:(nix.Error)) :=
    let return_ :=
      M.return_
        (R :=
          core.result.Result.t
            (std.os.fd.owned.OwnedFd.t * std.os.fd.owned.OwnedFd.t)
            ltac:(nix.Error)) in
    M.catch_return
      (let* fds :
          M.Val
            (core.mem.maybe_uninit.MaybeUninit.t
              (array std.os.fd.owned.OwnedFd.t)) :=
        let* α0 :
            core.mem.maybe_uninit.MaybeUninit.t
              (array std.os.fd.owned.OwnedFd.t) :=
          M.call
            (core.mem.maybe_uninit.MaybeUninit.t
                (array std.os.fd.owned.OwnedFd.t))::["uninit"] in
        M.alloc α0 in
      let* res : M.Val i32.t :=
        let* α0 : mut_ref (array std.os.fd.owned.OwnedFd.t) :=
          M.call
            ((core.mem.maybe_uninit.MaybeUninit.t
                  (array std.os.fd.owned.OwnedFd.t))::["as_mut_ptr"]
              (borrow_mut fds)) in
        let* α1 : mut_ref i32.t :=
          M.call ((mut_ref (array std.os.fd.owned.OwnedFd.t))::["cast"] α0) in
        let* α2 : i32.t := M.call (libc.unix.pipe α1) in
        M.alloc α2 in
      let* _ : M.Val i32.t :=
        let* α0 :
            (core.result.Result.t i32.t nix.errno.consts.Errno.t) ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self := core.result.Result.t i32.t nix.errno.consts.Errno.t)
              (Trait := ℐ))) in
        let* α1 : i32.t := M.read res in
        let* α2 : core.result.Result.t i32.t nix.errno.consts.Errno.t :=
          M.call (nix.errno.consts.Errno.t::["result"] α1) in
        let* α3 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                nix.errno.consts.Errno.t)
              i32.t :=
          M.call (α0 α2) in
        let* α4 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  nix.errno.consts.Errno.t)
                i32.t) :=
          M.alloc α3 in
        match_operator
          α4
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.result.Result.t
                        core.convert.Infallible.t
                        nix.errno.consts.Errno.t)
                      ->
                      M
                        (core.result.Result.t
                          (std.os.fd.owned.OwnedFd.t
                          *
                          std.os.fd.owned.OwnedFd.t)
                          nix.errno.consts.Errno.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self :=
                        core.result.Result.t
                          (std.os.fd.owned.OwnedFd.t
                          *
                          std.os.fd.owned.OwnedFd.t)
                          nix.errno.consts.Errno.t)
                      (R :=
                        core.result.Result.t
                          core.convert.Infallible.t
                          nix.errno.consts.Errno.t)
                      (Trait := ℐ))) in
                let* α1 :
                    core.result.Result.t
                      core.convert.Infallible.t
                      nix.errno.consts.Errno.t :=
                  M.read residual in
                let* α2 :
                    core.result.Result.t
                      (std.os.fd.owned.OwnedFd.t * std.os.fd.owned.OwnedFd.t)
                      nix.errno.consts.Errno.t :=
                  M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : i32.t := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val i32.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val i32.t)
          ] in
      let* α0 :
          core.mem.maybe_uninit.MaybeUninit.t
            (array std.os.fd.owned.OwnedFd.t) :=
        M.read fds in
      let* α1 : array std.os.fd.owned.OwnedFd.t :=
        M.call
          ((core.mem.maybe_uninit.MaybeUninit.t
                (array std.os.fd.owned.OwnedFd.t))::["assume_init"]
            α0) in
      let* α2 : M.Val (array std.os.fd.owned.OwnedFd.t) := M.alloc α1 in
      let* α0 :
          M.Val
            (core.result.Result.t
              (std.os.fd.owned.OwnedFd.t * std.os.fd.owned.OwnedFd.t)
              nix.errno.consts.Errno.t) :=
        match_operator
          α2
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | [_; _] =>
                let γ0_0 := [0] γ in
                let γ0_1 := [1] γ in
                let* read := M.copy γ0_0 in
                let* write := M.copy γ0_1 in
                let* α0 : std.os.fd.owned.OwnedFd.t := M.read read in
                let* α1 : std.os.fd.owned.OwnedFd.t := M.read write in
                M.alloc (core.result.Result.Ok (α0, α1))
              | _ => M.break_match
              end) :
              M
                (M.Val
                  (core.result.Result.t
                    (std.os.fd.owned.OwnedFd.t * std.os.fd.owned.OwnedFd.t)
                    nix.errno.consts.Errno.t))
          ] in
      M.read α0).
  
  (*
  pub fn sleep(seconds: c_uint) -> c_uint {
      unsafe { libc::sleep(seconds) }
  }
  *)
  Definition sleep
      (seconds : ltac:(libc.unix.c_uint))
      : M ltac:(libc.unix.c_uint) :=
    let* seconds := M.alloc seconds in
    let* α0 : u32.t := M.read seconds in
    M.call (libc.unix.sleep α0).
  
  Module setres.
    
  End setres.
  
  Module getres.
    
  End getres.
End unistd.

Ltac Result T := exact (core.result.Result.t T nix.errno.consts.Errno.t).

Ltac Error := exact nix.errno.consts.Errno.t.

Module  NixPath.
Section NixPath.
  Class Trait (Self : Set) : Type := {
    is_empty : (ref Self) -> M bool.t;
    len : (ref Self) -> M usize.t;
    with_nix_path {T F : Set} : (ref Self) -> F -> M ltac:(nix.Result T);
  }.
  
End NixPath.
End NixPath.

Module  Impl_nix_NixPath_for_str_t.
Section Impl_nix_NixPath_for_str_t.
  Definition Self : Set := str.t.
  
  (*
      fn is_empty(&self) -> bool {
          NixPath::is_empty(OsStr::new(self))
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.is_empty (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : ref str.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.ffi.os_str.OsStr.t::["new"] α1) in
    M.call (α0 α2).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          NixPath::len(OsStr::new(self))
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M usize.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.len (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : ref str.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.ffi.os_str.OsStr.t::["new"] α1) in
    M.call (α0 α2).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          OsStr::new(self).with_nix_path(f)
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 :
        (ref std.ffi.os_str.OsStr.t) ->
          F ->
          M (core.result.Result.t T nix.errno.consts.Errno.t) :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.with_nix_path
          (Self := std.ffi.os_str.OsStr.t)
          (T := T)
          (F := F)
          (Trait := ℐ))) in
    let* α1 : ref str.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.ffi.os_str.OsStr.t::["new"] α1) in
    let* α3 : F := M.read f in
    M.call (α0 α2 α3).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_str_t.
End Impl_nix_NixPath_for_str_t.

Module  Impl_nix_NixPath_for_std_ffi_os_str_OsStr_t.
Section Impl_nix_NixPath_for_std_ffi_os_str_OsStr_t.
  Definition Self : Set := std.ffi.os_str.OsStr.t.
  
  (*
      fn is_empty(&self) -> bool {
          self.as_bytes().is_empty()
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M (ref (slice u8.t)) :=
      ltac:(M.get_method (fun ℐ =>
        std.os.unix.ffi.os_str.OsStrExt.as_bytes
          (Self := std.ffi.os_str.OsStr.t)
          (Trait := ℐ))) in
    let* α1 : ref std.ffi.os_str.OsStr.t := M.read self in
    let* α2 : ref (slice u8.t) := M.call (α0 α1) in
    M.call ((slice u8.t)::["is_empty"] α2).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          self.as_bytes().len()
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M (ref (slice u8.t)) :=
      ltac:(M.get_method (fun ℐ =>
        std.os.unix.ffi.os_str.OsStrExt.as_bytes
          (Self := std.ffi.os_str.OsStr.t)
          (Trait := ℐ))) in
    let* α1 : ref std.ffi.os_str.OsStr.t := M.read self in
    let* α2 : ref (slice u8.t) := M.call (α0 α1) in
    M.call ((slice u8.t)::["len"] α2).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          self.as_bytes().with_nix_path(f)
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 :
        (ref (slice u8.t)) ->
          F ->
          M (core.result.Result.t T nix.errno.consts.Errno.t) :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.with_nix_path
          (Self := slice u8.t)
          (T := T)
          (F := F)
          (Trait := ℐ))) in
    let* α1 : (ref std.ffi.os_str.OsStr.t) -> M (ref (slice u8.t)) :=
      ltac:(M.get_method (fun ℐ =>
        std.os.unix.ffi.os_str.OsStrExt.as_bytes
          (Self := std.ffi.os_str.OsStr.t)
          (Trait := ℐ))) in
    let* α2 : ref std.ffi.os_str.OsStr.t := M.read self in
    let* α3 : ref (slice u8.t) := M.call (α1 α2) in
    let* α4 : F := M.read f in
    M.call (α0 α3 α4).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_std_ffi_os_str_OsStr_t.
End Impl_nix_NixPath_for_std_ffi_os_str_OsStr_t.

Module  Impl_nix_NixPath_for_core_ffi_c_str_CStr_t.
Section Impl_nix_NixPath_for_core_ffi_c_str_CStr_t.
  Definition Self : Set := core.ffi.c_str.CStr.t.
  
  (*
      fn is_empty(&self) -> bool {
          self.to_bytes().is_empty()
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : ref core.ffi.c_str.CStr.t := M.read self in
    let* α1 : ref (slice u8.t) :=
      M.call (core.ffi.c_str.CStr.t::["to_bytes"] α0) in
    M.call ((slice u8.t)::["is_empty"] α1).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          self.to_bytes().len()
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : ref core.ffi.c_str.CStr.t := M.read self in
    let* α1 : ref (slice u8.t) :=
      M.call (core.ffi.c_str.CStr.t::["to_bytes"] α0) in
    M.call ((slice u8.t)::["len"] α1).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          Ok(f(self))
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 : F -> (ref core.ffi.c_str.CStr.t) -> M _ :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.function.FnOnce.call_once
          (Self := F)
          (Args := ref core.ffi.c_str.CStr.t)
          (Trait := ℐ))) in
    let* α1 : F := M.read f in
    let* α2 : ref core.ffi.c_str.CStr.t := M.read self in
    let* α3 : T := M.call (α0 α1 (α2)) in
    M.pure (core.result.Result.Ok α3).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_core_ffi_c_str_CStr_t.
End Impl_nix_NixPath_for_core_ffi_c_str_CStr_t.

Module  Impl_nix_NixPath_for_slice_u8_t.
Section Impl_nix_NixPath_for_slice_u8_t.
  Definition Self : Set := slice u8.t.
  
  (*
      fn is_empty(&self) -> bool {
          self.is_empty()
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : ref (slice u8.t) := M.read self in
    M.call ((slice u8.t)::["is_empty"] α0).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          self.len()
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : ref (slice u8.t) := M.read self in
    M.call ((slice u8.t)::["len"] α0).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          // The real PATH_MAX is typically 4096, but it's statistically unlikely to have a path
          // longer than ~300 bytes. See the the PR description to get stats for your own machine.
          // https://github.com/nix-rust/nix/pull/1656
          //
          // By being smaller than a memory page, we also avoid the compiler inserting a probe frame:
          // https://docs.rs/compiler_builtins/latest/compiler_builtins/probestack/index.html
          const MAX_STACK_ALLOCATION: usize = 1024;
  
          if self.len() >= MAX_STACK_ALLOCATION {
              return with_nix_path_allocating(self, f);
          }
  
          let mut buf = MaybeUninit::<[u8; MAX_STACK_ALLOCATION]>::uninit();
          let buf_ptr = buf.as_mut_ptr().cast();
  
          unsafe {
              ptr::copy_nonoverlapping(self.as_ptr(), buf_ptr, self.len());
              buf_ptr.add(self.len()).write(0);
          }
  
          match CStr::from_bytes_with_nul(unsafe {
              slice::from_raw_parts(buf_ptr, self.len() + 1)
          }) {
              Ok(s) => Ok(f(s)),
              Err(_) => Err(Errno::EINVAL),
          }
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let return_ := M.return_ (R := ltac:(nix.Result T)) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : ref (slice u8.t) := M.read self in
        let* α1 : usize.t := M.call ((slice u8.t)::["len"] α0) in
        let* α2 : usize.t := M.read nix.with_nix_path.MAX_STACK_ALLOCATION in
        let* α3 : M.Val bool.t := M.alloc (BinOp.Pure.ge α1 α2) in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* α0 : ref (slice u8.t) := M.read self in
          let* α1 : F := M.read f in
          let* α2 : core.result.Result.t T nix.errno.consts.Errno.t :=
            M.call (nix.with_nix_path_allocating α0 α1) in
          let* α3 : M.Val never.t := return_ α2 in
          let* α4 := M.read α3 in
          let* α5 : unit := never_to_any α4 in
          M.alloc α5
        else
          M.alloc tt in
      let* buf : M.Val (core.mem.maybe_uninit.MaybeUninit.t (array u8.t)) :=
        let* α0 : core.mem.maybe_uninit.MaybeUninit.t (array u8.t) :=
          M.call
            (core.mem.maybe_uninit.MaybeUninit.t (array u8.t))::["uninit"] in
        M.alloc α0 in
      let* buf_ptr : M.Val (mut_ref u8.t) :=
        let* α0 : mut_ref (array u8.t) :=
          M.call
            ((core.mem.maybe_uninit.MaybeUninit.t (array u8.t))::["as_mut_ptr"]
              (borrow_mut buf)) in
        let* α1 : mut_ref u8.t :=
          M.call ((mut_ref (array u8.t))::["cast"] α0) in
        M.alloc α1 in
      let* _ : M.Val unit :=
        let* _ : M.Val unit :=
          let* α0 : ref (slice u8.t) := M.read self in
          let* α1 : ref u8.t := M.call ((slice u8.t)::["as_ptr"] α0) in
          let* α2 : mut_ref u8.t := M.read buf_ptr in
          let* α3 : ref (slice u8.t) := M.read self in
          let* α4 : usize.t := M.call ((slice u8.t)::["len"] α3) in
          let* α5 : unit :=
            M.call (core.intrinsics.copy_nonoverlapping α1 α2 α4) in
          M.alloc α5 in
        let* _ : M.Val unit :=
          let* α0 : mut_ref u8.t := M.read buf_ptr in
          let* α1 : ref (slice u8.t) := M.read self in
          let* α2 : usize.t := M.call ((slice u8.t)::["len"] α1) in
          let* α3 : mut_ref u8.t := M.call ((mut_ref u8.t)::["add"] α0 α2) in
          let* α4 : unit :=
            M.call ((mut_ref u8.t)::["write"] α3 ((Integer.of_Z 0) : u8.t)) in
          M.alloc α4 in
        M.alloc tt in
      let* α0 : mut_ref u8.t := M.read buf_ptr in
      let* α1 : ref (slice u8.t) := M.read self in
      let* α2 : usize.t := M.call ((slice u8.t)::["len"] α1) in
      let* α3 : usize.t := BinOp.Panic.add α2 ((Integer.of_Z 1) : usize.t) in
      let* α4 : ref (slice u8.t) :=
        M.call
          (core.slice.raw.from_raw_parts
            (pointer_coercion "MutToConstPointer" α0)
            α3) in
      let* α5 :
          core.result.Result.t
            (ref core.ffi.c_str.CStr.t)
            core.ffi.c_str.FromBytesWithNulError.t :=
        M.call (core.ffi.c_str.CStr.t::["from_bytes_with_nul"] α4) in
      let* α6 :
          M.Val
            (core.result.Result.t
              (ref core.ffi.c_str.CStr.t)
              core.ffi.c_str.FromBytesWithNulError.t) :=
        M.alloc α5 in
      let* α0 : M.Val (core.result.Result.t T nix.errno.consts.Errno.t) :=
        match_operator
          α6
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.result.Result.Ok _ =>
                let γ0_0 := core.result.Result.Get_Ok_0 γ in
                let* s := M.copy γ0_0 in
                let* α0 : F -> (ref core.ffi.c_str.CStr.t) -> M _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.function.FnOnce.call_once
                      (Self := F)
                      (Args := ref core.ffi.c_str.CStr.t)
                      (Trait := ℐ))) in
                let* α1 : F := M.read f in
                let* α2 : ref core.ffi.c_str.CStr.t := M.read s in
                let* α3 : T := M.call (α0 α1 (α2)) in
                M.alloc (core.result.Result.Ok α3)
              | _ => M.break_match
              end) :
              M (M.Val (core.result.Result.t T nix.errno.consts.Errno.t));
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.result.Result.Err _ =>
                let γ0_0 := core.result.Result.Get_Err_0 γ in
                M.alloc (core.result.Result.Err nix.errno.consts.Errno.EINVAL)
              | _ => M.break_match
              end) :
              M (M.Val (core.result.Result.t T nix.errno.consts.Errno.t))
          ] in
      M.read α0).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_slice_u8_t.
End Impl_nix_NixPath_for_slice_u8_t.

(*
fn with_nix_path_allocating<T, F>(from: &[u8], f: F) -> Result<T>
where
    F: FnOnce(&CStr) -> T,
{
    match CString::new(from) {
        Ok(s) => Ok(f(&s)),
        Err(_) => Err(Errno::EINVAL),
    }
}
*)
Definition with_nix_path_allocating
    {T F : Set}
    (from : ref (slice u8.t))
    (f : F)
    : M ltac:(nix.Result T) :=
  let* from := M.alloc from in
  let* f := M.alloc f in
  let* α0 : ref (slice u8.t) := M.read from in
  let* α1 :
      core.result.Result.t
        alloc.ffi.c_str.CString.t
        alloc.ffi.c_str.NulError.t :=
    M.call (alloc.ffi.c_str.CString.t::["new"] α0) in
  let* α2 :
      M.Val
        (core.result.Result.t
          alloc.ffi.c_str.CString.t
          alloc.ffi.c_str.NulError.t) :=
    M.alloc α1 in
  let* α3 : M.Val (core.result.Result.t T nix.errno.consts.Errno.t) :=
    match_operator
      α2
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.result.Result.Ok _ =>
            let γ0_0 := core.result.Result.Get_Ok_0 γ in
            let* s := M.copy γ0_0 in
            let* α0 : F -> (ref core.ffi.c_str.CStr.t) -> M _ :=
              ltac:(M.get_method (fun ℐ =>
                core.ops.function.FnOnce.call_once
                  (Self := F)
                  (Args := ref core.ffi.c_str.CStr.t)
                  (Trait := ℐ))) in
            let* α1 : F := M.read f in
            let* α2 : (ref alloc.ffi.c_str.CString.t) -> M (ref _) :=
              ltac:(M.get_method (fun ℐ =>
                core.ops.deref.Deref.deref
                  (Self := alloc.ffi.c_str.CString.t)
                  (Trait := ℐ))) in
            let* α3 : ref core.ffi.c_str.CStr.t := M.call (α2 (borrow s)) in
            let* α4 : T := M.call (α0 α1 (α3)) in
            M.alloc (core.result.Result.Ok α4)
          | _ => M.break_match
          end) :
          M (M.Val (core.result.Result.t T nix.errno.consts.Errno.t));
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | core.result.Result.Err _ =>
            let γ0_0 := core.result.Result.Get_Err_0 γ in
            M.alloc (core.result.Result.Err nix.errno.consts.Errno.EINVAL)
          | _ => M.break_match
          end) :
          M (M.Val (core.result.Result.t T nix.errno.consts.Errno.t))
      ] in
  M.read α3.

Module  Impl_nix_NixPath_for_std_path_Path_t.
Section Impl_nix_NixPath_for_std_path_Path_t.
  Definition Self : Set := std.path.Path.t.
  
  (*
      fn is_empty(&self) -> bool {
          NixPath::is_empty(self.as_os_str())
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.is_empty (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : ref std.path.Path.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α1) in
    M.call (α0 α2).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          NixPath::len(self.as_os_str())
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M usize.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.len (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : ref std.path.Path.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α1) in
    M.call (α0 α2).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          self.as_os_str().with_nix_path(f)
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 :
        (ref std.ffi.os_str.OsStr.t) ->
          F ->
          M (core.result.Result.t T nix.errno.consts.Errno.t) :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.with_nix_path
          (Self := std.ffi.os_str.OsStr.t)
          (T := T)
          (F := F)
          (Trait := ℐ))) in
    let* α1 : ref std.path.Path.t := M.read self in
    let* α2 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α1) in
    let* α3 : F := M.read f in
    M.call (α0 α2 α3).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_std_path_Path_t.
End Impl_nix_NixPath_for_std_path_Path_t.

Module  Impl_nix_NixPath_for_std_path_PathBuf_t.
Section Impl_nix_NixPath_for_std_path_PathBuf_t.
  Definition Self : Set := std.path.PathBuf.t.
  
  (*
      fn is_empty(&self) -> bool {
          NixPath::is_empty(self.as_os_str())
      }
  *)
  Definition is_empty (self : ref Self) : M bool.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.is_empty (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : (ref std.path.PathBuf.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := std.path.PathBuf.t)
          (Trait := ℐ))) in
    let* α2 : ref std.path.PathBuf.t := M.read self in
    let* α3 : ref std.path.Path.t := M.call (α1 α2) in
    let* α4 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α3) in
    M.call (α0 α4).
  
  Global Instance AssociatedFunction_is_empty :
    Notations.DoubleColon Self "is_empty" := {
    Notations.double_colon := is_empty;
  }.
  
  (*
      fn len(&self) -> usize {
          NixPath::len(self.as_os_str())
      }
  *)
  Definition len (self : ref Self) : M usize.t :=
    let* self := M.alloc self in
    let* α0 : (ref std.ffi.os_str.OsStr.t) -> M usize.t :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.len (Self := std.ffi.os_str.OsStr.t) (Trait := ℐ))) in
    let* α1 : (ref std.path.PathBuf.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := std.path.PathBuf.t)
          (Trait := ℐ))) in
    let* α2 : ref std.path.PathBuf.t := M.read self in
    let* α3 : ref std.path.Path.t := M.call (α1 α2) in
    let* α4 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α3) in
    M.call (α0 α4).
  
  Global Instance AssociatedFunction_len : Notations.DoubleColon Self "len" := {
    Notations.double_colon := len;
  }.
  
  (*
      fn with_nix_path<T, F>(&self, f: F) -> Result<T>
      where
          F: FnOnce(&CStr) -> T,
      {
          self.as_os_str().with_nix_path(f)
      }
  *)
  Definition with_nix_path
      {T F : Set}
      (self : ref Self)
      (f : F)
      : M ltac:(nix.Result T) :=
    let* self := M.alloc self in
    let* f := M.alloc f in
    let* α0 :
        (ref std.ffi.os_str.OsStr.t) ->
          F ->
          M (core.result.Result.t T nix.errno.consts.Errno.t) :=
      ltac:(M.get_method (fun ℐ =>
        nix.NixPath.with_nix_path
          (Self := std.ffi.os_str.OsStr.t)
          (T := T)
          (F := F)
          (Trait := ℐ))) in
    let* α1 : (ref std.path.PathBuf.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := std.path.PathBuf.t)
          (Trait := ℐ))) in
    let* α2 : ref std.path.PathBuf.t := M.read self in
    let* α3 : ref std.path.Path.t := M.call (α1 α2) in
    let* α4 : ref std.ffi.os_str.OsStr.t :=
      M.call (std.path.Path.t::["as_os_str"] α3) in
    let* α5 : F := M.read f in
    M.call (α0 α4 α5).
  
  Global Instance AssociatedFunction_with_nix_path {T F : Set} :
    Notations.DoubleColon Self "with_nix_path" := {
    Notations.double_colon := with_nix_path (T := T) (F := F);
  }.
  
  Global Instance ℐ : nix.NixPath.Trait Self := {
    nix.NixPath.is_empty := is_empty;
    nix.NixPath.len := len;
    nix.NixPath.with_nix_path {T F : Set} := with_nix_path (T := T) (F := F);
  }.
End Impl_nix_NixPath_for_std_path_PathBuf_t.
End Impl_nix_NixPath_for_std_path_PathBuf_t.
