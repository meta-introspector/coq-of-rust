(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn main() {
    let args = Args::parse_from(std::env::args().skip(1));

    let coq_of_rust_rustc_path = std::env::current_exe()
        .expect("current executable path invalid")
        .with_file_name("coq-of-rust-rustc");

    let cargo_path = env::var("CARGO_PATH").unwrap_or_else(|_| "cargo".to_string());
    let cargo_cmd = if std::env::var_os("COQ_OF_RUST_CONTINUE").is_some() {
        "build"
    } else {
        "check"
    };
    let mut cmd = Command::new(cargo_path);
    cmd.arg(cargo_cmd)
        .args(args.rust_flags)
        .env("RUSTC_WRAPPER", coq_of_rust_rustc_path)
        .env("CARGO_COQ_OF_RUST", "1");

    cmd.env(
        "COQ_OF_RUST_ARGS",
        serde_json::to_string(&args.coq_of_rust).unwrap(),
    );

    let exit_status = cmd.status().expect("could not run cargo");
    if !exit_status.success() {
        exit(exit_status.code().unwrap_or(-1));
    }
}
*)
Definition main : M unit :=
  let* args : M.Val coq_of_rust_lib.options.Args.t :=
    let* α0 :
        (core.iter.adapters.skip.Skip.t std.env.Args.t) ->
          M coq_of_rust_lib.options.Args.t :=
      ltac:(M.get_method (fun ℐ =>
        clap.derive.Parser.parse_from
          (Self := coq_of_rust_lib.options.Args.t)
          (I := core.iter.adapters.skip.Skip.t std.env.Args.t)
          (T := alloc.string.String.t)
          (Trait := ℐ))) in
    let* α1 :
        std.env.Args.t ->
          usize.t ->
          M (core.iter.adapters.skip.Skip.t std.env.Args.t) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.skip
          (Self := std.env.Args.t)
          (Trait := ℐ))) in
    let* α2 : std.env.Args.t := M.call std.env.args in
    let* α3 : core.iter.adapters.skip.Skip.t std.env.Args.t :=
      M.call (α1 α2 ((Integer.of_Z 1) : usize.t)) in
    let* α4 : coq_of_rust_lib.options.Args.t := M.call (α0 α3) in
    M.alloc α4 in
  let* coq_of_rust_rustc_path : M.Val std.path.PathBuf.t :=
    let* α0 : (ref std.path.PathBuf.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := std.path.PathBuf.t)
          (Trait := ℐ))) in
    let* α1 : core.result.Result.t std.path.PathBuf.t std.io.error.Error.t :=
      M.call std.env.current_exe in
    let* α2 : ref str.t := M.read (mk_str "current executable path invalid") in
    let* α3 : std.path.PathBuf.t :=
      M.call
        ((core.result.Result.t
              std.path.PathBuf.t
              std.io.error.Error.t)::["expect"]
          α1
          α2) in
    let* α4 : M.Val std.path.PathBuf.t := M.alloc α3 in
    let* α5 : ref std.path.Path.t := M.call (α0 (borrow α4)) in
    let* α6 : ref str.t := M.read (mk_str "coq-of-rust-rustc") in
    let* α7 : std.path.PathBuf.t :=
      M.call (std.path.Path.t::["with_file_name"] α5 α6) in
    M.alloc α7 in
  let* cargo_path : M.Val alloc.string.String.t :=
    let* α0 : ref str.t := M.read (mk_str "CARGO_PATH") in
    let* α1 : core.result.Result.t alloc.string.String.t std.env.VarError.t :=
      M.call (std.env.var α0) in
    let* α2 : alloc.string.String.t :=
      M.call
        ((core.result.Result.t
              alloc.string.String.t
              std.env.VarError.t)::["unwrap_or_else"]
          α1
          (fun (α0 : std.env.VarError.t) =>
            (let* α0 := M.alloc α0 in
            match_operator
              α0
              [
                fun γ =>
                  (let* α0 : (ref str.t) -> M alloc.string.String.t :=
                    ltac:(M.get_method (fun ℐ =>
                      alloc.string.ToString.to_string
                        (Self := str.t)
                        (Trait := ℐ))) in
                  let* α1 : ref str.t := M.read (mk_str "cargo") in
                  M.call (α0 α1)) :
                  M alloc.string.String.t
              ]) :
            M alloc.string.String.t)) in
    M.alloc α2 in
  let* cargo_cmd : M.Val (ref str.t) :=
    let* α0 : ref str.t := M.read (mk_str "COQ_OF_RUST_CONTINUE") in
    let* α1 : core.option.Option.t std.ffi.os_str.OsString.t :=
      M.call (std.env.var_os α0) in
    let* α2 : M.Val (core.option.Option.t std.ffi.os_str.OsString.t) :=
      M.alloc α1 in
    let* α3 : bool.t :=
      M.call
        ((core.option.Option.t std.ffi.os_str.OsString.t)::["is_some"]
          (borrow α2)) in
    let* α4 : M.Val bool.t := M.alloc α3 in
    let* α5 : bool.t := M.read (use α4) in
    let* α6 : M.Val (ref str.t) :=
      if α5 then
        M.pure (mk_str "build")
      else
        let* α0 : ref str.t := M.read (mk_str "check") in
        M.alloc α0 in
    M.copy α6 in
  let* cmd : M.Val std.process.Command.t :=
    let* α0 : alloc.string.String.t := M.read cargo_path in
    let* α1 : std.process.Command.t :=
      M.call (std.process.Command.t::["new"] α0) in
    M.alloc α1 in
  let* _ : M.Val (mut_ref std.process.Command.t) :=
    let* α0 : ref str.t := M.read cargo_cmd in
    let* α1 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] (borrow_mut cmd) α0) in
    let* α2 : alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t :=
      M.read (coq_of_rust_lib.options.Args.Get_rust_flags args) in
    let* α3 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["args"] α1 α2) in
    let* α4 : ref str.t := M.read (mk_str "RUSTC_WRAPPER") in
    let* α5 : std.path.PathBuf.t := M.read coq_of_rust_rustc_path in
    let* α6 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["env"] α3 α4 α5) in
    let* α7 : ref str.t := M.read (mk_str "CARGO_COQ_OF_RUST") in
    let* α8 : ref str.t := M.read (mk_str "1") in
    let* α9 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["env"] α6 α7 α8) in
    M.alloc α9 in
  let* _ : M.Val (mut_ref std.process.Command.t) :=
    let* α0 : ref str.t := M.read (mk_str "COQ_OF_RUST_ARGS") in
    let* α1 :
        core.result.Result.t alloc.string.String.t serde_json.error.Error.t :=
      M.call
        (serde_json.ser.to_string
          (borrow (coq_of_rust_lib.options.Args.Get_coq_of_rust args))) in
    let* α2 : alloc.string.String.t :=
      M.call
        ((core.result.Result.t
              alloc.string.String.t
              serde_json.error.Error.t)::["unwrap"]
          α1) in
    let* α3 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["env"] (borrow_mut cmd) α0 α2) in
    M.alloc α3 in
  let* exit_status : M.Val std.process.ExitStatus.t :=
    let* α0 :
        core.result.Result.t std.process.ExitStatus.t std.io.error.Error.t :=
      M.call (std.process.Command.t::["status"] (borrow_mut cmd)) in
    let* α1 : ref str.t := M.read (mk_str "could not run cargo") in
    let* α2 : std.process.ExitStatus.t :=
      M.call
        ((core.result.Result.t
              std.process.ExitStatus.t
              std.io.error.Error.t)::["expect"]
          α0
          α1) in
    M.alloc α2 in
  let* α0 : bool.t :=
    M.call (std.process.ExitStatus.t::["success"] (borrow exit_status)) in
  let* α1 : M.Val bool.t := M.alloc (UnOp.not α0) in
  let* α2 : bool.t := M.read (use α1) in
  let* α0 : M.Val unit :=
    if α2 then
      let* α0 : core.option.Option.t i32.t :=
        M.call (std.process.ExitStatus.t::["code"] (borrow exit_status)) in
      let* α1 : i32.t :=
        M.call
          ((core.option.Option.t i32.t)::["unwrap_or"]
            α0
            ((Integer.of_Z (-1)) : i32.t)) in
      let* α2 : never.t := M.call (std.process.exit α1) in
      let* α3 : unit := never_to_any α2 in
      M.alloc α3
    else
      M.alloc tt in
  M.read α0.
