(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Definition ALLOWED_CFGS : M.Val (ref (slice (ref str.t))) :=
  M.run
    (let* α0 : ref str.t := M.read (mk_str "emscripten_new_stat_abi") in
    let* α1 : ref str.t := M.read (mk_str "freebsd10") in
    let* α2 : ref str.t := M.read (mk_str "freebsd11") in
    let* α3 : ref str.t := M.read (mk_str "freebsd12") in
    let* α4 : ref str.t := M.read (mk_str "freebsd13") in
    let* α5 : ref str.t := M.read (mk_str "freebsd14") in
    let* α6 : ref str.t := M.read (mk_str "freebsd15") in
    let* α7 : ref str.t := M.read (mk_str "libc_const_extern_fn") in
    let* α8 : ref str.t := M.read (mk_str "libc_const_extern_fn_unstable") in
    let* α9 : ref str.t := M.read (mk_str "libc_deny_warnings") in
    let* α10 : ref str.t := M.read (mk_str "libc_thread_local") in
    let* α11 : M.Val (array (ref str.t)) :=
      M.alloc [ α0; α1; α2; α3; α4; α5; α6; α7; α8; α9; α10 ] in
    M.alloc (pointer_coercion "Unsize" (borrow α11))).

Definition CHECK_CFG_EXTRA
    : M.Val (ref (slice ((ref str.t) * (ref (slice (ref str.t)))))) :=
  M.run
    (let* α0 : ref str.t := M.read (mk_str "target_os") in
    let* α1 : ref str.t := M.read (mk_str "switch") in
    let* α2 : ref str.t := M.read (mk_str "aix") in
    let* α3 : ref str.t := M.read (mk_str "ohos") in
    let* α4 : ref str.t := M.read (mk_str "hurd") in
    let* α5 : M.Val (array (ref str.t)) := M.alloc [ α1; α2; α3; α4 ] in
    let* α6 : ref str.t := M.read (mk_str "target_env") in
    let* α7 : ref str.t := M.read (mk_str "illumos") in
    let* α8 : ref str.t := M.read (mk_str "wasi") in
    let* α9 : ref str.t := M.read (mk_str "aix") in
    let* α10 : ref str.t := M.read (mk_str "ohos") in
    let* α11 : M.Val (array (ref str.t)) := M.alloc [ α7; α8; α9; α10 ] in
    let* α12 : ref str.t := M.read (mk_str "target_arch") in
    let* α13 : ref str.t := M.read (mk_str "loongarch64") in
    let* α14 : ref str.t := M.read (mk_str "mips32r6") in
    let* α15 : ref str.t := M.read (mk_str "mips64r6") in
    let* α16 : ref str.t := M.read (mk_str "csky") in
    let* α17 : M.Val (array (ref str.t)) := M.alloc [ α13; α14; α15; α16 ] in
    let* α18 : M.Val (array ((ref str.t) * (ref (slice (ref str.t))))) :=
      M.alloc
        [
          (α0, pointer_coercion "Unsize" (borrow α5));
          (α6, pointer_coercion "Unsize" (borrow α11));
          (α12, pointer_coercion "Unsize" (borrow α17))
        ] in
    M.alloc (pointer_coercion "Unsize" (borrow α18))).

(*
fn main() {
    // Avoid unnecessary re-building.
    println!("cargo:rerun-if-changed=build.rs");

    let (rustc_minor_ver, is_nightly) = rustc_minor_nightly();
    let rustc_dep_of_std = env::var("CARGO_FEATURE_RUSTC_DEP_OF_STD").is_ok();
    let libc_ci = env::var("LIBC_CI").is_ok();
    let libc_check_cfg = env::var("LIBC_CHECK_CFG").is_ok();
    let const_extern_fn_cargo_feature = env::var("CARGO_FEATURE_CONST_EXTERN_FN").is_ok();

    // The ABI of libc used by std is backward compatible with FreeBSD 12.
    // The ABI of libc from crates.io is backward compatible with FreeBSD 11.
    //
    // On CI, we detect the actual FreeBSD version and match its ABI exactly,
    // running tests to ensure that the ABI is correct.
    match which_freebsd() {
        Some(10) if libc_ci => set_cfg("freebsd10"),
        Some(11) if libc_ci => set_cfg("freebsd11"),
        Some(12) if libc_ci || rustc_dep_of_std => set_cfg("freebsd12"),
        Some(13) if libc_ci => set_cfg("freebsd13"),
        Some(14) if libc_ci => set_cfg("freebsd14"),
        Some(15) if libc_ci => set_cfg("freebsd15"),
        Some(_) | None => set_cfg("freebsd11"),
    }

    match emcc_version_code() {
        Some(v) if (v >= 30142) => set_cfg("emscripten_new_stat_abi"),
        // Non-Emscripten or version < 3.1.42.
        Some(_) | None => (),
    }

    // On CI: deny all warnings
    if libc_ci {
        set_cfg("libc_deny_warnings");
    }

    // #[thread_local] is currently unstable
    if rustc_dep_of_std {
        set_cfg("libc_thread_local");
    }

    // Rust >= 1.62.0 allows to use `const_extern_fn` for "Rust" and "C".
    if rustc_minor_ver >= 62 {
        set_cfg("libc_const_extern_fn");
    } else {
        // Rust < 1.62.0 requires a crate feature and feature gate.
        if const_extern_fn_cargo_feature {
            if !is_nightly || rustc_minor_ver < 40 {
                panic!("const-extern-fn requires a nightly compiler >= 1.40");
            }
            set_cfg("libc_const_extern_fn_unstable");
            set_cfg("libc_const_extern_fn");
        }
    }

    // check-cfg is a nightly cargo/rustc feature to warn when unknown cfgs are used across the
    // codebase. libc can configure it if the appropriate environment variable is passed. Since
    // rust-lang/rust enforces it, this is useful when using a custom libc fork there.
    //
    // https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#check-cfg
    if libc_check_cfg {
        for cfg in ALLOWED_CFGS {
            if rustc_minor_ver >= 75 {
                println!("cargo:rustc-check-cfg=cfg({})", cfg);
            } else {
                println!("cargo:rustc-check-cfg=values({})", cfg);
            }
        }
        for &(name, values) in CHECK_CFG_EXTRA {
            let values = values.join("\",\"");
            if rustc_minor_ver >= 75 {
                println!("cargo:rustc-check-cfg=cfg({},values(\"{}\"))", name, values);
            } else {
                println!("cargo:rustc-check-cfg=values({},\"{}\")", name, values);
            }
        }
    }
}
*)
Definition main : M unit :=
  let* _ : M.Val unit :=
    let* _ : M.Val unit :=
      let* α0 : ref str.t :=
        M.read (mk_str "cargo:rerun-if-changed=build.rs
") in
      let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
      let* α2 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_const"]
            (pointer_coercion "Unsize" (borrow α1))) in
      let* α3 : unit := M.call (std.io.stdio._print α2) in
      M.alloc α3 in
    M.alloc tt in
  let* α0 : u32.t * bool.t := M.call build_script_build.rustc_minor_nightly in
  let* α1 : M.Val (u32.t * bool.t) := M.alloc α0 in
  let* α0 : M.Val unit :=
    match_operator
      α1
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | (_, _) =>
            let γ0_0 := Tuple.Access.left γ in
            let γ0_1 := Tuple.Access.right γ in
            let* rustc_minor_ver := M.copy γ0_0 in
            let* is_nightly := M.copy γ0_1 in
            let* rustc_dep_of_std : M.Val bool.t :=
              let* α0 : ref str.t :=
                M.read (mk_str "CARGO_FEATURE_RUSTC_DEP_OF_STD") in
              let* α1 :
                  core.result.Result.t
                    alloc.string.String.t
                    std.env.VarError.t :=
                M.call (std.env.var α0) in
              let* α2 :
                  M.Val
                    (core.result.Result.t
                      alloc.string.String.t
                      std.env.VarError.t) :=
                M.alloc α1 in
              let* α3 : bool.t :=
                M.call
                  ((core.result.Result.t
                        alloc.string.String.t
                        std.env.VarError.t)::["is_ok"]
                    (borrow α2)) in
              M.alloc α3 in
            let* libc_ci : M.Val bool.t :=
              let* α0 : ref str.t := M.read (mk_str "LIBC_CI") in
              let* α1 :
                  core.result.Result.t
                    alloc.string.String.t
                    std.env.VarError.t :=
                M.call (std.env.var α0) in
              let* α2 :
                  M.Val
                    (core.result.Result.t
                      alloc.string.String.t
                      std.env.VarError.t) :=
                M.alloc α1 in
              let* α3 : bool.t :=
                M.call
                  ((core.result.Result.t
                        alloc.string.String.t
                        std.env.VarError.t)::["is_ok"]
                    (borrow α2)) in
              M.alloc α3 in
            let* libc_check_cfg : M.Val bool.t :=
              let* α0 : ref str.t := M.read (mk_str "LIBC_CHECK_CFG") in
              let* α1 :
                  core.result.Result.t
                    alloc.string.String.t
                    std.env.VarError.t :=
                M.call (std.env.var α0) in
              let* α2 :
                  M.Val
                    (core.result.Result.t
                      alloc.string.String.t
                      std.env.VarError.t) :=
                M.alloc α1 in
              let* α3 : bool.t :=
                M.call
                  ((core.result.Result.t
                        alloc.string.String.t
                        std.env.VarError.t)::["is_ok"]
                    (borrow α2)) in
              M.alloc α3 in
            let* const_extern_fn_cargo_feature : M.Val bool.t :=
              let* α0 : ref str.t :=
                M.read (mk_str "CARGO_FEATURE_CONST_EXTERN_FN") in
              let* α1 :
                  core.result.Result.t
                    alloc.string.String.t
                    std.env.VarError.t :=
                M.call (std.env.var α0) in
              let* α2 :
                  M.Val
                    (core.result.Result.t
                      alloc.string.String.t
                      std.env.VarError.t) :=
                M.alloc α1 in
              let* α3 : bool.t :=
                M.call
                  ((core.result.Result.t
                        alloc.string.String.t
                        std.env.VarError.t)::["is_ok"]
                    (borrow α2)) in
              M.alloc α3 in
            let* _ : M.Val unit :=
              let* α0 : core.option.Option.t i32.t :=
                M.call build_script_build.which_freebsd in
              let* α1 : M.Val (core.option.Option.t i32.t) := M.alloc α0 in
              match_operator
                α1
                [
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd10") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd11") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd12") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd13") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd14") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd15") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* α0 : ref str.t := M.read (mk_str "freebsd11") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.None =>
                      let* α0 : ref str.t := M.read (mk_str "freebsd11") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit)
                ] in
            let* _ : M.Val unit :=
              let* α0 : core.option.Option.t u64.t :=
                M.call build_script_build.emcc_version_code in
              let* α1 : M.Val (core.option.Option.t u64.t) := M.alloc α0 in
              match_operator
                α1
                [
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      let* v := M.copy γ0_0 in
                      let* α0 : ref str.t :=
                        M.read (mk_str "emscripten_new_stat_abi") in
                      let* α1 : unit :=
                        M.call (build_script_build.set_cfg α0) in
                      M.alloc α1
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.Some _ =>
                      let γ0_0 := core.option.Option.Get_Some_0 γ in
                      M.alloc tt
                    | _ => M.break_match
                    end) :
                    M (M.Val unit);
                  fun γ =>
                    (let* α0 := M.read γ in
                    match α0 with
                    | core.option.Option.None => M.alloc tt
                    | _ => M.break_match
                    end) :
                    M (M.Val unit)
                ] in
            let* _ : M.Val unit :=
              let* α0 : bool.t := M.read (use libc_ci) in
              if α0 then
                let* _ : M.Val unit :=
                  let* α0 : ref str.t := M.read (mk_str "libc_deny_warnings") in
                  let* α1 : unit := M.call (build_script_build.set_cfg α0) in
                  M.alloc α1 in
                M.alloc tt
              else
                M.alloc tt in
            let* _ : M.Val unit :=
              let* α0 : bool.t := M.read (use rustc_dep_of_std) in
              if α0 then
                let* _ : M.Val unit :=
                  let* α0 : ref str.t := M.read (mk_str "libc_thread_local") in
                  let* α1 : unit := M.call (build_script_build.set_cfg α0) in
                  M.alloc α1 in
                M.alloc tt
              else
                M.alloc tt in
            let* _ : M.Val unit :=
              let* α0 : u32.t := M.read rustc_minor_ver in
              let* α1 : M.Val bool.t :=
                M.alloc (BinOp.Pure.ge α0 ((Integer.of_Z 62) : u32.t)) in
              let* α2 : bool.t := M.read (use α1) in
              if α2 then
                let* _ : M.Val unit :=
                  let* α0 : ref str.t :=
                    M.read (mk_str "libc_const_extern_fn") in
                  let* α1 : unit := M.call (build_script_build.set_cfg α0) in
                  M.alloc α1 in
                M.alloc tt
              else
                let* α0 : bool.t :=
                  M.read (use const_extern_fn_cargo_feature) in
                if α0 then
                  let* _ : M.Val unit :=
                    let* α0 : bool.t := M.read is_nightly in
                    let* α1 : u32.t := M.read rustc_minor_ver in
                    let* α2 : M.Val bool.t :=
                      M.alloc
                        (BinOp.Pure.or
                          (UnOp.not α0)
                          (BinOp.Pure.lt α1 ((Integer.of_Z 40) : u32.t))) in
                    let* α3 : bool.t := M.read (use α2) in
                    if α3 then
                      let* α0 : ref str.t :=
                        M.read
                          (mk_str
                            "const-extern-fn requires a nightly compiler >= 1.40") in
                      let* α1 : never.t :=
                        M.call (std.panicking.begin_panic α0) in
                      let* α2 : unit := never_to_any α1 in
                      M.alloc α2
                    else
                      M.alloc tt in
                  let* _ : M.Val unit :=
                    let* α0 : ref str.t :=
                      M.read (mk_str "libc_const_extern_fn_unstable") in
                    let* α1 : unit := M.call (build_script_build.set_cfg α0) in
                    M.alloc α1 in
                  let* _ : M.Val unit :=
                    let* α0 : ref str.t :=
                      M.read (mk_str "libc_const_extern_fn") in
                    let* α1 : unit := M.call (build_script_build.set_cfg α0) in
                    M.alloc α1 in
                  M.alloc tt
                else
                  M.alloc tt in
            let* α0 : bool.t := M.read (use libc_check_cfg) in
            if α0 then
              let* _ : M.Val unit :=
                let* α0 : (ref (slice (ref str.t))) -> M _ :=
                  ltac:(M.get_method (fun ℐ =>
                    core.iter.traits.collect.IntoIterator.into_iter
                      (Self := ref (slice (ref str.t)))
                      (Trait := ℐ))) in
                let* α1 : ref (slice (ref str.t)) :=
                  M.read build_script_build.ALLOWED_CFGS in
                let* α2 : core.slice.iter.Iter.t (ref str.t) :=
                  M.call (α0 α1) in
                let* α3 : M.Val (core.slice.iter.Iter.t (ref str.t)) :=
                  M.alloc α2 in
                let* α4 : M.Val unit :=
                  match_operator
                    α3
                    [
                      fun γ =>
                        (let* iter := M.copy γ in
                        M.loop
                          (let* _ : M.Val unit :=
                            let* α0 :
                                (mut_ref (core.slice.iter.Iter.t (ref str.t)))
                                  ->
                                  M (core.option.Option.t _) :=
                              ltac:(M.get_method (fun ℐ =>
                                core.iter.traits.iterator.Iterator.next
                                  (Self := core.slice.iter.Iter.t (ref str.t))
                                  (Trait := ℐ))) in
                            let* α1 : core.option.Option.t (ref (ref str.t)) :=
                              M.call (α0 (borrow_mut iter)) in
                            let* α2 :
                                M.Val
                                  (core.option.Option.t (ref (ref str.t))) :=
                              M.alloc α1 in
                            match_operator
                              α2
                              [
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.option.Option.None =>
                                    let* α0 : M.Val never.t := M.break in
                                    let* α1 := M.read α0 in
                                    let* α2 : unit := never_to_any α1 in
                                    M.alloc α2
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit);
                                fun γ =>
                                  (let* α0 := M.read γ in
                                  match α0 with
                                  | core.option.Option.Some _ =>
                                    let γ0_0 :=
                                      core.option.Option.Get_Some_0 γ in
                                    let* cfg := M.copy γ0_0 in
                                    let* α0 : u32.t := M.read rustc_minor_ver in
                                    let* α1 : M.Val bool.t :=
                                      M.alloc
                                        (BinOp.Pure.ge
                                          α0
                                          ((Integer.of_Z 75) : u32.t)) in
                                    let* α2 : bool.t := M.read (use α1) in
                                    if α2 then
                                      let* _ : M.Val unit :=
                                        let* _ : M.Val unit :=
                                          let* α0 : ref str.t :=
                                            M.read
                                              (mk_str
                                                "cargo:rustc-check-cfg=cfg(") in
                                          let* α1 : ref str.t :=
                                            M.read (mk_str ")
") in
                                          let* α2 : M.Val (array (ref str.t)) :=
                                            M.alloc [ α0; α1 ] in
                                          let* α3 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow cfg)) in
                                          let* α4 :
                                              M.Val
                                                (array
                                                  core.fmt.rt.Argument.t) :=
                                            M.alloc [ α3 ] in
                                          let* α5 : core.fmt.Arguments.t :=
                                            M.call
                                              (core.fmt.Arguments.t::["new_v1"]
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α2))
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α4))) in
                                          let* α6 : unit :=
                                            M.call (std.io.stdio._print α5) in
                                          M.alloc α6 in
                                        M.alloc tt in
                                      M.alloc tt
                                    else
                                      let* _ : M.Val unit :=
                                        let* _ : M.Val unit :=
                                          let* α0 : ref str.t :=
                                            M.read
                                              (mk_str
                                                "cargo:rustc-check-cfg=values(") in
                                          let* α1 : ref str.t :=
                                            M.read (mk_str ")
") in
                                          let* α2 : M.Val (array (ref str.t)) :=
                                            M.alloc [ α0; α1 ] in
                                          let* α3 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow cfg)) in
                                          let* α4 :
                                              M.Val
                                                (array
                                                  core.fmt.rt.Argument.t) :=
                                            M.alloc [ α3 ] in
                                          let* α5 : core.fmt.Arguments.t :=
                                            M.call
                                              (core.fmt.Arguments.t::["new_v1"]
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α2))
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α4))) in
                                          let* α6 : unit :=
                                            M.call (std.io.stdio._print α5) in
                                          M.alloc α6 in
                                        M.alloc tt in
                                      M.alloc tt
                                  | _ => M.break_match
                                  end) :
                                  M (M.Val unit)
                              ] in
                          M.alloc tt)) :
                        M (M.Val unit)
                    ] in
                M.pure (use α4) in
              let* α0 :
                  (ref (slice ((ref str.t) * (ref (slice (ref str.t)))))) ->
                    M _ :=
                ltac:(M.get_method (fun ℐ =>
                  core.iter.traits.collect.IntoIterator.into_iter
                    (Self :=
                      ref (slice ((ref str.t) * (ref (slice (ref str.t))))))
                    (Trait := ℐ))) in
              let* α1 : ref (slice ((ref str.t) * (ref (slice (ref str.t))))) :=
                M.read build_script_build.CHECK_CFG_EXTRA in
              let* α2 :
                  core.slice.iter.Iter.t
                    ((ref str.t) * (ref (slice (ref str.t)))) :=
                M.call (α0 α1) in
              let* α3 :
                  M.Val
                    (core.slice.iter.Iter.t
                      ((ref str.t) * (ref (slice (ref str.t))))) :=
                M.alloc α2 in
              let* α4 : M.Val unit :=
                match_operator
                  α3
                  [
                    fun γ =>
                      (let* iter := M.copy γ in
                      M.loop
                        (let* _ : M.Val unit :=
                          let* α0 :
                              (mut_ref
                                  (core.slice.iter.Iter.t
                                    ((ref str.t) * (ref (slice (ref str.t))))))
                                ->
                                M (core.option.Option.t _) :=
                            ltac:(M.get_method (fun ℐ =>
                              core.iter.traits.iterator.Iterator.next
                                (Self :=
                                  core.slice.iter.Iter.t
                                    ((ref str.t) * (ref (slice (ref str.t)))))
                                (Trait := ℐ))) in
                          let* α1 :
                              core.option.Option.t
                                (ref
                                  ((ref str.t) * (ref (slice (ref str.t))))) :=
                            M.call (α0 (borrow_mut iter)) in
                          let* α2 :
                              M.Val
                                (core.option.Option.t
                                  (ref
                                    ((ref str.t)
                                    *
                                    (ref (slice (ref str.t)))))) :=
                            M.alloc α1 in
                          match_operator
                            α2
                            [
                              fun γ =>
                                (let* α0 := M.read γ in
                                match α0 with
                                | core.option.Option.None =>
                                  let* α0 : M.Val never.t := M.break in
                                  let* α1 := M.read α0 in
                                  let* α2 : unit := never_to_any α1 in
                                  M.alloc α2
                                | _ => M.break_match
                                end) :
                                M (M.Val unit);
                              fun γ =>
                                (let* α0 := M.read γ in
                                match α0 with
                                | core.option.Option.Some _ =>
                                  let γ0_0 := core.option.Option.Get_Some_0 γ in
                                  let* γ0_0 :=
                                    let* α0 := M.read γ0_0 in
                                    M.pure (deref α0) in
                                  let* α0 := M.read γ0_0 in
                                  match α0 with
                                  | (_, _) =>
                                    let γ2_0 := Tuple.Access.left γ0_0 in
                                    let γ2_1 := Tuple.Access.right γ0_0 in
                                    let* name := M.copy γ2_0 in
                                    let* values := M.copy γ2_1 in
                                    let* values : M.Val alloc.string.String.t :=
                                      let* α0 : ref (slice (ref str.t)) :=
                                        M.read values in
                                      let* α1 : ref str.t :=
                                        M.read (mk_str """,""") in
                                      let* α2 : alloc.string.String.t :=
                                        M.call
                                          ((slice (ref str.t))::["join"]
                                            α0
                                            α1) in
                                      M.alloc α2 in
                                    let* α0 : u32.t := M.read rustc_minor_ver in
                                    let* α1 : M.Val bool.t :=
                                      M.alloc
                                        (BinOp.Pure.ge
                                          α0
                                          ((Integer.of_Z 75) : u32.t)) in
                                    let* α2 : bool.t := M.read (use α1) in
                                    if α2 then
                                      let* _ : M.Val unit :=
                                        let* _ : M.Val unit :=
                                          let* α0 : ref str.t :=
                                            M.read
                                              (mk_str
                                                "cargo:rustc-check-cfg=cfg(") in
                                          let* α1 : ref str.t :=
                                            M.read (mk_str ",values(""") in
                                          let* α2 : ref str.t :=
                                            M.read (mk_str """))
") in
                                          let* α3 : M.Val (array (ref str.t)) :=
                                            M.alloc [ α0; α1; α2 ] in
                                          let* α4 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow name)) in
                                          let* α5 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow values)) in
                                          let* α6 :
                                              M.Val
                                                (array
                                                  core.fmt.rt.Argument.t) :=
                                            M.alloc [ α4; α5 ] in
                                          let* α7 : core.fmt.Arguments.t :=
                                            M.call
                                              (core.fmt.Arguments.t::["new_v1"]
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α3))
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α6))) in
                                          let* α8 : unit :=
                                            M.call (std.io.stdio._print α7) in
                                          M.alloc α8 in
                                        M.alloc tt in
                                      M.alloc tt
                                    else
                                      let* _ : M.Val unit :=
                                        let* _ : M.Val unit :=
                                          let* α0 : ref str.t :=
                                            M.read
                                              (mk_str
                                                "cargo:rustc-check-cfg=values(") in
                                          let* α1 : ref str.t :=
                                            M.read (mk_str ",""") in
                                          let* α2 : ref str.t :=
                                            M.read (mk_str """)
") in
                                          let* α3 : M.Val (array (ref str.t)) :=
                                            M.alloc [ α0; α1; α2 ] in
                                          let* α4 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow name)) in
                                          let* α5 : core.fmt.rt.Argument.t :=
                                            M.call
                                              (core.fmt.rt.Argument.t::["new_display"]
                                                (borrow values)) in
                                          let* α6 :
                                              M.Val
                                                (array
                                                  core.fmt.rt.Argument.t) :=
                                            M.alloc [ α4; α5 ] in
                                          let* α7 : core.fmt.Arguments.t :=
                                            M.call
                                              (core.fmt.Arguments.t::["new_v1"]
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α3))
                                                (pointer_coercion
                                                  "Unsize"
                                                  (borrow α6))) in
                                          let* α8 : unit :=
                                            M.call (std.io.stdio._print α7) in
                                          M.alloc α8 in
                                        M.alloc tt in
                                      M.alloc tt
                                  end
                                | _ => M.break_match
                                end) :
                                M (M.Val unit)
                            ] in
                        M.alloc tt)) :
                      M (M.Val unit)
                  ] in
              M.pure (use α4)
            else
              M.alloc tt
          end) :
          M (M.Val unit)
      ] in
  M.read α0.

(*
fn rustc_minor_nightly() -> (u32, bool) {
    macro_rules! otry {
        ($e:expr) => {
            match $e {
                Some(e) => e,
                None => panic!("Failed to get rustc version"),
            }
        };
    }

    let rustc = otry!(env::var_os("RUSTC"));
    let output = Command::new(rustc)
        .arg("--version")
        .output()
        .ok()
        .expect("Failed to get rustc version");
    if !output.status.success() {
        panic!(
            "failed to run rustc: {}",
            String::from_utf8_lossy(output.stderr.as_slice())
        );
    }

    let version = otry!(str::from_utf8(&output.stdout).ok());
    let mut pieces = version.split('.');

    if pieces.next() != Some("rustc 1") {
        panic!("Failed to get rustc version");
    }

    let minor = pieces.next();

    // If `rustc` was built from a tarball, its version string
    // will have neither a git hash nor a commit date
    // (e.g. "rustc 1.39.0"). Treat this case as non-nightly,
    // since a nightly build should either come from CI
    // or a git checkout
    let nightly_raw = otry!(pieces.next()).split('-').nth(1);
    let nightly = nightly_raw
        .map(|raw| raw.starts_with("dev") || raw.starts_with("nightly"))
        .unwrap_or(false);
    let minor = otry!(otry!(minor).parse().ok());

    (minor, nightly)
}
*)
Definition rustc_minor_nightly : M (u32.t * bool.t) :=
  let* rustc : M.Val std.ffi.os_str.OsString.t :=
    let* α0 : ref str.t := M.read (mk_str "RUSTC") in
    let* α1 : core.option.Option.t std.ffi.os_str.OsString.t :=
      M.call (std.env.var_os α0) in
    let* α2 : M.Val (core.option.Option.t std.ffi.os_str.OsString.t) :=
      M.alloc α1 in
    let* α3 : M.Val std.ffi.os_str.OsString.t :=
      match_operator
        α2
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.Some _ =>
              let γ0_0 := core.option.Option.Get_Some_0 γ in
              let* e := M.copy γ0_0 in
              M.pure e
            | _ => M.break_match
            end) :
            M (M.Val std.ffi.os_str.OsString.t);
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.None =>
              let* α0 : ref str.t :=
                M.read (mk_str "Failed to get rustc version") in
              let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
              let* α2 : std.ffi.os_str.OsString.t := never_to_any α1 in
              M.alloc α2
            | _ => M.break_match
            end) :
            M (M.Val std.ffi.os_str.OsString.t)
        ] in
    M.copy α3 in
  let* output : M.Val std.process.Output.t :=
    let* α0 : std.ffi.os_str.OsString.t := M.read rustc in
    let* α1 : std.process.Command.t :=
      M.call (std.process.Command.t::["new"] α0) in
    let* α2 : M.Val std.process.Command.t := M.alloc α1 in
    let* α3 : ref str.t := M.read (mk_str "--version") in
    let* α4 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] (borrow_mut α2) α3) in
    let* α5 : core.result.Result.t std.process.Output.t std.io.error.Error.t :=
      M.call (std.process.Command.t::["output"] α4) in
    let* α6 : core.option.Option.t std.process.Output.t :=
      M.call
        ((core.result.Result.t
              std.process.Output.t
              std.io.error.Error.t)::["ok"]
          α5) in
    let* α7 : ref str.t := M.read (mk_str "Failed to get rustc version") in
    let* α8 : std.process.Output.t :=
      M.call ((core.option.Option.t std.process.Output.t)::["expect"] α6 α7) in
    M.alloc α8 in
  let* _ : M.Val unit :=
    let* α0 : bool.t :=
      M.call
        (std.process.ExitStatus.t::["success"]
          (borrow (std.process.Output.Get_status output))) in
    let* α1 : M.Val bool.t := M.alloc (UnOp.not α0) in
    let* α2 : bool.t := M.read (use α1) in
    if α2 then
      let* α0 : ref str.t := M.read (mk_str "failed to run rustc: ") in
      let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
      let* α2 : ref (slice u8.t) :=
        M.call
          ((alloc.vec.Vec.t u8.t alloc.alloc.Global.t)::["as_slice"]
            (borrow (std.process.Output.Get_stderr output))) in
      let* α3 : alloc.borrow.Cow.t str.t :=
        M.call (alloc.string.String.t::["from_utf8_lossy"] α2) in
      let* α4 : M.Val (alloc.borrow.Cow.t str.t) := M.alloc α3 in
      let* α5 : core.fmt.rt.Argument.t :=
        M.call (core.fmt.rt.Argument.t::["new_display"] (borrow α4)) in
      let* α6 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α5 ] in
      let* α7 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_v1"]
            (pointer_coercion "Unsize" (borrow α1))
            (pointer_coercion "Unsize" (borrow α6))) in
      let* α8 : never.t := M.call (core.panicking.panic_fmt α7) in
      let* α9 : unit := never_to_any α8 in
      M.alloc α9
    else
      M.alloc tt in
  let* version : M.Val (ref str.t) :=
    let* α0 : (ref (alloc.vec.Vec.t u8.t alloc.alloc.Global.t)) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.deref.Deref.deref
          (Self := alloc.vec.Vec.t u8.t alloc.alloc.Global.t)
          (Trait := ℐ))) in
    let* α1 : ref (slice u8.t) :=
      M.call (α0 (borrow (std.process.Output.Get_stdout output))) in
    let* α2 : core.result.Result.t (ref str.t) core.str.error.Utf8Error.t :=
      M.call (core.str.converts.from_utf8 α1) in
    let* α3 : core.option.Option.t (ref str.t) :=
      M.call
        ((core.result.Result.t (ref str.t) core.str.error.Utf8Error.t)::["ok"]
          α2) in
    let* α4 : M.Val (core.option.Option.t (ref str.t)) := M.alloc α3 in
    let* α5 : M.Val (ref str.t) :=
      match_operator
        α4
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.Some _ =>
              let γ0_0 := core.option.Option.Get_Some_0 γ in
              let* e := M.copy γ0_0 in
              M.pure e
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.None =>
              let* α0 : ref str.t :=
                M.read (mk_str "Failed to get rustc version") in
              let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
              let* α2 : ref str.t := never_to_any α1 in
              M.alloc α2
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t))
        ] in
    M.copy α5 in
  let* pieces : M.Val (core.str.iter.Split.t char.t) :=
    let* α0 : ref str.t := M.read version in
    let* α1 : core.str.iter.Split.t char.t :=
      M.call (str.t::["split"] α0 "."%char) in
    M.alloc α1 in
  let* _ : M.Val unit :=
    let* α0 :
        (ref (core.option.Option.t (ref str.t))) ->
          (ref (core.option.Option.t (ref str.t))) ->
          M bool.t :=
      ltac:(M.get_method (fun ℐ =>
        core.cmp.PartialEq.ne
          (Self := core.option.Option.t (ref str.t))
          (Rhs := core.option.Option.t (ref str.t))
          (Trait := ℐ))) in
    let* α1 :
        (mut_ref (core.str.iter.Split.t char.t)) ->
          M (core.option.Option.t _) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.next
          (Self := core.str.iter.Split.t char.t)
          (Trait := ℐ))) in
    let* α2 : core.option.Option.t (ref str.t) :=
      M.call (α1 (borrow_mut pieces)) in
    let* α3 : M.Val (core.option.Option.t (ref str.t)) := M.alloc α2 in
    let* α4 : ref str.t := M.read (mk_str "rustc 1") in
    let* α5 : M.Val (core.option.Option.t (ref str.t)) :=
      M.alloc (core.option.Option.Some α4) in
    let* α6 : bool.t := M.call (α0 (borrow α3) (borrow α5)) in
    let* α7 : M.Val bool.t := M.alloc α6 in
    let* α8 : bool.t := M.read (use α7) in
    if α8 then
      let* α0 : ref str.t := M.read (mk_str "Failed to get rustc version") in
      let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
      let* α2 : unit := never_to_any α1 in
      M.alloc α2
    else
      M.alloc tt in
  let* minor : M.Val (core.option.Option.t (ref str.t)) :=
    let* α0 :
        (mut_ref (core.str.iter.Split.t char.t)) ->
          M (core.option.Option.t _) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.next
          (Self := core.str.iter.Split.t char.t)
          (Trait := ℐ))) in
    let* α1 : core.option.Option.t (ref str.t) :=
      M.call (α0 (borrow_mut pieces)) in
    M.alloc α1 in
  let* nightly_raw : M.Val (core.option.Option.t (ref str.t)) :=
    let* α0 :
        (mut_ref (core.str.iter.Split.t char.t)) ->
          usize.t ->
          M (core.option.Option.t _) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.nth
          (Self := core.str.iter.Split.t char.t)
          (Trait := ℐ))) in
    let* α1 :
        (mut_ref (core.str.iter.Split.t char.t)) ->
          M (core.option.Option.t _) :=
      ltac:(M.get_method (fun ℐ =>
        core.iter.traits.iterator.Iterator.next
          (Self := core.str.iter.Split.t char.t)
          (Trait := ℐ))) in
    let* α2 : core.option.Option.t (ref str.t) :=
      M.call (α1 (borrow_mut pieces)) in
    let* α3 : M.Val (core.option.Option.t (ref str.t)) := M.alloc α2 in
    let* α4 : M.Val (ref str.t) :=
      match_operator
        α3
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.Some _ =>
              let γ0_0 := core.option.Option.Get_Some_0 γ in
              let* e := M.copy γ0_0 in
              M.pure e
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.None =>
              let* α0 : ref str.t :=
                M.read (mk_str "Failed to get rustc version") in
              let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
              let* α2 : ref str.t := never_to_any α1 in
              M.alloc α2
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t))
        ] in
    let* α5 : ref str.t := M.read α4 in
    let* α6 : core.str.iter.Split.t char.t :=
      M.call (str.t::["split"] α5 "-"%char) in
    let* α7 : M.Val (core.str.iter.Split.t char.t) := M.alloc α6 in
    let* α8 : core.option.Option.t (ref str.t) :=
      M.call (α0 (borrow_mut α7) ((Integer.of_Z 1) : usize.t)) in
    M.alloc α8 in
  let* nightly : M.Val bool.t :=
    let* α0 : core.option.Option.t (ref str.t) := M.read nightly_raw in
    let* α1 : core.option.Option.t bool.t :=
      M.call
        ((core.option.Option.t (ref str.t))::["map"]
          α0
          (fun (α0 : ref str.t) =>
            (let* α0 := M.alloc α0 in
            match_operator
              α0
              [
                fun γ =>
                  (let* raw := M.copy γ in
                  let* α0 : ref str.t := M.read raw in
                  let* α1 : ref str.t := M.read (mk_str "dev") in
                  let* α2 : bool.t := M.call (str.t::["starts_with"] α0 α1) in
                  let* α3 : ref str.t := M.read raw in
                  let* α4 : ref str.t := M.read (mk_str "nightly") in
                  let* α5 : bool.t := M.call (str.t::["starts_with"] α3 α4) in
                  M.pure (BinOp.Pure.or α2 α5)) :
                  M bool.t
              ]) :
            M bool.t)) in
    let* α2 : bool.t :=
      M.call ((core.option.Option.t bool.t)::["unwrap_or"] α1 false) in
    M.alloc α2 in
  let* minor : M.Val u32.t :=
    let* α0 : M.Val (ref str.t) :=
      match_operator
        minor
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.Some _ =>
              let γ0_0 := core.option.Option.Get_Some_0 γ in
              let* e := M.copy γ0_0 in
              M.pure e
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t));
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.None =>
              let* α0 : ref str.t :=
                M.read (mk_str "Failed to get rustc version") in
              let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
              let* α2 : ref str.t := never_to_any α1 in
              M.alloc α2
            | _ => M.break_match
            end) :
            M (M.Val (ref str.t))
        ] in
    let* α1 : ref str.t := M.read α0 in
    let* α2 : core.result.Result.t u32.t core.num.error.ParseIntError.t :=
      M.call (str.t::["parse"] α1) in
    let* α3 : core.option.Option.t u32.t :=
      M.call
        ((core.result.Result.t u32.t core.num.error.ParseIntError.t)::["ok"]
          α2) in
    let* α4 : M.Val (core.option.Option.t u32.t) := M.alloc α3 in
    let* α5 : M.Val u32.t :=
      match_operator
        α4
        [
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.Some _ =>
              let γ0_0 := core.option.Option.Get_Some_0 γ in
              let* e := M.copy γ0_0 in
              M.pure e
            | _ => M.break_match
            end) :
            M (M.Val u32.t);
          fun γ =>
            (let* α0 := M.read γ in
            match α0 with
            | core.option.Option.None =>
              let* α0 : ref str.t :=
                M.read (mk_str "Failed to get rustc version") in
              let* α1 : never.t := M.call (std.panicking.begin_panic α0) in
              let* α2 : u32.t := never_to_any α1 in
              M.alloc α2
            | _ => M.break_match
            end) :
            M (M.Val u32.t)
        ] in
    M.copy α5 in
  let* α0 : u32.t := M.read minor in
  let* α1 : bool.t := M.read nightly in
  let* α0 : M.Val (u32.t * bool.t) := M.alloc (α0, α1) in
  M.read α0.

(*
fn which_freebsd() -> Option<i32> {
    let output = std::process::Command::new("freebsd-version")
        .output()
        .ok()?;
    if !output.status.success() {
        return None;
    }

    let stdout = String::from_utf8(output.stdout).ok()?;

    match &stdout {
        s if s.starts_with("10") => Some(10),
        s if s.starts_with("11") => Some(11),
        s if s.starts_with("12") => Some(12),
        s if s.starts_with("13") => Some(13),
        s if s.starts_with("14") => Some(14),
        s if s.starts_with("15") => Some(15),
        _ => None,
    }
}
*)
Definition which_freebsd : M (core.option.Option.t i32.t) :=
  let return_ := M.return_ (R := core.option.Option.t i32.t) in
  M.catch_return
    (let* output : M.Val std.process.Output.t :=
      let* α0 :
          (core.option.Option.t std.process.Output.t) ->
            M (core.ops.control_flow.ControlFlow.t _ _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.try_trait.Try.branch
            (Self := core.option.Option.t std.process.Output.t)
            (Trait := ℐ))) in
      let* α1 : ref str.t := M.read (mk_str "freebsd-version") in
      let* α2 : std.process.Command.t :=
        M.call (std.process.Command.t::["new"] α1) in
      let* α3 : M.Val std.process.Command.t := M.alloc α2 in
      let* α4 :
          core.result.Result.t std.process.Output.t std.io.error.Error.t :=
        M.call (std.process.Command.t::["output"] (borrow_mut α3)) in
      let* α5 : core.option.Option.t std.process.Output.t :=
        M.call
          ((core.result.Result.t
                std.process.Output.t
                std.io.error.Error.t)::["ok"]
            α4) in
      let* α6 :
          core.ops.control_flow.ControlFlow.t
            (core.option.Option.t core.convert.Infallible.t)
            std.process.Output.t :=
        M.call (α0 α5) in
      let* α7 :
          M.Val
            (core.ops.control_flow.ControlFlow.t
              (core.option.Option.t core.convert.Infallible.t)
              std.process.Output.t) :=
        M.alloc α6 in
      let* α8 : M.Val std.process.Output.t :=
        match_operator
          α7
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.option.Option.t core.convert.Infallible.t) ->
                      M (core.option.Option.t i32.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.option.Option.t i32.t)
                      (R := core.option.Option.t core.convert.Infallible.t)
                      (Trait := ℐ))) in
                let* α1 : core.option.Option.t core.convert.Infallible.t :=
                  M.read residual in
                let* α2 : core.option.Option.t i32.t := M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : std.process.Output.t := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val std.process.Output.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val std.process.Output.t)
          ] in
      M.copy α8 in
    let* _ : M.Val unit :=
      let* α0 : bool.t :=
        M.call
          (std.process.ExitStatus.t::["success"]
            (borrow (std.process.Output.Get_status output))) in
      let* α1 : M.Val bool.t := M.alloc (UnOp.not α0) in
      let* α2 : bool.t := M.read (use α1) in
      if α2 then
        let* α0 : M.Val never.t := return_ core.option.Option.None in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* stdout : M.Val alloc.string.String.t :=
      let* α0 :
          (core.option.Option.t alloc.string.String.t) ->
            M (core.ops.control_flow.ControlFlow.t _ _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.try_trait.Try.branch
            (Self := core.option.Option.t alloc.string.String.t)
            (Trait := ℐ))) in
      let* α1 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
        M.read (std.process.Output.Get_stdout output) in
      let* α2 :
          core.result.Result.t
            alloc.string.String.t
            alloc.string.FromUtf8Error.t :=
        M.call (alloc.string.String.t::["from_utf8"] α1) in
      let* α3 : core.option.Option.t alloc.string.String.t :=
        M.call
          ((core.result.Result.t
                alloc.string.String.t
                alloc.string.FromUtf8Error.t)::["ok"]
            α2) in
      let* α4 :
          core.ops.control_flow.ControlFlow.t
            (core.option.Option.t core.convert.Infallible.t)
            alloc.string.String.t :=
        M.call (α0 α3) in
      let* α5 :
          M.Val
            (core.ops.control_flow.ControlFlow.t
              (core.option.Option.t core.convert.Infallible.t)
              alloc.string.String.t) :=
        M.alloc α4 in
      let* α6 : M.Val alloc.string.String.t :=
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.option.Option.t core.convert.Infallible.t) ->
                      M (core.option.Option.t i32.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.option.Option.t i32.t)
                      (R := core.option.Option.t core.convert.Infallible.t)
                      (Trait := ℐ))) in
                let* α1 : core.option.Option.t core.convert.Infallible.t :=
                  M.read residual in
                let* α2 : core.option.Option.t i32.t := M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : alloc.string.String.t := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val alloc.string.String.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val alloc.string.String.t)
          ] in
      M.copy α6 in
    let* α0 : M.Val (ref alloc.string.String.t) := M.alloc (borrow stdout) in
    let* α0 : M.Val (core.option.Option.t i32.t) :=
      match_operator
        α0
        [
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 10) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 11) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 12) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 13) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 14) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (let* s := M.copy γ in
            M.alloc (core.option.Option.Some ((Integer.of_Z 15) : i32.t))) :
            M (M.Val (core.option.Option.t i32.t));
          fun γ =>
            (M.alloc core.option.Option.None) :
            M (M.Val (core.option.Option.t i32.t))
        ] in
    M.read α0).

(*
fn emcc_version_code() -> Option<u64> {
    let output = std::process::Command::new("emcc")
        .arg("-dumpversion")
        .output()
        .ok()?;
    if !output.status.success() {
        return None;
    }

    let version = String::from_utf8(output.stdout).ok()?;

    // Some Emscripten versions come with `-git` attached, so split the
    // version string also on the `-` char.
    let mut pieces = version.trim().split(|c| c == '.' || c == '-');

    let major = pieces.next().and_then(|x| x.parse().ok()).unwrap_or(0);
    let minor = pieces.next().and_then(|x| x.parse().ok()).unwrap_or(0);
    let patch = pieces.next().and_then(|x| x.parse().ok()).unwrap_or(0);

    Some(major * 10000 + minor * 100 + patch)
}
*)
Definition emcc_version_code : M (core.option.Option.t u64.t) :=
  let return_ := M.return_ (R := core.option.Option.t u64.t) in
  M.catch_return
    (let* output : M.Val std.process.Output.t :=
      let* α0 :
          (core.option.Option.t std.process.Output.t) ->
            M (core.ops.control_flow.ControlFlow.t _ _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.try_trait.Try.branch
            (Self := core.option.Option.t std.process.Output.t)
            (Trait := ℐ))) in
      let* α1 : ref str.t := M.read (mk_str "emcc") in
      let* α2 : std.process.Command.t :=
        M.call (std.process.Command.t::["new"] α1) in
      let* α3 : M.Val std.process.Command.t := M.alloc α2 in
      let* α4 : ref str.t := M.read (mk_str "-dumpversion") in
      let* α5 : mut_ref std.process.Command.t :=
        M.call (std.process.Command.t::["arg"] (borrow_mut α3) α4) in
      let* α6 :
          core.result.Result.t std.process.Output.t std.io.error.Error.t :=
        M.call (std.process.Command.t::["output"] α5) in
      let* α7 : core.option.Option.t std.process.Output.t :=
        M.call
          ((core.result.Result.t
                std.process.Output.t
                std.io.error.Error.t)::["ok"]
            α6) in
      let* α8 :
          core.ops.control_flow.ControlFlow.t
            (core.option.Option.t core.convert.Infallible.t)
            std.process.Output.t :=
        M.call (α0 α7) in
      let* α9 :
          M.Val
            (core.ops.control_flow.ControlFlow.t
              (core.option.Option.t core.convert.Infallible.t)
              std.process.Output.t) :=
        M.alloc α8 in
      let* α10 : M.Val std.process.Output.t :=
        match_operator
          α9
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.option.Option.t core.convert.Infallible.t) ->
                      M (core.option.Option.t u64.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.option.Option.t u64.t)
                      (R := core.option.Option.t core.convert.Infallible.t)
                      (Trait := ℐ))) in
                let* α1 : core.option.Option.t core.convert.Infallible.t :=
                  M.read residual in
                let* α2 : core.option.Option.t u64.t := M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : std.process.Output.t := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val std.process.Output.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val std.process.Output.t)
          ] in
      M.copy α10 in
    let* _ : M.Val unit :=
      let* α0 : bool.t :=
        M.call
          (std.process.ExitStatus.t::["success"]
            (borrow (std.process.Output.Get_status output))) in
      let* α1 : M.Val bool.t := M.alloc (UnOp.not α0) in
      let* α2 : bool.t := M.read (use α1) in
      if α2 then
        let* α0 : M.Val never.t := return_ core.option.Option.None in
        let* α1 := M.read α0 in
        let* α2 : unit := never_to_any α1 in
        M.alloc α2
      else
        M.alloc tt in
    let* version : M.Val alloc.string.String.t :=
      let* α0 :
          (core.option.Option.t alloc.string.String.t) ->
            M (core.ops.control_flow.ControlFlow.t _ _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.try_trait.Try.branch
            (Self := core.option.Option.t alloc.string.String.t)
            (Trait := ℐ))) in
      let* α1 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
        M.read (std.process.Output.Get_stdout output) in
      let* α2 :
          core.result.Result.t
            alloc.string.String.t
            alloc.string.FromUtf8Error.t :=
        M.call (alloc.string.String.t::["from_utf8"] α1) in
      let* α3 : core.option.Option.t alloc.string.String.t :=
        M.call
          ((core.result.Result.t
                alloc.string.String.t
                alloc.string.FromUtf8Error.t)::["ok"]
            α2) in
      let* α4 :
          core.ops.control_flow.ControlFlow.t
            (core.option.Option.t core.convert.Infallible.t)
            alloc.string.String.t :=
        M.call (α0 α3) in
      let* α5 :
          M.Val
            (core.ops.control_flow.ControlFlow.t
              (core.option.Option.t core.convert.Infallible.t)
              alloc.string.String.t) :=
        M.alloc α4 in
      let* α6 : M.Val alloc.string.String.t :=
        match_operator
          α5
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Break _ =>
                let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                let* residual := M.copy γ0_0 in
                let* α0 :
                    (core.option.Option.t core.convert.Infallible.t) ->
                      M (core.option.Option.t u64.t) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.try_trait.FromResidual.from_residual
                      (Self := core.option.Option.t u64.t)
                      (R := core.option.Option.t core.convert.Infallible.t)
                      (Trait := ℐ))) in
                let* α1 : core.option.Option.t core.convert.Infallible.t :=
                  M.read residual in
                let* α2 : core.option.Option.t u64.t := M.call (α0 α1) in
                let* α3 : M.Val never.t := return_ α2 in
                let* α4 := M.read α3 in
                let* α5 : alloc.string.String.t := never_to_any α4 in
                M.alloc α5
              | _ => M.break_match
              end) :
              M (M.Val alloc.string.String.t);
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.ops.control_flow.ControlFlow.Continue _ =>
                let γ0_0 :=
                  core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                let* val := M.copy γ0_0 in
                M.pure val
              | _ => M.break_match
              end) :
              M (M.Val alloc.string.String.t)
          ] in
      M.copy α6 in
    let* pieces : M.Val (core.str.iter.Split.t (char.t -> M bool.t)) :=
      let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.deref.Deref.deref
            (Self := alloc.string.String.t)
            (Trait := ℐ))) in
      let* α1 : ref str.t := M.call (α0 (borrow version)) in
      let* α2 : ref str.t := M.call (str.t::["trim"] α1) in
      let* α3 : core.str.iter.Split.t (char.t -> M bool.t) :=
        M.call
          (str.t::["split"]
            α2
            (fun (α0 : char.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* c := M.copy γ in
                    let* α0 : char.t := M.read c in
                    let* α1 : char.t := M.read c in
                    M.pure
                      (BinOp.Pure.or
                        (BinOp.Pure.eq α0 "."%char)
                        (BinOp.Pure.eq α1 "-"%char))) :
                    M bool.t
                ]) :
              M bool.t)) in
      M.alloc α3 in
    let* major : M.Val u64.t :=
      let* α0 :
          (mut_ref (core.str.iter.Split.t (char.t -> M bool.t))) ->
            M (core.option.Option.t _) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.next
            (Self := core.str.iter.Split.t (char.t -> M bool.t))
            (Trait := ℐ))) in
      let* α1 : core.option.Option.t (ref str.t) :=
        M.call (α0 (borrow_mut pieces)) in
      let* α2 : core.option.Option.t u64.t :=
        M.call
          ((core.option.Option.t (ref str.t))::["and_then"]
            α1
            (fun (α0 : ref str.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* x := M.copy γ in
                    let* α0 : ref str.t := M.read x in
                    let* α1 :
                        core.result.Result.t
                          u64.t
                          core.num.error.ParseIntError.t :=
                      M.call (str.t::["parse"] α0) in
                    M.call
                      ((core.result.Result.t
                            u64.t
                            core.num.error.ParseIntError.t)::["ok"]
                        α1)) :
                    M (core.option.Option.t u64.t)
                ]) :
              M (core.option.Option.t u64.t))) in
      let* α3 : u64.t :=
        M.call
          ((core.option.Option.t u64.t)::["unwrap_or"]
            α2
            ((Integer.of_Z 0) : u64.t)) in
      M.alloc α3 in
    let* minor : M.Val u64.t :=
      let* α0 :
          (mut_ref (core.str.iter.Split.t (char.t -> M bool.t))) ->
            M (core.option.Option.t _) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.next
            (Self := core.str.iter.Split.t (char.t -> M bool.t))
            (Trait := ℐ))) in
      let* α1 : core.option.Option.t (ref str.t) :=
        M.call (α0 (borrow_mut pieces)) in
      let* α2 : core.option.Option.t u64.t :=
        M.call
          ((core.option.Option.t (ref str.t))::["and_then"]
            α1
            (fun (α0 : ref str.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* x := M.copy γ in
                    let* α0 : ref str.t := M.read x in
                    let* α1 :
                        core.result.Result.t
                          u64.t
                          core.num.error.ParseIntError.t :=
                      M.call (str.t::["parse"] α0) in
                    M.call
                      ((core.result.Result.t
                            u64.t
                            core.num.error.ParseIntError.t)::["ok"]
                        α1)) :
                    M (core.option.Option.t u64.t)
                ]) :
              M (core.option.Option.t u64.t))) in
      let* α3 : u64.t :=
        M.call
          ((core.option.Option.t u64.t)::["unwrap_or"]
            α2
            ((Integer.of_Z 0) : u64.t)) in
      M.alloc α3 in
    let* patch : M.Val u64.t :=
      let* α0 :
          (mut_ref (core.str.iter.Split.t (char.t -> M bool.t))) ->
            M (core.option.Option.t _) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.next
            (Self := core.str.iter.Split.t (char.t -> M bool.t))
            (Trait := ℐ))) in
      let* α1 : core.option.Option.t (ref str.t) :=
        M.call (α0 (borrow_mut pieces)) in
      let* α2 : core.option.Option.t u64.t :=
        M.call
          ((core.option.Option.t (ref str.t))::["and_then"]
            α1
            (fun (α0 : ref str.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* x := M.copy γ in
                    let* α0 : ref str.t := M.read x in
                    let* α1 :
                        core.result.Result.t
                          u64.t
                          core.num.error.ParseIntError.t :=
                      M.call (str.t::["parse"] α0) in
                    M.call
                      ((core.result.Result.t
                            u64.t
                            core.num.error.ParseIntError.t)::["ok"]
                        α1)) :
                    M (core.option.Option.t u64.t)
                ]) :
              M (core.option.Option.t u64.t))) in
      let* α3 : u64.t :=
        M.call
          ((core.option.Option.t u64.t)::["unwrap_or"]
            α2
            ((Integer.of_Z 0) : u64.t)) in
      M.alloc α3 in
    let* α0 : u64.t := M.read major in
    let* α1 : u64.t := BinOp.Panic.mul α0 ((Integer.of_Z 10000) : u64.t) in
    let* α2 : u64.t := M.read minor in
    let* α3 : u64.t := BinOp.Panic.mul α2 ((Integer.of_Z 100) : u64.t) in
    let* α4 : u64.t := BinOp.Panic.add α1 α3 in
    let* α5 : u64.t := M.read patch in
    let* α6 : u64.t := BinOp.Panic.add α4 α5 in
    let* α0 : M.Val (core.option.Option.t u64.t) :=
      M.alloc (core.option.Option.Some α6) in
    M.read α0).

(*
fn set_cfg(cfg: &str) {
    if !ALLOWED_CFGS.contains(&cfg) {
        panic!("trying to set cfg {}, but it is not in ALLOWED_CFGS", cfg);
    }
    println!("cargo:rustc-cfg={}", cfg);
}
*)
Definition set_cfg (cfg : ref str.t) : M unit :=
  let* cfg := M.alloc cfg in
  let* _ : M.Val unit :=
    let* α0 : ref (slice (ref str.t)) :=
      M.read build_script_build.ALLOWED_CFGS in
    let* α1 : bool.t :=
      M.call ((slice (ref str.t))::["contains"] α0 (borrow cfg)) in
    let* α2 : M.Val bool.t := M.alloc (UnOp.not α1) in
    let* α3 : bool.t := M.read (use α2) in
    if α3 then
      let* α0 : ref str.t := M.read (mk_str "trying to set cfg ") in
      let* α1 : ref str.t :=
        M.read (mk_str ", but it is not in ALLOWED_CFGS") in
      let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
      let* α3 : core.fmt.rt.Argument.t :=
        M.call (core.fmt.rt.Argument.t::["new_display"] (borrow cfg)) in
      let* α4 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α3 ] in
      let* α5 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_v1"]
            (pointer_coercion "Unsize" (borrow α2))
            (pointer_coercion "Unsize" (borrow α4))) in
      let* α6 : never.t := M.call (core.panicking.panic_fmt α5) in
      let* α7 : unit := never_to_any α6 in
      M.alloc α7
    else
      M.alloc tt in
  let* _ : M.Val unit :=
    let* _ : M.Val unit :=
      let* α0 : ref str.t := M.read (mk_str "cargo:rustc-cfg=") in
      let* α1 : ref str.t := M.read (mk_str "
") in
      let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
      let* α3 : core.fmt.rt.Argument.t :=
        M.call (core.fmt.rt.Argument.t::["new_display"] (borrow cfg)) in
      let* α4 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α3 ] in
      let* α5 : core.fmt.Arguments.t :=
        M.call
          (core.fmt.Arguments.t::["new_v1"]
            (pointer_coercion "Unsize" (borrow α2))
            (pointer_coercion "Unsize" (borrow α4))) in
      let* α6 : unit := M.call (std.io.stdio._print α5) in
      M.alloc α6 in
    M.alloc tt in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.
