(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  DefaultCallbacks.
Section DefaultCallbacks.
  Inductive t : Set := Build.
End DefaultCallbacks.
End DefaultCallbacks.

Module  Impl_rustc_driver_impl_Callbacks_for_coq_of_rust_rustc_DefaultCallbacks_t.
Section Impl_rustc_driver_impl_Callbacks_for_coq_of_rust_rustc_DefaultCallbacks_t.
  Definition Self : Set := coq_of_rust_rustc.DefaultCallbacks.t.
  
  Global Instance ℐ : rustc_driver_impl.Callbacks.Required.Trait Self := {
    rustc_driver_impl.Callbacks.config := Datatypes.None;
    rustc_driver_impl.Callbacks.after_crate_root_parsing := Datatypes.None;
    rustc_driver_impl.Callbacks.after_expansion := Datatypes.None;
    rustc_driver_impl.Callbacks.after_analysis := Datatypes.None;
  }.
End Impl_rustc_driver_impl_Callbacks_for_coq_of_rust_rustc_DefaultCallbacks_t.
End Impl_rustc_driver_impl_Callbacks_for_coq_of_rust_rustc_DefaultCallbacks_t.

(*
fn main() {
    let handler =
        rustc_session::EarlyErrorHandler::new(rustc_session::config::ErrorOutputType::default());

    rustc_driver::init_rustc_env_logger(&handler);
    setup_plugin();
}
*)
Definition main : M unit :=
  let* handler : M.Val rustc_session.session.EarlyErrorHandler.t :=
    let* α0 : M rustc_session.config.ErrorOutputType.t :=
      ltac:(M.get_method (fun ℐ =>
        core.default.Default.default
          (Self := rustc_session.config.ErrorOutputType.t)
          (Trait := ℐ))) in
    let* α1 : rustc_session.config.ErrorOutputType.t := M.call α0 in
    let* α2 : rustc_session.session.EarlyErrorHandler.t :=
      M.call (rustc_session.session.EarlyErrorHandler.t::["new"] α1) in
    M.alloc α2 in
  let* _ : M.Val unit :=
    let* α0 : unit :=
      M.call (rustc_driver_impl.init_rustc_env_logger (borrow handler)) in
    M.alloc α0 in
  let* _ : M.Val unit :=
    let* α0 : unit := M.call coq_of_rust_rustc.setup_plugin in
    M.alloc α0 in
  let* α0 : M.Val unit := M.alloc tt in
  M.read α0.

(*
fn setup_plugin() {
    let mut args = env::args().collect::<Vec<_>>();

    let is_wrapper = args.get(1).map(|s| s.contains("rustc")).unwrap_or(false);

    if is_wrapper {
        args.remove(1);
    }

    let coq_of_rust: CoqOfRustArgs = if is_wrapper {
        serde_json::from_str(&std::env::var("COQ_OF_RUST_ARGS").unwrap()).unwrap()
    } else {
        let all_args = Args::parse_from(&args);
        args = all_args.rust_flags;
        all_args.coq_of_rust
    };

    let sysroot = sysroot_path();
    args.push(format!("--sysroot={sysroot}"));

    let normal_rustc = args.iter().any(|arg| arg.starts_with("--print"));
    let primary_package = std::env::var("CARGO_PRIMARY_PACKAGE").is_ok();

    // Did the user ask to compile this crate? Either they explicitly invoked `coq_of_rust-rustc`
    // or this is a primary package.
    let user_asked_for = !is_wrapper || primary_package;

    if normal_rustc || !user_asked_for {
        return RunCompiler::new(&args, &mut DefaultCallbacks {})
            .run()
            .unwrap();
    } else {
        let opts = Options::from_args(coq_of_rust);
        let mut callbacks = ToCoq::new(opts);

        RunCompiler::new(&args, &mut callbacks).run().unwrap();
    }
}
*)
Definition setup_plugin : M unit :=
  let return_ := M.return_ (R := unit) in
  M.catch_return
    (let* args :
        M.Val (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t) :=
      let* α0 :
          std.env.Args.t ->
            M (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t) :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.collect
            (Self := std.env.Args.t)
            (B := alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)
            (Trait := ℐ))) in
      let* α1 : std.env.Args.t := M.call std.env.args in
      let* α2 : alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t :=
        M.call (α0 α1) in
      M.alloc α2 in
    let* is_wrapper : M.Val bool.t :=
      let* α0 :
          (ref (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)) ->
            M (ref _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.deref.Deref.deref
            (Self := alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)
            (Trait := ℐ))) in
      let* α1 : ref (slice alloc.string.String.t) :=
        M.call (α0 (borrow args)) in
      let* α2 : core.option.Option.t (ref alloc.string.String.t) :=
        M.call
          ((slice alloc.string.String.t)::["get"]
            α1
            ((Integer.of_Z 1) : usize.t)) in
      let* α3 : core.option.Option.t bool.t :=
        M.call
          ((core.option.Option.t (ref alloc.string.String.t))::["map"]
            α2
            (fun (α0 : ref alloc.string.String.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* s := M.copy γ in
                    let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.deref.Deref.deref
                          (Self := alloc.string.String.t)
                          (Trait := ℐ))) in
                    let* α1 : ref alloc.string.String.t := M.read s in
                    let* α2 : ref str.t := M.call (α0 α1) in
                    let* α3 : ref str.t := M.read (mk_str "rustc") in
                    M.call (str.t::["contains"] α2 α3)) :
                    M bool.t
                ]) :
              M bool.t)) in
      let* α4 : bool.t :=
        M.call ((core.option.Option.t bool.t)::["unwrap_or"] α3 false) in
      M.alloc α4 in
    let* _ : M.Val unit :=
      let* α0 : bool.t := M.read (use is_wrapper) in
      if α0 then
        let* _ : M.Val alloc.string.String.t :=
          let* α0 : alloc.string.String.t :=
            M.call
              ((alloc.vec.Vec.t
                    alloc.string.String.t
                    alloc.alloc.Global.t)::["remove"]
                (borrow_mut args)
                ((Integer.of_Z 1) : usize.t)) in
          M.alloc α0 in
        M.alloc tt
      else
        M.alloc tt in
    let* coq_of_rust : M.Val coq_of_rust_lib.options.CoqOfRustArgs.t :=
      let* α0 : bool.t := M.read (use is_wrapper) in
      let* α1 : M.Val coq_of_rust_lib.options.CoqOfRustArgs.t :=
        if α0 then
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 : ref str.t := M.read (mk_str "COQ_OF_RUST_ARGS") in
          let* α2 :
              core.result.Result.t alloc.string.String.t std.env.VarError.t :=
            M.call (std.env.var α1) in
          let* α3 : alloc.string.String.t :=
            M.call
              ((core.result.Result.t
                    alloc.string.String.t
                    std.env.VarError.t)::["unwrap"]
                α2) in
          let* α4 : M.Val alloc.string.String.t := M.alloc α3 in
          let* α5 : ref str.t := M.call (α0 (borrow α4)) in
          let* α6 :
              core.result.Result.t
                coq_of_rust_lib.options.CoqOfRustArgs.t
                serde_json.error.Error.t :=
            M.call (serde_json.de.from_str α5) in
          let* α7 : coq_of_rust_lib.options.CoqOfRustArgs.t :=
            M.call
              ((core.result.Result.t
                    coq_of_rust_lib.options.CoqOfRustArgs.t
                    serde_json.error.Error.t)::["unwrap"]
                α6) in
          M.alloc α7
        else
          let* all_args : M.Val coq_of_rust_lib.options.Args.t :=
            let* α0 :
                (ref
                    (alloc.vec.Vec.t
                      alloc.string.String.t
                      alloc.alloc.Global.t))
                  ->
                  M coq_of_rust_lib.options.Args.t :=
              ltac:(M.get_method (fun ℐ =>
                clap.derive.Parser.parse_from
                  (Self := coq_of_rust_lib.options.Args.t)
                  (I :=
                    ref
                      (alloc.vec.Vec.t
                        alloc.string.String.t
                        alloc.alloc.Global.t))
                  (T := ref alloc.string.String.t)
                  (Trait := ℐ))) in
            let* α1 : coq_of_rust_lib.options.Args.t :=
              M.call (α0 (borrow args)) in
            M.alloc α1 in
          let* _ : M.Val unit :=
            let* α0 :
                alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t :=
              M.read (coq_of_rust_lib.options.Args.Get_rust_flags all_args) in
            assign args α0 in
          M.pure (coq_of_rust_lib.options.Args.Get_coq_of_rust all_args) in
      M.copy α1 in
    let* sysroot : M.Val alloc.string.String.t :=
      let* α0 : alloc.string.String.t :=
        M.call coq_of_rust_rustc.sysroot_path in
      M.alloc α0 in
    let* _ : M.Val unit :=
      let* res : M.Val alloc.string.String.t :=
        let* α0 : ref str.t := M.read (mk_str "--sysroot=") in
        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
        let* α2 : core.fmt.rt.Argument.t :=
          M.call (core.fmt.rt.Argument.t::["new_display"] (borrow sysroot)) in
        let* α3 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α2 ] in
        let* α4 : core.fmt.Arguments.t :=
          M.call
            (core.fmt.Arguments.t::["new_v1"]
              (pointer_coercion "Unsize" (borrow α1))
              (pointer_coercion "Unsize" (borrow α3))) in
        let* α5 : alloc.string.String.t := M.call (alloc.fmt.format α4) in
        M.alloc α5 in
      let* α0 : alloc.string.String.t := M.read res in
      let* α1 : unit :=
        M.call
          ((alloc.vec.Vec.t
                alloc.string.String.t
                alloc.alloc.Global.t)::["push"]
            (borrow_mut args)
            α0) in
      M.alloc α1 in
    let* normal_rustc : M.Val bool.t :=
      let* α0 :
          (mut_ref (core.slice.iter.Iter.t alloc.string.String.t)) ->
            ((ref alloc.string.String.t) -> M bool.t) ->
            M bool.t :=
        ltac:(M.get_method (fun ℐ =>
          core.iter.traits.iterator.Iterator.any
            (Self := core.slice.iter.Iter.t alloc.string.String.t)
            (F := (ref alloc.string.String.t) -> M bool.t)
            (Trait := ℐ))) in
      let* α1 :
          (ref (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)) ->
            M (ref _) :=
        ltac:(M.get_method (fun ℐ =>
          core.ops.deref.Deref.deref
            (Self := alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)
            (Trait := ℐ))) in
      let* α2 : ref (slice alloc.string.String.t) :=
        M.call (α1 (borrow args)) in
      let* α3 : core.slice.iter.Iter.t alloc.string.String.t :=
        M.call ((slice alloc.string.String.t)::["iter"] α2) in
      let* α4 : M.Val (core.slice.iter.Iter.t alloc.string.String.t) :=
        M.alloc α3 in
      let* α5 : bool.t :=
        M.call
          (α0
            (borrow_mut α4)
            (fun (α0 : ref alloc.string.String.t) =>
              (let* α0 := M.alloc α0 in
              match_operator
                α0
                [
                  fun γ =>
                    (let* arg := M.copy γ in
                    let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.deref.Deref.deref
                          (Self := alloc.string.String.t)
                          (Trait := ℐ))) in
                    let* α1 : ref alloc.string.String.t := M.read arg in
                    let* α2 : ref str.t := M.call (α0 α1) in
                    let* α3 : ref str.t := M.read (mk_str "--print") in
                    M.call (str.t::["starts_with"] α2 α3)) :
                    M bool.t
                ]) :
              M bool.t)) in
      M.alloc α5 in
    let* primary_package : M.Val bool.t :=
      let* α0 : ref str.t := M.read (mk_str "CARGO_PRIMARY_PACKAGE") in
      let* α1 : core.result.Result.t alloc.string.String.t std.env.VarError.t :=
        M.call (std.env.var α0) in
      let* α2 :
          M.Val
            (core.result.Result.t alloc.string.String.t std.env.VarError.t) :=
        M.alloc α1 in
      let* α3 : bool.t :=
        M.call
          ((core.result.Result.t
                alloc.string.String.t
                std.env.VarError.t)::["is_ok"]
            (borrow α2)) in
      M.alloc α3 in
    let* user_asked_for : M.Val bool.t :=
      let* α0 : bool.t := M.read is_wrapper in
      let* α1 : bool.t := M.read primary_package in
      M.alloc (BinOp.Pure.or (UnOp.not α0) α1) in
    let* α0 : bool.t := M.read normal_rustc in
    let* α1 : bool.t := M.read user_asked_for in
    let* α2 : M.Val bool.t := M.alloc (BinOp.Pure.or α0 (UnOp.not α1)) in
    let* α3 : bool.t := M.read (use α2) in
    let* α0 : M.Val unit :=
      if α3 then
        let* α0 :
            (ref (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t))
              ->
              M (ref _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.deref.Deref.deref
              (Self :=
                alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)
              (Trait := ℐ))) in
        let* α1 : ref (slice alloc.string.String.t) :=
          M.call (α0 (borrow args)) in
        let* α2 : M.Val coq_of_rust_rustc.DefaultCallbacks.t :=
          M.alloc coq_of_rust_rustc.DefaultCallbacks.Build in
        let* α3 : rustc_driver_impl.RunCompiler.t :=
          M.call
            (rustc_driver_impl.RunCompiler.t::["new"]
              α1
              (pointer_coercion "Unsize" (borrow_mut α2))) in
        let* α4 : core.result.Result.t unit rustc_span.ErrorGuaranteed.t :=
          M.call (rustc_driver_impl.RunCompiler.t::["run"] α3) in
        let* α5 : unit :=
          M.call
            ((core.result.Result.t
                  unit
                  rustc_span.ErrorGuaranteed.t)::["unwrap"]
              α4) in
        let* α6 : M.Val never.t := return_ α5 in
        let* α7 := M.read α6 in
        let* α8 : unit := never_to_any α7 in
        M.alloc α8
      else
        let* opts : M.Val coq_of_rust_lib.options.Options.t :=
          let* α0 : coq_of_rust_lib.options.CoqOfRustArgs.t :=
            M.read coq_of_rust in
          let* α1 : coq_of_rust_lib.options.Options.t :=
            M.call (coq_of_rust_lib.options.Options.t::["from_args"] α0) in
          M.alloc α1 in
        let* callbacks : M.Val coq_of_rust_lib.callbacks.ToCoq.t :=
          let* α0 : coq_of_rust_lib.options.Options.t := M.read opts in
          let* α1 : coq_of_rust_lib.callbacks.ToCoq.t :=
            M.call (coq_of_rust_lib.callbacks.ToCoq.t::["new"] α0) in
          M.alloc α1 in
        let* _ : M.Val unit :=
          let* α0 :
              (ref (alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  alloc.vec.Vec.t alloc.string.String.t alloc.alloc.Global.t)
                (Trait := ℐ))) in
          let* α1 : ref (slice alloc.string.String.t) :=
            M.call (α0 (borrow args)) in
          let* α2 : rustc_driver_impl.RunCompiler.t :=
            M.call
              (rustc_driver_impl.RunCompiler.t::["new"]
                α1
                (pointer_coercion "Unsize" (borrow_mut callbacks))) in
          let* α3 : core.result.Result.t unit rustc_span.ErrorGuaranteed.t :=
            M.call (rustc_driver_impl.RunCompiler.t::["run"] α2) in
          let* α4 : unit :=
            M.call
              ((core.result.Result.t
                    unit
                    rustc_span.ErrorGuaranteed.t)::["unwrap"]
                α3) in
          M.alloc α4 in
        M.alloc tt in
    M.read α0).

(*
fn sysroot_path() -> String {
    let toolchain: toml::Value = toml::from_str(include_str!("../../../rust-toolchain")).unwrap();
    let channel = toolchain["toolchain"]["channel"].as_str().unwrap();

    let output = Command::new("rustup")
        .arg("run")
        .arg(channel)
        .arg("rustc")
        .arg("--print")
        .arg("sysroot")
        .output()
        .unwrap();

    String::from_utf8(output.stdout).unwrap().trim().to_owned()
}
*)
Definition sysroot_path : M alloc.string.String.t :=
  let* toolchain : M.Val toml.value.Value.t :=
    let* α0 : ref str.t :=
      M.read
        (mk_str
          "[toolchain]
channel = ""nightly-2023-12-15""
components = [
  ""clippy"",
  ""llvm-tools-preview"" ,
  ""rustc-dev"",
  ""rustfmt""
]
") in
    let* α1 : core.result.Result.t toml.value.Value.t toml.de.Error.t :=
      M.call (toml.de.from_str α0) in
    let* α2 : toml.value.Value.t :=
      M.call
        ((core.result.Result.t toml.value.Value.t toml.de.Error.t)::["unwrap"]
          α1) in
    M.alloc α2 in
  let* channel : M.Val (ref str.t) :=
    let* α0 : (ref toml.value.Value.t) -> (ref str.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.index.Index.index
          (Self := toml.value.Value.t)
          (Idx := ref str.t)
          (Trait := ℐ))) in
    let* α1 : (ref toml.value.Value.t) -> (ref str.t) -> M (ref _) :=
      ltac:(M.get_method (fun ℐ =>
        core.ops.index.Index.index
          (Self := toml.value.Value.t)
          (Idx := ref str.t)
          (Trait := ℐ))) in
    let* α2 : ref str.t := M.read (mk_str "toolchain") in
    let* α3 : ref toml.value.Value.t := M.call (α1 (borrow toolchain) α2) in
    let* α4 : ref str.t := M.read (mk_str "channel") in
    let* α5 : ref toml.value.Value.t := M.call (α0 α3 α4) in
    let* α6 : core.option.Option.t (ref str.t) :=
      M.call (toml.value.Value.t::["as_str"] α5) in
    let* α7 : ref str.t :=
      M.call ((core.option.Option.t (ref str.t))::["unwrap"] α6) in
    M.alloc α7 in
  let* output : M.Val std.process.Output.t :=
    let* α0 : ref str.t := M.read (mk_str "rustup") in
    let* α1 : std.process.Command.t :=
      M.call (std.process.Command.t::["new"] α0) in
    let* α2 : M.Val std.process.Command.t := M.alloc α1 in
    let* α3 : ref str.t := M.read (mk_str "run") in
    let* α4 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] (borrow_mut α2) α3) in
    let* α5 : ref str.t := M.read channel in
    let* α6 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] α4 α5) in
    let* α7 : ref str.t := M.read (mk_str "rustc") in
    let* α8 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] α6 α7) in
    let* α9 : ref str.t := M.read (mk_str "--print") in
    let* α10 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] α8 α9) in
    let* α11 : ref str.t := M.read (mk_str "sysroot") in
    let* α12 : mut_ref std.process.Command.t :=
      M.call (std.process.Command.t::["arg"] α10 α11) in
    let* α13 : core.result.Result.t std.process.Output.t std.io.error.Error.t :=
      M.call (std.process.Command.t::["output"] α12) in
    let* α14 : std.process.Output.t :=
      M.call
        ((core.result.Result.t
              std.process.Output.t
              std.io.error.Error.t)::["unwrap"]
          α13) in
    M.alloc α14 in
  let* α0 : (ref str.t) -> M _ :=
    ltac:(M.get_method (fun ℐ =>
      alloc.borrow.ToOwned.to_owned (Self := str.t) (Trait := ℐ))) in
  let* α1 : (ref alloc.string.String.t) -> M (ref _) :=
    ltac:(M.get_method (fun ℐ =>
      core.ops.deref.Deref.deref
        (Self := alloc.string.String.t)
        (Trait := ℐ))) in
  let* α2 : alloc.vec.Vec.t u8.t alloc.alloc.Global.t :=
    M.read (std.process.Output.Get_stdout output) in
  let* α3 :
      core.result.Result.t alloc.string.String.t alloc.string.FromUtf8Error.t :=
    M.call (alloc.string.String.t::["from_utf8"] α2) in
  let* α4 : alloc.string.String.t :=
    M.call
      ((core.result.Result.t
            alloc.string.String.t
            alloc.string.FromUtf8Error.t)::["unwrap"]
        α3) in
  let* α5 : M.Val alloc.string.String.t := M.alloc α4 in
  let* α6 : ref str.t := M.call (α1 (borrow α5)) in
  let* α7 : ref str.t := M.call (str.t::["trim"] α6) in
  let* α8 : alloc.string.String.t := M.call (α0 α7) in
  let* α0 : M.Val alloc.string.String.t := M.alloc α8 in
  M.read α0.
