(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Translate.
Section Translate.
  Record t : Set := {
    path : std.path.PathBuf.t;
    axiomatize : bool.t;
    axiomatize_public : bool.t;
    generate_reorder : bool.t;
    output_path : std.path.PathBuf.t;
    configuration_file : alloc.string.String.t;
  }.
  
  Definition Get_path :=
    Ref.map (fun α => Some α.(path)) (fun β α => Some (α <| path := β |>)).
  Definition Get_axiomatize :=
    Ref.map
      (fun α => Some α.(axiomatize))
      (fun β α => Some (α <| axiomatize := β |>)).
  Definition Get_axiomatize_public :=
    Ref.map
      (fun α => Some α.(axiomatize_public))
      (fun β α => Some (α <| axiomatize_public := β |>)).
  Definition Get_generate_reorder :=
    Ref.map
      (fun α => Some α.(generate_reorder))
      (fun β α => Some (α <| generate_reorder := β |>)).
  Definition Get_output_path :=
    Ref.map
      (fun α => Some α.(output_path))
      (fun β α => Some (α <| output_path := β |>)).
  Definition Get_configuration_file :=
    Ref.map
      (fun α => Some α.(configuration_file))
      (fun β α => Some (α <| configuration_file := β |>)).
End Translate.
End Translate.

Module  Impl_clap_derive_FromArgMatches_for_coq_of_rust_Translate_t.
Section Impl_clap_derive_FromArgMatches_for_coq_of_rust_Translate_t.
  Definition Self : Set := coq_of_rust.Translate.t.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α1 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α2 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α0 α1) in
    let* α3 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α2 in
    M.call (from_arg_matches_mut (borrow_mut α3)).
  
  Global Instance AssociatedFunction_from_arg_matches :
    Notations.DoubleColon Self "from_arg_matches" := {
    Notations.double_colon := from_arg_matches;
  }.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches_mut
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t Self ltac:(clap.Error)) in
    M.catch_return
      (let* v : M.Val coq_of_rust.Translate.t :=
        let* α0 :
            (core.result.Result.t
                std.path.PathBuf.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  std.path.PathBuf.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α1 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α2 : ref str.t := M.read (mk_str "path") in
        let* α3 : core.option.Option.t std.path.PathBuf.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α1
              α2) in
        let* α4 :
            core.result.Result.t
              std.path.PathBuf.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t std.path.PathBuf.t)::["ok_or_else"]
              α3
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: path") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α5 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              std.path.PathBuf.t :=
          M.call (α0 α4) in
        let* α6 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                std.path.PathBuf.t) :=
          M.alloc α5 in
        let* α7 : M.Val std.path.PathBuf.t :=
          match_operator
            α6
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : std.path.PathBuf.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val std.path.PathBuf.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val std.path.PathBuf.t)
            ] in
        let* α8 : std.path.PathBuf.t := M.read α7 in
        let* α9 :
            (core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α10 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α11 : ref str.t := M.read (mk_str "axiomatize") in
        let* α12 : core.option.Option.t bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α10
              α11) in
        let* α13 :
            core.result.Result.t
              bool.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t bool.t)::["ok_or_else"]
              α12
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: axiomatize") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α14 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              bool.t :=
          M.call (α9 α13) in
        let* α15 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t) :=
          M.alloc α14 in
        let* α16 : M.Val bool.t :=
          match_operator
            α15
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : bool.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val bool.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val bool.t)
            ] in
        let* α17 : bool.t := M.read α16 in
        let* α18 :
            (core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α19 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α20 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α21 : core.option.Option.t bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α19
              α20) in
        let* α22 :
            core.result.Result.t
              bool.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t bool.t)::["ok_or_else"]
              α21
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: axiomatize_public") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α23 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              bool.t :=
          M.call (α18 α22) in
        let* α24 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t) :=
          M.alloc α23 in
        let* α25 : M.Val bool.t :=
          match_operator
            α24
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : bool.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val bool.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val bool.t)
            ] in
        let* α26 : bool.t := M.read α25 in
        let* α27 :
            (core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α28 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α29 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α30 : core.option.Option.t bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α28
              α29) in
        let* α31 :
            core.result.Result.t
              bool.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t bool.t)::["ok_or_else"]
              α30
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: generate_reorder") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α32 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              bool.t :=
          M.call (α27 α31) in
        let* α33 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t) :=
          M.alloc α32 in
        let* α34 : M.Val bool.t :=
          match_operator
            α33
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : bool.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val bool.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val bool.t)
            ] in
        let* α35 : bool.t := M.read α34 in
        let* α36 :
            (core.result.Result.t
                std.path.PathBuf.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  std.path.PathBuf.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α37 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α38 : ref str.t := M.read (mk_str "output_path") in
        let* α39 : core.option.Option.t std.path.PathBuf.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α37
              α38) in
        let* α40 :
            core.result.Result.t
              std.path.PathBuf.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t std.path.PathBuf.t)::["ok_or_else"]
              α39
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: output_path") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α41 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              std.path.PathBuf.t :=
          M.call (α36 α40) in
        let* α42 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                std.path.PathBuf.t) :=
          M.alloc α41 in
        let* α43 : M.Val std.path.PathBuf.t :=
          match_operator
            α42
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : std.path.PathBuf.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val std.path.PathBuf.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val std.path.PathBuf.t)
            ] in
        let* α44 : std.path.PathBuf.t := M.read α43 in
        let* α45 :
            (core.result.Result.t
                alloc.string.String.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  alloc.string.String.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α46 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α47 : ref str.t := M.read (mk_str "configuration_file") in
        let* α48 : core.option.Option.t alloc.string.String.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α46
              α47) in
        let* α49 :
            core.result.Result.t
              alloc.string.String.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t alloc.string.String.t)::["ok_or_else"]
              α48
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: configuration_file") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α50 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              alloc.string.String.t :=
          M.call (α45 α49) in
        let* α51 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                alloc.string.String.t) :=
          M.alloc α50 in
        let* α52 : M.Val alloc.string.String.t :=
          match_operator
            α51
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Translate.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : alloc.string.String.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val alloc.string.String.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val alloc.string.String.t)
            ] in
        let* α53 : alloc.string.String.t := M.read α52 in
        M.alloc
          {|
            coq_of_rust.Translate.path := α8;
            coq_of_rust.Translate.axiomatize := α17;
            coq_of_rust.Translate.axiomatize_public := α26;
            coq_of_rust.Translate.generate_reorder := α35;
            coq_of_rust.Translate.output_path := α44;
            coq_of_rust.Translate.configuration_file := α53;
          |} in
      let* α0 : coq_of_rust.Translate.t := M.read v in
      let* α0 :
          M.Val
            (core.result.Result.t
              coq_of_rust.Translate.t
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        M.alloc (core.result.Result.Ok α0) in
      M.read α0).
  
  Global Instance AssociatedFunction_from_arg_matches_mut :
    Notations.DoubleColon Self "from_arg_matches_mut" := {
    Notations.double_colon := from_arg_matches_mut;
  }.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches
      (self : mut_ref Self)
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
    let* α1 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α2 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α3 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α1 α2) in
    let* α4 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α3 in
    M.call (update_from_arg_matches_mut α0 (borrow_mut α4)).
  
  Global Instance AssociatedFunction_update_from_arg_matches :
    Notations.DoubleColon Self "update_from_arg_matches" := {
    Notations.double_colon := update_from_arg_matches;
  }.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches_mut
      (self : mut_ref Self)
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t unit ltac:(clap.Error)) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "path") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* path : M.Val (mut_ref std.path.PathBuf.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc (borrow_mut (coq_of_rust.Translate.Get_path (deref α0))) in
          let* α0 : mut_ref std.path.PathBuf.t := M.read path in
          let* α1 :
              (core.result.Result.t
                  std.path.PathBuf.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    std.path.PathBuf.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "path") in
          let* α4 : core.option.Option.t std.path.PathBuf.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                std.path.PathBuf.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t std.path.PathBuf.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: path") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                std.path.PathBuf.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  std.path.PathBuf.t) :=
            M.alloc α6 in
          let* α8 : M.Val std.path.PathBuf.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : std.path.PathBuf.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val std.path.PathBuf.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val std.path.PathBuf.t)
              ] in
          let* α9 : std.path.PathBuf.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "axiomatize") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* axiomatize : M.Val (mut_ref bool.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc
              (borrow_mut (coq_of_rust.Translate.Get_axiomatize (deref α0))) in
          let* α0 : mut_ref bool.t := M.read axiomatize in
          let* α1 :
              (core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    bool.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "axiomatize") in
          let* α4 : core.option.Option.t bool.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t bool.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: axiomatize") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  bool.t) :=
            M.alloc α6 in
          let* α8 : M.Val bool.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : bool.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t)
              ] in
          let* α9 : bool.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* axiomatize_public : M.Val (mut_ref bool.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc
              (borrow_mut
                (coq_of_rust.Translate.Get_axiomatize_public (deref α0))) in
          let* α0 : mut_ref bool.t := M.read axiomatize_public in
          let* α1 :
              (core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    bool.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "axiomatize_public") in
          let* α4 : core.option.Option.t bool.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t bool.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: axiomatize_public") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  bool.t) :=
            M.alloc α6 in
          let* α8 : M.Val bool.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : bool.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t)
              ] in
          let* α9 : bool.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* generate_reorder : M.Val (mut_ref bool.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc
              (borrow_mut
                (coq_of_rust.Translate.Get_generate_reorder (deref α0))) in
          let* α0 : mut_ref bool.t := M.read generate_reorder in
          let* α1 :
              (core.result.Result.t
                  bool.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    bool.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "generate_reorder") in
          let* α4 : core.option.Option.t bool.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                bool.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t bool.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: generate_reorder") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                bool.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  bool.t) :=
            M.alloc α6 in
          let* α8 : M.Val bool.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : bool.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val bool.t)
              ] in
          let* α9 : bool.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "output_path") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* output_path : M.Val (mut_ref std.path.PathBuf.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc
              (borrow_mut (coq_of_rust.Translate.Get_output_path (deref α0))) in
          let* α0 : mut_ref std.path.PathBuf.t := M.read output_path in
          let* α1 :
              (core.result.Result.t
                  std.path.PathBuf.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    std.path.PathBuf.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "output_path") in
          let* α4 : core.option.Option.t std.path.PathBuf.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                std.path.PathBuf.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t std.path.PathBuf.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: output_path") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                std.path.PathBuf.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  std.path.PathBuf.t) :=
            M.alloc α6 in
          let* α8 : M.Val std.path.PathBuf.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : std.path.PathBuf.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val std.path.PathBuf.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val std.path.PathBuf.t)
              ] in
          let* α9 : std.path.PathBuf.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "configuration_file") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* configuration_file : M.Val (mut_ref alloc.string.String.t) :=
            let* α0 : mut_ref coq_of_rust.Translate.t := M.read self in
            M.alloc
              (borrow_mut
                (coq_of_rust.Translate.Get_configuration_file (deref α0))) in
          let* α0 : mut_ref alloc.string.String.t :=
            M.read configuration_file in
          let* α1 :
              (core.result.Result.t
                  alloc.string.String.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    alloc.string.String.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "configuration_file") in
          let* α4 : core.option.Option.t alloc.string.String.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                alloc.string.String.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t alloc.string.String.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: configuration_file") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                alloc.string.String.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  alloc.string.String.t) :=
            M.alloc α6 in
          let* α8 : M.Val alloc.string.String.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : alloc.string.String.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val alloc.string.String.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val alloc.string.String.t)
              ] in
          let* α9 : alloc.string.String.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* α0 :
          M.Val
            (core.result.Result.t
              unit
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_update_from_arg_matches_mut :
    Notations.DoubleColon Self "update_from_arg_matches_mut" := {
    Notations.double_colon := update_from_arg_matches_mut;
  }.
  
  Global Instance ℐ : clap.derive.FromArgMatches.Required.Trait Self := {
    clap.derive.FromArgMatches.from_arg_matches := from_arg_matches;
    clap.derive.FromArgMatches.from_arg_matches_mut :=
      Datatypes.Some from_arg_matches_mut;
    clap.derive.FromArgMatches.update_from_arg_matches :=
      update_from_arg_matches;
    clap.derive.FromArgMatches.update_from_arg_matches_mut :=
      Datatypes.Some update_from_arg_matches_mut;
  }.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Translate_t.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Translate_t.

Module  Impl_clap_derive_Args_for_coq_of_rust_Translate_t.
Section Impl_clap_derive_Args_for_coq_of_rust_Translate_t.
  Definition Self : Set := coq_of_rust.Translate.t.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition group_id : M (core.option.Option.t clap.util.id.Id.t) :=
    let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := clap.util.id.Id.t)
          (T := ref str.t)
          (Trait := ℐ))) in
    let* α1 : ref str.t := M.read (mk_str "Translate") in
    let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
    M.pure (core.option.Option.Some α2).
  
  Global Instance AssociatedFunction_group_id :
    Notations.DoubleColon Self "group_id" := {
    Notations.double_colon := group_id;
  }.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_args
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : ref str.t := M.read (mk_str "Translate") in
      let* α2 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["new"] α1) in
      let* α3 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["multiple"] α2 true) in
      let* members : M.Val (array clap.util.id.Id.t) :=
        let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α1 : ref str.t := M.read (mk_str "path") in
        let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
        let* α3 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize") in
        let* α5 : clap.util.id.Id.t := M.call (α3 α4) in
        let* α6 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α7 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α8 : clap.util.id.Id.t := M.call (α6 α7) in
        let* α9 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α10 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α11 : clap.util.id.Id.t := M.call (α9 α10) in
        let* α12 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α13 : ref str.t := M.read (mk_str "output_path") in
        let* α14 : clap.util.id.Id.t := M.call (α12 α13) in
        let* α15 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α16 : ref str.t := M.read (mk_str "configuration_file") in
        let* α17 : clap.util.id.Id.t := M.call (α15 α16) in
        M.alloc [ α2; α5; α8; α11; α14; α17 ] in
      let* α4 : array clap.util.id.Id.t := M.read members in
      let* α5 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["args"] α3 α4) in
      let* α6 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["group"] α0 α5) in
      M.alloc α6 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "path") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "PATH") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and true α5)) in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["value_parser"]
              α6
              coq_of_rust.is_valid_path) in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α7
              clap.builder.action.ArgAction.Set_) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Sets a path to rust file") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["short"] α3 "p"%char) in
        let* α5 : ref str.t := M.read (mk_str "path") in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α4 α5) in
        let* α7 : ref str.t := M.read (mk_str "PATH") in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α6 α7) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "axiomatize") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "AXIOMATIZE") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Axiomatize the definitions") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "axiomatize") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "AXIOMATIZE_PUBLIC") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read
            (mk_str "Axiomatize the definitions with everything as public") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize-public") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "GENERATE_REORDER") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read
            (mk_str
              "Generate the ""reorder"" section of the configuration file") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "generate-reorder") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "output_path") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "OUTPUT_PATH") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["value_parser"]
              α6
              coq_of_rust.is_valid_path) in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α7
              clap.builder.action.ArgAction.Set_) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read (mk_str "Output path where to place the translation") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "output-path") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "output_path") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* α8 : ref str.t := M.read (mk_str "coq_translation") in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "configuration_file") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "CONFIGURATION_FILE") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val
              (clap.builder.value_parser._AutoValueParser.t
                alloc.string.String.t) :=
          let* α0 :
              clap.builder.value_parser._AutoValueParser.t
                alloc.string.String.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t
                  alloc.string.String.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              alloc.string.String.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              alloc.string.String.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val
              (ref
                (clap.builder.value_parser._AutoValueParser.t
                  alloc.string.String.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref
                  (clap.builder.value_parser._AutoValueParser.t
                    alloc.string.String.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t
                      alloc.string.String.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        alloc.string.String.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          alloc.string.String.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            alloc.string.String.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.Set_) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Configuration file path") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "configuration-file") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "config") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* α8 : ref str.t := M.read (mk_str "coq-of-rust-config.json") in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    M.read __clap_app.
  
  Global Instance AssociatedFunction_augment_args :
    Notations.DoubleColon Self "augment_args" := {
    Notations.double_colon := augment_args;
  }.
  
  (*
  Args
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_args_for_update
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : ref str.t := M.read (mk_str "Translate") in
      let* α2 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["new"] α1) in
      let* α3 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["multiple"] α2 true) in
      let* members : M.Val (array clap.util.id.Id.t) :=
        let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α1 : ref str.t := M.read (mk_str "path") in
        let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
        let* α3 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize") in
        let* α5 : clap.util.id.Id.t := M.call (α3 α4) in
        let* α6 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α7 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α8 : clap.util.id.Id.t := M.call (α6 α7) in
        let* α9 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α10 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α11 : clap.util.id.Id.t := M.call (α9 α10) in
        let* α12 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α13 : ref str.t := M.read (mk_str "output_path") in
        let* α14 : clap.util.id.Id.t := M.call (α12 α13) in
        let* α15 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α16 : ref str.t := M.read (mk_str "configuration_file") in
        let* α17 : clap.util.id.Id.t := M.call (α15 α16) in
        M.alloc [ α2; α5; α8; α11; α14; α17 ] in
      let* α4 : array clap.util.id.Id.t := M.read members in
      let* α5 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["args"] α3 α4) in
      let* α6 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["group"] α0 α5) in
      M.alloc α6 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "path") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "PATH") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and true α5)) in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["value_parser"]
              α6
              coq_of_rust.is_valid_path) in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α7
              clap.builder.action.ArgAction.Set_) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Sets a path to rust file") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["short"] α3 "p"%char) in
        let* α5 : ref str.t := M.read (mk_str "path") in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α4 α5) in
        let* α7 : ref str.t := M.read (mk_str "PATH") in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α6 α7) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "axiomatize") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "AXIOMATIZE") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Axiomatize the definitions") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "axiomatize") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args_for_update.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "AXIOMATIZE_PUBLIC") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read
            (mk_str "Axiomatize the definitions with everything as public") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "axiomatize-public") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "axiomatize_public") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args_for_update.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "GENERATE_REORDER") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.SetTrue in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val (clap.builder.value_parser._AutoValueParser.t bool.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t bool.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t bool.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              bool.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t bool.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref (clap.builder.value_parser._AutoValueParser.t bool.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t bool.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        bool.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          bool.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            bool.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.SetTrue) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read
            (mk_str
              "Generate the ""reorder"" section of the configuration file") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "generate-reorder") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "generate_reorder") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* s : M.Val (ref str.t) :=
          let* α0 : (ref alloc.string.String.t) -> M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self := alloc.string.String.t)
                (Trait := ℐ))) in
          let* α1 :
              (ref
                  (once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t)))
                ->
                M (ref _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.deref.Deref.deref
                (Self :=
                  once_cell.sync.Lazy.t
                    alloc.string.String.t
                    (M alloc.string.String.t))
                (Trait := ℐ))) in
          let* α2 :
              ref
                (once_cell.sync.Lazy.t
                  alloc.string.String.t
                  (M alloc.string.String.t)) :=
            M.read coq_of_rust.augment_args_for_update.DEFAULT_VALUE in
          let* α3 : ref alloc.string.String.t := M.call (α1 α2) in
          let* α4 : ref str.t := M.call (α0 α3) in
          M.alloc α4 in
        let* α8 : ref str.t := M.read s in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "output_path") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "OUTPUT_PATH") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["value_parser"]
              α6
              coq_of_rust.is_valid_path) in
        let* α8 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α7
              clap.builder.action.ArgAction.Set_) in
        M.alloc α8 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read (mk_str "Output path where to place the translation") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "output-path") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "output_path") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* α8 : ref str.t := M.read (mk_str "coq_translation") in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "configuration_file") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "CONFIGURATION_FILE") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Set_ in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and false α5)) in
        let* auto :
            M.Val
              (clap.builder.value_parser._AutoValueParser.t
                alloc.string.String.t) :=
          let* α0 :
              clap.builder.value_parser._AutoValueParser.t
                alloc.string.String.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t
                  alloc.string.String.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              alloc.string.String.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              alloc.string.String.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val
              (ref
                (clap.builder.value_parser._AutoValueParser.t
                  alloc.string.String.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref
                (ref
                  (clap.builder.value_parser._AutoValueParser.t
                    alloc.string.String.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref
                    (clap.builder.value_parser._AutoValueParser.t
                      alloc.string.String.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t
                        alloc.string.String.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          alloc.string.String.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            alloc.string.String.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.ValueParser.t :=
          M.call (α0 (borrow α6)) in
        let* α7 : M.Val clap.builder.value_parser.ValueParser.t := M.alloc α7 in
        let* α8 : clap.builder.value_parser.ValueParser.t := M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.Set_) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t := M.read (mk_str "Configuration file path") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : ref str.t := M.read (mk_str "configuration-file") in
        let* α5 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α3 α4) in
        let* α6 : ref str.t := M.read (mk_str "config") in
        let* α7 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α5 α6) in
        let* α8 : ref str.t := M.read (mk_str "coq-of-rust-config.json") in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["default_value"] α7 α8) in
        M.alloc α9 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    M.read __clap_app.
  
  Global Instance AssociatedFunction_augment_args_for_update :
    Notations.DoubleColon Self "augment_args_for_update" := {
    Notations.double_colon := augment_args_for_update;
  }.
  
  Global Instance ℐ : clap.derive.Args.Required.Trait Self := {
    clap.derive.Args.group_id := Datatypes.Some group_id;
    clap.derive.Args.augment_args := augment_args;
    clap.derive.Args.augment_args_for_update := augment_args_for_update;
  }.
End Impl_clap_derive_Args_for_coq_of_rust_Translate_t.
End Impl_clap_derive_Args_for_coq_of_rust_Translate_t.

(*
fn is_valid_path(path: &str) -> Result<PathBuf, String> {
    let target_path = Path::new(path);
    if target_path.exists() {
        Ok(target_path.to_path_buf())
    } else {
        Err(format!("Path does not exist: {path}"))
    }
}
*)
Definition is_valid_path
    (path : ref str.t)
    : M (core.result.Result.t std.path.PathBuf.t alloc.string.String.t) :=
  let* path := M.alloc path in
  let* target_path : M.Val (ref std.path.Path.t) :=
    let* α0 : ref str.t := M.read path in
    let* α1 : ref std.path.Path.t := M.call (std.path.Path.t::["new"] α0) in
    M.alloc α1 in
  let* α0 : ref std.path.Path.t := M.read target_path in
  let* α1 : bool.t := M.call (std.path.Path.t::["exists"] α0) in
  let* α2 : M.Val bool.t := M.alloc α1 in
  let* α3 : bool.t := M.read (use α2) in
  let* α0 :
      M.Val (core.result.Result.t std.path.PathBuf.t alloc.string.String.t) :=
    if α3 then
      let* α0 : ref std.path.Path.t := M.read target_path in
      let* α1 : std.path.PathBuf.t :=
        M.call (std.path.Path.t::["to_path_buf"] α0) in
      M.alloc (core.result.Result.Ok α1)
    else
      let* res : M.Val alloc.string.String.t :=
        let* α0 : ref str.t := M.read (mk_str "Path does not exist: ") in
        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
        let* α2 : core.fmt.rt.Argument.t :=
          M.call (core.fmt.rt.Argument.t::["new_display"] (borrow path)) in
        let* α3 : M.Val (array core.fmt.rt.Argument.t) := M.alloc [ α2 ] in
        let* α4 : core.fmt.Arguments.t :=
          M.call
            (core.fmt.Arguments.t::["new_v1"]
              (pointer_coercion "Unsize" (borrow α1))
              (pointer_coercion "Unsize" (borrow α3))) in
        let* α5 : alloc.string.String.t := M.call (alloc.fmt.format α4) in
        M.alloc α5 in
      let* α0 : alloc.string.String.t := M.read res in
      M.alloc (core.result.Result.Err α0) in
  M.read α0.

Module Commands.
  Inductive t : Set :=
  | Translate (_ : coq_of_rust.Translate.t).
  
  Definition Get_Translate_0 :=
    Ref.map
      (fun α => match α with | Translate α0 => Some α0 end)
      (fun β α => match α with | Translate _ => Some (Translate β) end).
End Commands.

Module  Impl_clap_derive_FromArgMatches_for_coq_of_rust_Commands_t.
Section Impl_clap_derive_FromArgMatches_for_coq_of_rust_Commands_t.
  Definition Self : Set := coq_of_rust.Commands.t.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α1 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α2 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α0 α1) in
    let* α3 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α2 in
    M.call (from_arg_matches_mut (borrow_mut α3)).
  
  Global Instance AssociatedFunction_from_arg_matches :
    Notations.DoubleColon Self "from_arg_matches" := {
    Notations.double_colon := from_arg_matches;
  }.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches_mut
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t Self ltac:(clap.Error)) in
    M.catch_return
      (let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
        M.read __clap_arg_matches in
      let* α1 :
          core.option.Option.t
            (alloc.string.String.t
            *
            clap.parser.matches.arg_matches.ArgMatches.t) :=
        M.call
          (clap.parser.matches.arg_matches.ArgMatches.t::["remove_subcommand"]
            α0) in
      let* α2 :
          M.Val
            (core.option.Option.t
              (alloc.string.String.t
              *
              clap.parser.matches.arg_matches.ArgMatches.t)) :=
        M.alloc α1 in
      let* α3 :
          M.Val
            (core.result.Result.t
              coq_of_rust.Commands.t
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        match_operator
          α2
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let* α0 := M.read γ0_0 in
                match α0 with
                | (_, _) =>
                  let γ1_0 := Tuple.Access.left γ0_0 in
                  let γ1_1 := Tuple.Access.right γ0_0 in
                  let* __clap_name := M.copy γ1_0 in
                  let* __clap_arg_sub_matches := M.copy γ1_1 in
                  let* __clap_arg_matches :
                      M.Val
                        (mut_ref
                          clap.parser.matches.arg_matches.ArgMatches.t) :=
                    M.alloc (borrow_mut __clap_arg_sub_matches) in
                  let* _ : M.Val unit :=
                    let* α0 :
                        (ref alloc.string.String.t) ->
                          (ref (ref str.t)) ->
                          M bool.t :=
                      ltac:(M.get_method (fun ℐ =>
                        core.cmp.PartialEq.eq
                          (Self := alloc.string.String.t)
                          (Rhs := ref str.t)
                          (Trait := ℐ))) in
                    let* α1 : bool.t :=
                      M.call
                        (α0
                          (borrow __clap_name)
                          (borrow (mk_str "translate"))) in
                    let* α2 :
                        mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
                      M.read __clap_arg_matches in
                    let* α3 : ref str.t := M.read (mk_str "") in
                    let* α4 : bool.t :=
                      M.call
                        (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
                          (borrow (deref α2))
                          α3) in
                    let* α5 : M.Val bool.t :=
                      M.alloc (BinOp.Pure.and α1 (UnOp.not α4)) in
                    let* α6 : bool.t := M.read (use α5) in
                    if α6 then
                      let* α0 :
                          (core.result.Result.t
                              coq_of_rust.Translate.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                            ->
                            M (core.ops.control_flow.ControlFlow.t _ _) :=
                        ltac:(M.get_method (fun ℐ =>
                          core.ops.try_trait.Try.branch
                            (Self :=
                              core.result.Result.t
                                coq_of_rust.Translate.t
                                (clap.error.Error.t
                                  clap.error.format.RichFormatter.t))
                            (Trait := ℐ))) in
                      let* α1 :
                          (mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
                            ->
                            M
                              (core.result.Result.t
                                coq_of_rust.Translate.t
                                (clap.error.Error.t
                                  clap.error.format.RichFormatter.t)) :=
                        ltac:(M.get_method (fun ℐ =>
                          clap.derive.FromArgMatches.from_arg_matches_mut
                            (Self := coq_of_rust.Translate.t)
                            (Trait := ℐ))) in
                      let* α2 :
                          mut_ref
                            clap.parser.matches.arg_matches.ArgMatches.t :=
                        M.read __clap_arg_matches in
                      let* α3 :
                          core.result.Result.t
                            coq_of_rust.Translate.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t) :=
                        M.call (α1 α2) in
                      let* α4 :
                          core.ops.control_flow.ControlFlow.t
                            (core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                            coq_of_rust.Translate.t :=
                        M.call (α0 α3) in
                      let* α5 :
                          M.Val
                            (core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                (clap.error.Error.t
                                  clap.error.format.RichFormatter.t))
                              coq_of_rust.Translate.t) :=
                        M.alloc α4 in
                      let* α6 : M.Val coq_of_rust.Translate.t :=
                        match_operator
                          α5
                          [
                            fun γ =>
                              (let* α0 := M.read γ in
                              match α0 with
                              | core.ops.control_flow.ControlFlow.Break _ =>
                                let γ0_0 :=
                                  core.ops.control_flow.ControlFlow.Get_Break_0
                                    γ in
                                let* residual := M.copy γ0_0 in
                                let* α0 :
                                    (core.result.Result.t
                                        core.convert.Infallible.t
                                        (clap.error.Error.t
                                          clap.error.format.RichFormatter.t))
                                      ->
                                      M
                                        (core.result.Result.t
                                          coq_of_rust.Commands.t
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t)) :=
                                  ltac:(M.get_method (fun ℐ =>
                                    core.ops.try_trait.FromResidual.from_residual
                                      (Self :=
                                        core.result.Result.t
                                          coq_of_rust.Commands.t
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t))
                                      (R :=
                                        core.result.Result.t
                                          core.convert.Infallible.t
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t))
                                      (Trait := ℐ))) in
                                let* α1 :
                                    core.result.Result.t
                                      core.convert.Infallible.t
                                      (clap.error.Error.t
                                        clap.error.format.RichFormatter.t) :=
                                  M.read residual in
                                let* α2 :
                                    core.result.Result.t
                                      coq_of_rust.Commands.t
                                      (clap.error.Error.t
                                        clap.error.format.RichFormatter.t) :=
                                  M.call (α0 α1) in
                                let* α3 : M.Val never.t := return_ α2 in
                                let* α4 := M.read α3 in
                                let* α5 : coq_of_rust.Translate.t :=
                                  never_to_any α4 in
                                M.alloc α5
                              | _ => M.break_match
                              end) :
                              M (M.Val coq_of_rust.Translate.t);
                            fun γ =>
                              (let* α0 := M.read γ in
                              match α0 with
                              | core.ops.control_flow.ControlFlow.Continue _ =>
                                let γ0_0 :=
                                  core.ops.control_flow.ControlFlow.Get_Continue_0
                                    γ in
                                let* val := M.copy γ0_0 in
                                M.pure val
                              | _ => M.break_match
                              end) :
                              M (M.Val coq_of_rust.Translate.t)
                          ] in
                      let* α7 : coq_of_rust.Translate.t := M.read α6 in
                      let* α8 : M.Val never.t :=
                        return_
                          (core.result.Result.Ok
                            (coq_of_rust.Commands.Translate α7)) in
                      let* α9 := M.read α8 in
                      let* α10 : unit := never_to_any α9 in
                      M.alloc α10
                    else
                      M.alloc tt in
                  let* res : M.Val alloc.string.String.t :=
                    let* α0 : ref str.t := M.read (mk_str "The subcommand '") in
                    let* α1 : ref str.t :=
                      M.read (mk_str "' wasn't recognized") in
                    let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
                    let* α3 : core.fmt.rt.Argument.t :=
                      M.call
                        (core.fmt.rt.Argument.t::["new_display"]
                          (borrow __clap_name)) in
                    let* α4 : M.Val (array core.fmt.rt.Argument.t) :=
                      M.alloc [ α3 ] in
                    let* α5 : core.fmt.Arguments.t :=
                      M.call
                        (core.fmt.Arguments.t::["new_v1"]
                          (pointer_coercion "Unsize" (borrow α2))
                          (pointer_coercion "Unsize" (borrow α4))) in
                    let* α6 : alloc.string.String.t :=
                      M.call (alloc.fmt.format α5) in
                    M.alloc α6 in
                  let* α0 : alloc.string.String.t := M.read res in
                  let* α1 :
                      clap.error.Error.t clap.error.format.RichFormatter.t :=
                    M.call
                      ((clap.error.Error.t
                            clap.error.format.RichFormatter.t)::["raw"]
                        clap.error.kind.ErrorKind.InvalidSubcommand
                        α0) in
                  M.alloc (core.result.Result.Err α1)
                end
              | _ => M.break_match
              end) :
              M
                (M.Val
                  (core.result.Result.t
                    coq_of_rust.Commands.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t)));
            fun γ =>
              (let* α0 : ref str.t :=
                M.read
                  (mk_str
                    "A subcommand is required but one was not provided.") in
              let* α1 : clap.error.Error.t clap.error.format.RichFormatter.t :=
                M.call
                  ((clap.error.Error.t
                        clap.error.format.RichFormatter.t)::["raw"]
                    clap.error.kind.ErrorKind.MissingSubcommand
                    α0) in
              M.alloc (core.result.Result.Err α1)) :
              M
                (M.Val
                  (core.result.Result.t
                    coq_of_rust.Commands.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t)))
          ] in
      M.read α3).
  
  Global Instance AssociatedFunction_from_arg_matches_mut :
    Notations.DoubleColon Self "from_arg_matches_mut" := {
    Notations.double_colon := from_arg_matches_mut;
  }.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches
      (self : mut_ref Self)
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 : mut_ref coq_of_rust.Commands.t := M.read self in
    let* α1 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α2 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α3 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α1 α2) in
    let* α4 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α3 in
    M.call (update_from_arg_matches_mut α0 (borrow_mut α4)).
  
  Global Instance AssociatedFunction_update_from_arg_matches :
    Notations.DoubleColon Self "update_from_arg_matches" := {
    Notations.double_colon := update_from_arg_matches;
  }.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches_mut
      (self : mut_ref Self)
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t unit ltac:(clap.Error)) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : core.option.Option.t (ref str.t) :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["subcommand_name"]
              (borrow (deref α0))) in
        let* α2 : M.Val (core.option.Option.t (ref str.t)) := M.alloc α1 in
        match_operator
          α2
          [
            fun γ =>
              (let* α0 := M.read γ in
              match α0 with
              | core.option.Option.Some _ =>
                let γ0_0 := core.option.Option.Get_Some_0 γ in
                let* __clap_name := M.copy γ0_0 in
                match_operator
                  self
                  [
                    fun γ =>
                      (let* γ :=
                        let* α0 := M.read γ in
                        M.pure (deref α0) in
                      let* α0 := M.read γ in
                      match α0 with
                      | coq_of_rust.Commands.Translate _ =>
                        let γ1_0 := coq_of_rust.Commands.Get_Translate_0 γ in
                        let* __clap_arg := M.alloc (borrow_mut γ1_0) in
                        let* α0 :
                            mut_ref
                              clap.parser.matches.arg_matches.ArgMatches.t :=
                          M.read __clap_arg_matches in
                        let* α1 :
                            core.option.Option.t
                              (alloc.string.String.t
                              *
                              clap.parser.matches.arg_matches.ArgMatches.t) :=
                          M.call
                            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_subcommand"]
                              α0) in
                        let* α2 :
                            alloc.string.String.t
                            *
                            clap.parser.matches.arg_matches.ArgMatches.t :=
                          M.call
                            ((core.option.Option.t
                                  (alloc.string.String.t
                                  *
                                  clap.parser.matches.arg_matches.ArgMatches.t))::["unwrap"]
                              α1) in
                        let* α3 :
                            M.Val
                              (alloc.string.String.t
                              *
                              clap.parser.matches.arg_matches.ArgMatches.t) :=
                          M.alloc α2 in
                        match_operator
                          α3
                          [
                            fun γ =>
                              (let* α0 := M.read γ in
                              match α0 with
                              | (_, _) =>
                                let γ0_0 := Tuple.Access.left γ in
                                let γ0_1 := Tuple.Access.right γ in
                                let* __clap_arg_sub_matches := M.copy γ0_1 in
                                let* __clap_arg_matches :
                                    M.Val
                                      (mut_ref
                                        clap.parser.matches.arg_matches.ArgMatches.t) :=
                                  M.alloc (borrow_mut __clap_arg_sub_matches) in
                                let* α0 :
                                    (core.result.Result.t
                                        unit
                                        (clap.error.Error.t
                                          clap.error.format.RichFormatter.t))
                                      ->
                                      M
                                        (core.ops.control_flow.ControlFlow.t
                                          _
                                          _) :=
                                  ltac:(M.get_method (fun ℐ =>
                                    core.ops.try_trait.Try.branch
                                      (Self :=
                                        core.result.Result.t
                                          unit
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t))
                                      (Trait := ℐ))) in
                                let* α1 :
                                    (mut_ref coq_of_rust.Translate.t) ->
                                      (mut_ref
                                        clap.parser.matches.arg_matches.ArgMatches.t)
                                      ->
                                      M
                                        (core.result.Result.t
                                          unit
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t)) :=
                                  ltac:(M.get_method (fun ℐ =>
                                    clap.derive.FromArgMatches.update_from_arg_matches_mut
                                      (Self := coq_of_rust.Translate.t)
                                      (Trait := ℐ))) in
                                let* α2 : mut_ref coq_of_rust.Translate.t :=
                                  M.read __clap_arg in
                                let* α3 :
                                    mut_ref
                                      clap.parser.matches.arg_matches.ArgMatches.t :=
                                  M.read __clap_arg_matches in
                                let* α4 :
                                    core.result.Result.t
                                      unit
                                      (clap.error.Error.t
                                        clap.error.format.RichFormatter.t) :=
                                  M.call (α1 α2 α3) in
                                let* α5 :
                                    core.ops.control_flow.ControlFlow.t
                                      (core.result.Result.t
                                        core.convert.Infallible.t
                                        (clap.error.Error.t
                                          clap.error.format.RichFormatter.t))
                                      unit :=
                                  M.call (α0 α4) in
                                let* α6 :
                                    M.Val
                                      (core.ops.control_flow.ControlFlow.t
                                        (core.result.Result.t
                                          core.convert.Infallible.t
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t))
                                        unit) :=
                                  M.alloc α5 in
                                match_operator
                                  α6
                                  [
                                    fun γ =>
                                      (let* α0 := M.read γ in
                                      match α0 with
                                      |
                                          core.ops.control_flow.ControlFlow.Break
                                            _
                                          =>
                                        let γ0_0 :=
                                          core.ops.control_flow.ControlFlow.Get_Break_0
                                            γ in
                                        let* residual := M.copy γ0_0 in
                                        let* α0 :
                                            (core.result.Result.t
                                                core.convert.Infallible.t
                                                (clap.error.Error.t
                                                  clap.error.format.RichFormatter.t))
                                              ->
                                              M
                                                (core.result.Result.t
                                                  unit
                                                  (clap.error.Error.t
                                                    clap.error.format.RichFormatter.t)) :=
                                          ltac:(M.get_method (fun ℐ =>
                                            core.ops.try_trait.FromResidual.from_residual
                                              (Self :=
                                                core.result.Result.t
                                                  unit
                                                  (clap.error.Error.t
                                                    clap.error.format.RichFormatter.t))
                                              (R :=
                                                core.result.Result.t
                                                  core.convert.Infallible.t
                                                  (clap.error.Error.t
                                                    clap.error.format.RichFormatter.t))
                                              (Trait := ℐ))) in
                                        let* α1 :
                                            core.result.Result.t
                                              core.convert.Infallible.t
                                              (clap.error.Error.t
                                                clap.error.format.RichFormatter.t) :=
                                          M.read residual in
                                        let* α2 :
                                            core.result.Result.t
                                              unit
                                              (clap.error.Error.t
                                                clap.error.format.RichFormatter.t) :=
                                          M.call (α0 α1) in
                                        let* α3 : M.Val never.t := return_ α2 in
                                        let* α4 := M.read α3 in
                                        let* α5 : unit := never_to_any α4 in
                                        M.alloc α5
                                      | _ => M.break_match
                                      end) :
                                      M (M.Val unit);
                                    fun γ =>
                                      (let* α0 := M.read γ in
                                      match α0 with
                                      |
                                          core.ops.control_flow.ControlFlow.Continue
                                            _
                                          =>
                                        let γ0_0 :=
                                          core.ops.control_flow.ControlFlow.Get_Continue_0
                                            γ in
                                        let* val := M.copy γ0_0 in
                                        M.pure val
                                      | _ => M.break_match
                                      end) :
                                      M (M.Val unit)
                                  ]
                              end) :
                              M (M.Val unit)
                          ]
                      end) :
                      M (M.Val unit);
                    fun γ =>
                      (let* s := M.copy γ in
                      let* _ : M.Val unit :=
                        let* α0 : mut_ref coq_of_rust.Commands.t := M.read s in
                        let* α1 :
                            (core.result.Result.t
                                coq_of_rust.Commands.t
                                (clap.error.Error.t
                                  clap.error.format.RichFormatter.t))
                              ->
                              M (core.ops.control_flow.ControlFlow.t _ _) :=
                          ltac:(M.get_method (fun ℐ =>
                            core.ops.try_trait.Try.branch
                              (Self :=
                                core.result.Result.t
                                  coq_of_rust.Commands.t
                                  (clap.error.Error.t
                                    clap.error.format.RichFormatter.t))
                              (Trait := ℐ))) in
                        let* α2 :
                            mut_ref
                              clap.parser.matches.arg_matches.ArgMatches.t :=
                          M.read __clap_arg_matches in
                        let* α3 :
                            core.result.Result.t
                              coq_of_rust.Commands.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t) :=
                          M.call (from_arg_matches_mut α2) in
                        let* α4 :
                            core.ops.control_flow.ControlFlow.t
                              (core.result.Result.t
                                core.convert.Infallible.t
                                (clap.error.Error.t
                                  clap.error.format.RichFormatter.t))
                              coq_of_rust.Commands.t :=
                          M.call (α1 α3) in
                        let* α5 :
                            M.Val
                              (core.ops.control_flow.ControlFlow.t
                                (core.result.Result.t
                                  core.convert.Infallible.t
                                  (clap.error.Error.t
                                    clap.error.format.RichFormatter.t))
                                coq_of_rust.Commands.t) :=
                          M.alloc α4 in
                        let* α6 : M.Val coq_of_rust.Commands.t :=
                          match_operator
                            α5
                            [
                              fun γ =>
                                (let* α0 := M.read γ in
                                match α0 with
                                | core.ops.control_flow.ControlFlow.Break _ =>
                                  let γ0_0 :=
                                    core.ops.control_flow.ControlFlow.Get_Break_0
                                      γ in
                                  let* residual := M.copy γ0_0 in
                                  let* α0 :
                                      (core.result.Result.t
                                          core.convert.Infallible.t
                                          (clap.error.Error.t
                                            clap.error.format.RichFormatter.t))
                                        ->
                                        M
                                          (core.result.Result.t
                                            unit
                                            (clap.error.Error.t
                                              clap.error.format.RichFormatter.t)) :=
                                    ltac:(M.get_method (fun ℐ =>
                                      core.ops.try_trait.FromResidual.from_residual
                                        (Self :=
                                          core.result.Result.t
                                            unit
                                            (clap.error.Error.t
                                              clap.error.format.RichFormatter.t))
                                        (R :=
                                          core.result.Result.t
                                            core.convert.Infallible.t
                                            (clap.error.Error.t
                                              clap.error.format.RichFormatter.t))
                                        (Trait := ℐ))) in
                                  let* α1 :
                                      core.result.Result.t
                                        core.convert.Infallible.t
                                        (clap.error.Error.t
                                          clap.error.format.RichFormatter.t) :=
                                    M.read residual in
                                  let* α2 :
                                      core.result.Result.t
                                        unit
                                        (clap.error.Error.t
                                          clap.error.format.RichFormatter.t) :=
                                    M.call (α0 α1) in
                                  let* α3 : M.Val never.t := return_ α2 in
                                  let* α4 := M.read α3 in
                                  let* α5 : coq_of_rust.Commands.t :=
                                    never_to_any α4 in
                                  M.alloc α5
                                | _ => M.break_match
                                end) :
                                M (M.Val coq_of_rust.Commands.t);
                              fun γ =>
                                (let* α0 := M.read γ in
                                match α0 with
                                |
                                    core.ops.control_flow.ControlFlow.Continue _
                                    =>
                                  let γ0_0 :=
                                    core.ops.control_flow.ControlFlow.Get_Continue_0
                                      γ in
                                  let* val := M.copy γ0_0 in
                                  M.pure val
                                | _ => M.break_match
                                end) :
                                M (M.Val coq_of_rust.Commands.t)
                            ] in
                        let* α7 : coq_of_rust.Commands.t := M.read α6 in
                        assign (deref α0) α7 in
                      M.alloc tt) :
                      M (M.Val unit)
                  ]
              | _ => M.break_match
              end) :
              M (M.Val unit);
            fun γ => (M.alloc tt) : M (M.Val unit)
          ] in
      let* α0 :
          M.Val
            (core.result.Result.t
              unit
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_update_from_arg_matches_mut :
    Notations.DoubleColon Self "update_from_arg_matches_mut" := {
    Notations.double_colon := update_from_arg_matches_mut;
  }.
  
  Global Instance ℐ : clap.derive.FromArgMatches.Required.Trait Self := {
    clap.derive.FromArgMatches.from_arg_matches := from_arg_matches;
    clap.derive.FromArgMatches.from_arg_matches_mut :=
      Datatypes.Some from_arg_matches_mut;
    clap.derive.FromArgMatches.update_from_arg_matches :=
      update_from_arg_matches;
    clap.derive.FromArgMatches.update_from_arg_matches_mut :=
      Datatypes.Some update_from_arg_matches_mut;
  }.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Commands_t.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Commands_t.

Module  Impl_clap_derive_Subcommand_for_coq_of_rust_Commands_t.
Section Impl_clap_derive_Subcommand_for_coq_of_rust_Commands_t.
  Definition Self : Set := coq_of_rust.Commands.t.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_subcommands
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      M.copy __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        let* α0 : ref str.t := M.read (mk_str "translate") in
        let* α1 : clap.builder.command.Command.t :=
          M.call (clap.builder.command.Command.t::["new"] α0) in
        M.alloc α1 in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        M.copy __clap_subcommand in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        let* α0 :
            clap.builder.command.Command.t ->
              M clap.builder.command.Command.t :=
          ltac:(M.get_method (fun ℐ =>
            clap.derive.Args.augment_args
              (Self := coq_of_rust.Translate.t)
              (Trait := ℐ))) in
        let* α1 : clap.builder.command.Command.t := M.read __clap_subcommand in
        let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
        M.alloc α2 in
      let* α0 : clap.builder.command.Command.t := M.read __clap_subcommand in
      let* α1 : ref str.t :=
        M.read (mk_str "Translate rust files to coq files") in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["about"] α0 α1) in
      let* α3 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["long_about"]
            α2
            core.option.Option.None) in
      let* α1 : M.Val clap.builder.command.Command.t := M.alloc α3 in
      let* α2 : clap.builder.command.Command.t := M.read α1 in
      let* α3 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["subcommand"] α0 α2) in
      M.alloc α3 in
    M.read __clap_app.
  
  Global Instance AssociatedFunction_augment_subcommands :
    Notations.DoubleColon Self "augment_subcommands" := {
    Notations.double_colon := augment_subcommands;
  }.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_subcommands_for_update
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      M.copy __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        let* α0 : ref str.t := M.read (mk_str "translate") in
        let* α1 : clap.builder.command.Command.t :=
          M.call (clap.builder.command.Command.t::["new"] α0) in
        M.alloc α1 in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        M.copy __clap_subcommand in
      let* __clap_subcommand : M.Val clap.builder.command.Command.t :=
        let* α0 :
            clap.builder.command.Command.t ->
              M clap.builder.command.Command.t :=
          ltac:(M.get_method (fun ℐ =>
            clap.derive.Args.augment_args_for_update
              (Self := coq_of_rust.Translate.t)
              (Trait := ℐ))) in
        let* α1 : clap.builder.command.Command.t := M.read __clap_subcommand in
        let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
        M.alloc α2 in
      let* α0 : clap.builder.command.Command.t := M.read __clap_subcommand in
      let* α1 : ref str.t :=
        M.read (mk_str "Translate rust files to coq files") in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["about"] α0 α1) in
      let* α3 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["long_about"]
            α2
            core.option.Option.None) in
      let* α1 : M.Val clap.builder.command.Command.t := M.alloc α3 in
      let* α2 : clap.builder.command.Command.t := M.read α1 in
      let* α3 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["subcommand"] α0 α2) in
      M.alloc α3 in
    M.read __clap_app.
  
  Global Instance AssociatedFunction_augment_subcommands_for_update :
    Notations.DoubleColon Self "augment_subcommands_for_update" := {
    Notations.double_colon := augment_subcommands_for_update;
  }.
  
  (*
  Subcommand
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition has_subcommand (__clap_name : ref str.t) : M bool.t :=
    let* __clap_name := M.alloc __clap_name in
    let return_ := M.return_ (R := bool.t) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* α0 : (ref (ref str.t)) -> (ref (ref str.t)) -> M bool.t :=
          ltac:(M.get_method (fun ℐ =>
            core.cmp.PartialEq.eq
              (Self := ref str.t)
              (Rhs := ref str.t)
              (Trait := ℐ))) in
        let* α1 : bool.t :=
          M.call (α0 (borrow (mk_str "translate")) (borrow __clap_name)) in
        let* α2 : M.Val bool.t := M.alloc α1 in
        let* α3 : bool.t := M.read (use α2) in
        if α3 then
          let* α0 : M.Val never.t := return_ true in
          let* α1 := M.read α0 in
          let* α2 : unit := never_to_any α1 in
          M.alloc α2
        else
          M.alloc tt in
      let* α0 : M.Val bool.t := M.alloc false in
      M.read α0).
  
  Global Instance AssociatedFunction_has_subcommand :
    Notations.DoubleColon Self "has_subcommand" := {
    Notations.double_colon := has_subcommand;
  }.
  
  Global Instance ℐ : clap.derive.Subcommand.Trait Self := {
    clap.derive.Subcommand.augment_subcommands := augment_subcommands;
    clap.derive.Subcommand.augment_subcommands_for_update :=
      augment_subcommands_for_update;
    clap.derive.Subcommand.has_subcommand := has_subcommand;
  }.
End Impl_clap_derive_Subcommand_for_coq_of_rust_Commands_t.
End Impl_clap_derive_Subcommand_for_coq_of_rust_Commands_t.

Module  Cli.
Section Cli.
  Record t : Set := {
    command : coq_of_rust.Commands.t;
    debug : u8.t;
  }.
  
  Definition Get_command :=
    Ref.map
      (fun α => Some α.(command))
      (fun β α => Some (α <| command := β |>)).
  Definition Get_debug :=
    Ref.map (fun α => Some α.(debug)) (fun β α => Some (α <| debug := β |>)).
End Cli.
End Cli.

Module  Impl_clap_derive_Parser_for_coq_of_rust_Cli_t.
Section Impl_clap_derive_Parser_for_coq_of_rust_Cli_t.
  Definition Self : Set := coq_of_rust.Cli.t.
  
  Global Instance ℐ : clap.derive.Parser.Required.Trait Self := {
    clap.derive.Parser.parse := Datatypes.None;
    clap.derive.Parser.try_parse := Datatypes.None;
    clap.derive.Parser.parse_from := Datatypes.None;
    clap.derive.Parser.try_parse_from := Datatypes.None;
    clap.derive.Parser.update_from := Datatypes.None;
    clap.derive.Parser.try_update_from := Datatypes.None;
  }.
End Impl_clap_derive_Parser_for_coq_of_rust_Cli_t.
End Impl_clap_derive_Parser_for_coq_of_rust_Cli_t.

Module  Impl_clap_derive_CommandFactory_for_coq_of_rust_Cli_t.
Section Impl_clap_derive_CommandFactory_for_coq_of_rust_Cli_t.
  Definition Self : Set := coq_of_rust.Cli.t.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition command : M clap.builder.command.Command.t :=
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : ref str.t := M.read (mk_str "coq_of_rust_cli") in
      let* α1 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["new"] α0) in
      M.alloc α1 in
    let* α0 :
        clap.builder.command.Command.t -> M clap.builder.command.Command.t :=
      ltac:(M.get_method (fun ℐ =>
        clap.derive.Args.augment_args
          (Self := coq_of_rust.Cli.t)
          (Trait := ℐ))) in
    let* α1 : clap.builder.command.Command.t := M.read __clap_app in
    let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
    let* α0 : M.Val clap.builder.command.Command.t := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_command :
    Notations.DoubleColon Self "command" := {
    Notations.double_colon := command;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition command_for_update : M clap.builder.command.Command.t :=
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : ref str.t := M.read (mk_str "coq_of_rust_cli") in
      let* α1 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["new"] α0) in
      M.alloc α1 in
    let* α0 :
        clap.builder.command.Command.t -> M clap.builder.command.Command.t :=
      ltac:(M.get_method (fun ℐ =>
        clap.derive.Args.augment_args_for_update
          (Self := coq_of_rust.Cli.t)
          (Trait := ℐ))) in
    let* α1 : clap.builder.command.Command.t := M.read __clap_app in
    let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
    let* α0 : M.Val clap.builder.command.Command.t := M.alloc α2 in
    M.read α0.
  
  Global Instance AssociatedFunction_command_for_update :
    Notations.DoubleColon Self "command_for_update" := {
    Notations.double_colon := command_for_update;
  }.
  
  Global Instance ℐ : clap.derive.CommandFactory.Trait Self := {
    clap.derive.CommandFactory.command := command;
    clap.derive.CommandFactory.command_for_update := command_for_update;
  }.
End Impl_clap_derive_CommandFactory_for_coq_of_rust_Cli_t.
End Impl_clap_derive_CommandFactory_for_coq_of_rust_Cli_t.

Module  Impl_clap_derive_FromArgMatches_for_coq_of_rust_Cli_t.
Section Impl_clap_derive_FromArgMatches_for_coq_of_rust_Cli_t.
  Definition Self : Set := coq_of_rust.Cli.t.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α1 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α2 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α0 α1) in
    let* α3 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α2 in
    M.call (from_arg_matches_mut (borrow_mut α3)).
  
  Global Instance AssociatedFunction_from_arg_matches :
    Notations.DoubleColon Self "from_arg_matches" := {
    Notations.double_colon := from_arg_matches;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition from_arg_matches_mut
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t Self ltac:(clap.Error)) :=
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t Self ltac:(clap.Error)) in
    M.catch_return
      (let* v : M.Val coq_of_rust.Cli.t :=
        let* α0 :
            (core.result.Result.t
                coq_of_rust.Commands.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  coq_of_rust.Commands.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α1 :
            (mut_ref clap.parser.matches.arg_matches.ArgMatches.t) ->
              M
                (core.result.Result.t
                  coq_of_rust.Commands.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
          ltac:(M.get_method (fun ℐ =>
            clap.derive.FromArgMatches.from_arg_matches_mut
              (Self := coq_of_rust.Commands.t)
              (Trait := ℐ))) in
        let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α3 :
            core.result.Result.t
              coq_of_rust.Commands.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call (α1 α2) in
        let* α4 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              coq_of_rust.Commands.t :=
          M.call (α0 α3) in
        let* α5 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                coq_of_rust.Commands.t) :=
          M.alloc α4 in
        let* α6 : M.Val coq_of_rust.Commands.t :=
          match_operator
            α5
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Cli.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Cli.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Cli.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : coq_of_rust.Commands.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val coq_of_rust.Commands.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val coq_of_rust.Commands.t)
            ] in
        let* α7 : coq_of_rust.Commands.t := M.read α6 in
        let* α8 :
            (core.result.Result.t
                u8.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              ->
              M (core.ops.control_flow.ControlFlow.t _ _) :=
          ltac:(M.get_method (fun ℐ =>
            core.ops.try_trait.Try.branch
              (Self :=
                core.result.Result.t
                  u8.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
              (Trait := ℐ))) in
        let* α9 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α10 : ref str.t := M.read (mk_str "debug") in
        let* α11 : core.option.Option.t u8.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
              α9
              α10) in
        let* α12 :
            core.result.Result.t
              u8.t
              (clap.error.Error.t clap.error.format.RichFormatter.t) :=
          M.call
            ((core.option.Option.t u8.t)::["ok_or_else"]
              α11
              (fun (α0 : unit) =>
                (let* α0 := M.alloc α0 in
                match_operator
                  α0
                  [
                    fun γ =>
                      (let* res : M.Val alloc.string.String.t :=
                        let* α0 : ref str.t :=
                          M.read
                            (mk_str
                              "The following required argument was not provided: debug") in
                        let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                        let* α2 : array core.fmt.rt.Argument.t :=
                          M.call core.fmt.rt.Argument.t::["none"] in
                        let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                          M.alloc α2 in
                        let* α4 : core.fmt.Arguments.t :=
                          M.call
                            (core.fmt.Arguments.t::["new_v1"]
                              (pointer_coercion "Unsize" (borrow α1))
                              (pointer_coercion "Unsize" (borrow α3))) in
                        let* α5 : alloc.string.String.t :=
                          M.call (alloc.fmt.format α4) in
                        M.alloc α5 in
                      let* α0 : alloc.string.String.t := M.read res in
                      M.call
                        ((clap.error.Error.t
                              clap.error.format.RichFormatter.t)::["raw"]
                          clap.error.kind.ErrorKind.MissingRequiredArgument
                          α0)) :
                      M (clap.error.Error.t clap.error.format.RichFormatter.t)
                  ]) :
                M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
        let* α13 :
            core.ops.control_flow.ControlFlow.t
              (core.result.Result.t
                core.convert.Infallible.t
                (clap.error.Error.t clap.error.format.RichFormatter.t))
              u8.t :=
          M.call (α8 α12) in
        let* α14 :
            M.Val
              (core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                u8.t) :=
          M.alloc α13 in
        let* α15 : M.Val u8.t :=
          match_operator
            α14
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            coq_of_rust.Cli.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            coq_of_rust.Cli.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        coq_of_rust.Cli.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : u8.t := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val u8.t);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val u8.t)
            ] in
        let* α16 : u8.t := M.read α15 in
        M.alloc
          {| coq_of_rust.Cli.command := α7; coq_of_rust.Cli.debug := α16; |} in
      let* α0 : coq_of_rust.Cli.t := M.read v in
      let* α0 :
          M.Val
            (core.result.Result.t
              coq_of_rust.Cli.t
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        M.alloc (core.result.Result.Ok α0) in
      M.read α0).
  
  Global Instance AssociatedFunction_from_arg_matches_mut :
    Notations.DoubleColon Self "from_arg_matches_mut" := {
    Notations.double_colon := from_arg_matches_mut;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches
      (self : mut_ref Self)
      (__clap_arg_matches : ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let* α0 : mut_ref coq_of_rust.Cli.t := M.read self in
    let* α1 :
        (ref clap.parser.matches.arg_matches.ArgMatches.t) ->
          M clap.parser.matches.arg_matches.ArgMatches.t :=
      ltac:(M.get_method (fun ℐ =>
        core.clone.Clone.clone
          (Self := clap.parser.matches.arg_matches.ArgMatches.t)
          (Trait := ℐ))) in
    let* α2 : ref clap.parser.matches.arg_matches.ArgMatches.t :=
      M.read __clap_arg_matches in
    let* α3 : clap.parser.matches.arg_matches.ArgMatches.t := M.call (α1 α2) in
    let* α4 : M.Val clap.parser.matches.arg_matches.ArgMatches.t :=
      M.alloc α3 in
    M.call (update_from_arg_matches_mut α0 (borrow_mut α4)).
  
  Global Instance AssociatedFunction_update_from_arg_matches :
    Notations.DoubleColon Self "update_from_arg_matches" := {
    Notations.double_colon := update_from_arg_matches;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition update_from_arg_matches_mut
      (self : mut_ref Self)
      (__clap_arg_matches
        :
        mut_ref clap.parser.matches.arg_matches.ArgMatches.t)
      : M (core.result.Result.t unit ltac:(clap.Error)) :=
    let* self := M.alloc self in
    let* __clap_arg_matches := M.alloc __clap_arg_matches in
    let return_ :=
      M.return_ (R := core.result.Result.t unit ltac:(clap.Error)) in
    M.catch_return
      (let* _ : M.Val unit :=
        let* command : M.Val (mut_ref coq_of_rust.Commands.t) :=
          let* α0 : mut_ref coq_of_rust.Cli.t := M.read self in
          M.alloc (borrow_mut (coq_of_rust.Cli.Get_command (deref α0))) in
        let* _ : M.Val unit :=
          let* α0 :
              (core.result.Result.t
                  unit
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    unit
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α1 :
              (mut_ref coq_of_rust.Commands.t) ->
                (mut_ref clap.parser.matches.arg_matches.ArgMatches.t) ->
                M
                  (core.result.Result.t
                    unit
                    (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
            ltac:(M.get_method (fun ℐ =>
              clap.derive.FromArgMatches.update_from_arg_matches_mut
                (Self := coq_of_rust.Commands.t)
                (Trait := ℐ))) in
          let* α2 : mut_ref coq_of_rust.Commands.t := M.read command in
          let* α3 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α4 :
              core.result.Result.t
                unit
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call (α1 α2 α3) in
          let* α5 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                unit :=
            M.call (α0 α4) in
          let* α6 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  unit) :=
            M.alloc α5 in
          match_operator
            α6
            [
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Break _ =>
                  let γ0_0 := core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                  let* residual := M.copy γ0_0 in
                  let* α0 :
                      (core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t))
                        ->
                        M
                          (core.result.Result.t
                            unit
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t)) :=
                    ltac:(M.get_method (fun ℐ =>
                      core.ops.try_trait.FromResidual.from_residual
                        (Self :=
                          core.result.Result.t
                            unit
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (R :=
                          core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                        (Trait := ℐ))) in
                  let* α1 :
                      core.result.Result.t
                        core.convert.Infallible.t
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.read residual in
                  let* α2 :
                      core.result.Result.t
                        unit
                        (clap.error.Error.t
                          clap.error.format.RichFormatter.t) :=
                    M.call (α0 α1) in
                  let* α3 : M.Val never.t := return_ α2 in
                  let* α4 := M.read α3 in
                  let* α5 : unit := never_to_any α4 in
                  M.alloc α5
                | _ => M.break_match
                end) :
                M (M.Val unit);
              fun γ =>
                (let* α0 := M.read γ in
                match α0 with
                | core.ops.control_flow.ControlFlow.Continue _ =>
                  let γ0_0 :=
                    core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                  let* val := M.copy γ0_0 in
                  M.pure val
                | _ => M.break_match
                end) :
                M (M.Val unit)
            ] in
        M.alloc tt in
      let* _ : M.Val unit :=
        let* α0 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
          M.read __clap_arg_matches in
        let* α1 : ref str.t := M.read (mk_str "debug") in
        let* α2 : bool.t :=
          M.call
            (clap.parser.matches.arg_matches.ArgMatches.t::["contains_id"]
              (borrow (deref α0))
              α1) in
        let* α3 : M.Val bool.t := M.alloc α2 in
        let* α4 : bool.t := M.read (use α3) in
        if α4 then
          let* debug : M.Val (mut_ref u8.t) :=
            let* α0 : mut_ref coq_of_rust.Cli.t := M.read self in
            M.alloc (borrow_mut (coq_of_rust.Cli.Get_debug (deref α0))) in
          let* α0 : mut_ref u8.t := M.read debug in
          let* α1 :
              (core.result.Result.t
                  u8.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                ->
                M (core.ops.control_flow.ControlFlow.t _ _) :=
            ltac:(M.get_method (fun ℐ =>
              core.ops.try_trait.Try.branch
                (Self :=
                  core.result.Result.t
                    u8.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                (Trait := ℐ))) in
          let* α2 : mut_ref clap.parser.matches.arg_matches.ArgMatches.t :=
            M.read __clap_arg_matches in
          let* α3 : ref str.t := M.read (mk_str "debug") in
          let* α4 : core.option.Option.t u8.t :=
            M.call
              (clap.parser.matches.arg_matches.ArgMatches.t::["remove_one"]
                α2
                α3) in
          let* α5 :
              core.result.Result.t
                u8.t
                (clap.error.Error.t clap.error.format.RichFormatter.t) :=
            M.call
              ((core.option.Option.t u8.t)::["ok_or_else"]
                α4
                (fun (α0 : unit) =>
                  (let* α0 := M.alloc α0 in
                  match_operator
                    α0
                    [
                      fun γ =>
                        (let* res : M.Val alloc.string.String.t :=
                          let* α0 : ref str.t :=
                            M.read
                              (mk_str
                                "The following required argument was not provided: debug") in
                          let* α1 : M.Val (array (ref str.t)) :=
                            M.alloc [ α0 ] in
                          let* α2 : array core.fmt.rt.Argument.t :=
                            M.call core.fmt.rt.Argument.t::["none"] in
                          let* α3 : M.Val (array core.fmt.rt.Argument.t) :=
                            M.alloc α2 in
                          let* α4 : core.fmt.Arguments.t :=
                            M.call
                              (core.fmt.Arguments.t::["new_v1"]
                                (pointer_coercion "Unsize" (borrow α1))
                                (pointer_coercion "Unsize" (borrow α3))) in
                          let* α5 : alloc.string.String.t :=
                            M.call (alloc.fmt.format α4) in
                          M.alloc α5 in
                        let* α0 : alloc.string.String.t := M.read res in
                        M.call
                          ((clap.error.Error.t
                                clap.error.format.RichFormatter.t)::["raw"]
                            clap.error.kind.ErrorKind.MissingRequiredArgument
                            α0)) :
                        M (clap.error.Error.t clap.error.format.RichFormatter.t)
                    ]) :
                  M (clap.error.Error.t clap.error.format.RichFormatter.t))) in
          let* α6 :
              core.ops.control_flow.ControlFlow.t
                (core.result.Result.t
                  core.convert.Infallible.t
                  (clap.error.Error.t clap.error.format.RichFormatter.t))
                u8.t :=
            M.call (α1 α5) in
          let* α7 :
              M.Val
                (core.ops.control_flow.ControlFlow.t
                  (core.result.Result.t
                    core.convert.Infallible.t
                    (clap.error.Error.t clap.error.format.RichFormatter.t))
                  u8.t) :=
            M.alloc α6 in
          let* α8 : M.Val u8.t :=
            match_operator
              α7
              [
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Break _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Break_0 γ in
                    let* residual := M.copy γ0_0 in
                    let* α0 :
                        (core.result.Result.t
                            core.convert.Infallible.t
                            (clap.error.Error.t
                              clap.error.format.RichFormatter.t))
                          ->
                          M
                            (core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t)) :=
                      ltac:(M.get_method (fun ℐ =>
                        core.ops.try_trait.FromResidual.from_residual
                          (Self :=
                            core.result.Result.t
                              unit
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (R :=
                            core.result.Result.t
                              core.convert.Infallible.t
                              (clap.error.Error.t
                                clap.error.format.RichFormatter.t))
                          (Trait := ℐ))) in
                    let* α1 :
                        core.result.Result.t
                          core.convert.Infallible.t
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.read residual in
                    let* α2 :
                        core.result.Result.t
                          unit
                          (clap.error.Error.t
                            clap.error.format.RichFormatter.t) :=
                      M.call (α0 α1) in
                    let* α3 : M.Val never.t := return_ α2 in
                    let* α4 := M.read α3 in
                    let* α5 : u8.t := never_to_any α4 in
                    M.alloc α5
                  | _ => M.break_match
                  end) :
                  M (M.Val u8.t);
                fun γ =>
                  (let* α0 := M.read γ in
                  match α0 with
                  | core.ops.control_flow.ControlFlow.Continue _ =>
                    let γ0_0 :=
                      core.ops.control_flow.ControlFlow.Get_Continue_0 γ in
                    let* val := M.copy γ0_0 in
                    M.pure val
                  | _ => M.break_match
                  end) :
                  M (M.Val u8.t)
              ] in
          let* α9 : u8.t := M.read α8 in
          assign (deref α0) α9
        else
          M.alloc tt in
      let* α0 :
          M.Val
            (core.result.Result.t
              unit
              (clap.error.Error.t clap.error.format.RichFormatter.t)) :=
        M.alloc (core.result.Result.Ok tt) in
      M.read α0).
  
  Global Instance AssociatedFunction_update_from_arg_matches_mut :
    Notations.DoubleColon Self "update_from_arg_matches_mut" := {
    Notations.double_colon := update_from_arg_matches_mut;
  }.
  
  Global Instance ℐ : clap.derive.FromArgMatches.Required.Trait Self := {
    clap.derive.FromArgMatches.from_arg_matches := from_arg_matches;
    clap.derive.FromArgMatches.from_arg_matches_mut :=
      Datatypes.Some from_arg_matches_mut;
    clap.derive.FromArgMatches.update_from_arg_matches :=
      update_from_arg_matches;
    clap.derive.FromArgMatches.update_from_arg_matches_mut :=
      Datatypes.Some update_from_arg_matches_mut;
  }.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Cli_t.
End Impl_clap_derive_FromArgMatches_for_coq_of_rust_Cli_t.

Module  Impl_clap_derive_Args_for_coq_of_rust_Cli_t.
Section Impl_clap_derive_Args_for_coq_of_rust_Cli_t.
  Definition Self : Set := coq_of_rust.Cli.t.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition group_id : M (core.option.Option.t clap.util.id.Id.t) :=
    let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
      ltac:(M.get_method (fun ℐ =>
        core.convert.From.from
          (Self := clap.util.id.Id.t)
          (T := ref str.t)
          (Trait := ℐ))) in
    let* α1 : ref str.t := M.read (mk_str "Cli") in
    let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
    M.pure (core.option.Option.Some α2).
  
  Global Instance AssociatedFunction_group_id :
    Notations.DoubleColon Self "group_id" := {
    Notations.double_colon := group_id;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_args
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : ref str.t := M.read (mk_str "Cli") in
      let* α2 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["new"] α1) in
      let* α3 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["multiple"] α2 true) in
      let* members : M.Val (array clap.util.id.Id.t) :=
        let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α1 : ref str.t := M.read (mk_str "debug") in
        let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
        M.alloc [ α2 ] in
      let* α4 : array clap.util.id.Id.t := M.read members in
      let* α5 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["args"] α3 α4) in
      let* α6 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["group"] α0 α5) in
      M.alloc α6 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 :
          clap.builder.command.Command.t -> M clap.builder.command.Command.t :=
        ltac:(M.get_method (fun ℐ =>
          clap.derive.Subcommand.augment_subcommands
            (Self := coq_of_rust.Commands.t)
            (Trait := ℐ))) in
      let* α1 : clap.builder.command.Command.t := M.read __clap_app in
      let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["subcommand_required"] α0 true) in
      let* α2 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["arg_required_else_help"]
            α1
            true) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "debug") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "DEBUG") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Count in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and true α5)) in
        let* auto : M.Val (clap.builder.value_parser._AutoValueParser.t u8.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t u8.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t u8.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              u8.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              u8.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t u8.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref (ref (clap.builder.value_parser._AutoValueParser.t u8.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref (clap.builder.value_parser._AutoValueParser.t u8.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t u8.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          u8.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            u8.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.RangedI64ValueParser.t u8.t :=
          M.call (α0 (borrow α6)) in
        let* α7 :
            M.Val (clap.builder.value_parser.RangedI64ValueParser.t u8.t) :=
          M.alloc α7 in
        let* α8 : clap.builder.value_parser.RangedI64ValueParser.t u8.t :=
          M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.Count) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read (mk_str "Turn debugging information on") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["short"] α3 "d"%char) in
        let* α5 : ref str.t := M.read (mk_str "debug") in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α4 α5) in
        M.alloc α6 in
      let* arg : M.Val clap.builder.arg.Arg.t := M.copy arg in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* α0 : clap.builder.command.Command.t := M.read __clap_app in
    let* α1 : ref str.t := M.read (mk_str "0.1.0") in
    let* α2 : clap.builder.command.Command.t :=
      M.call (clap.builder.command.Command.t::["version"] α0 α1) in
    let* α3 : clap.builder.command.Command.t :=
      M.call
        (clap.builder.command.Command.t::["long_about"]
          α2
          core.option.Option.None) in
    let* α0 : M.Val clap.builder.command.Command.t := M.alloc α3 in
    M.read α0.
  
  Global Instance AssociatedFunction_augment_args :
    Notations.DoubleColon Self "augment_args" := {
    Notations.double_colon := augment_args;
  }.
  
  (*
  Parser
  *)
  (* #[allow(dead_code)] - function was ignored by the compiler *)
  Definition augment_args_for_update
      (__clap_app : clap.builder.command.Command.t)
      : M clap.builder.command.Command.t :=
    let* __clap_app := M.alloc __clap_app in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : ref str.t := M.read (mk_str "Cli") in
      let* α2 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["new"] α1) in
      let* α3 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["multiple"] α2 true) in
      let* members : M.Val (array clap.util.id.Id.t) :=
        let* α0 : (ref str.t) -> M clap.util.id.Id.t :=
          ltac:(M.get_method (fun ℐ =>
            core.convert.From.from
              (Self := clap.util.id.Id.t)
              (T := ref str.t)
              (Trait := ℐ))) in
        let* α1 : ref str.t := M.read (mk_str "debug") in
        let* α2 : clap.util.id.Id.t := M.call (α0 α1) in
        M.alloc [ α2 ] in
      let* α4 : array clap.util.id.Id.t := M.read members in
      let* α5 : clap.builder.arg_group.ArgGroup.t :=
        M.call (clap.builder.arg_group.ArgGroup.t::["args"] α3 α4) in
      let* α6 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["group"] α0 α5) in
      M.alloc α6 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 :
          clap.builder.command.Command.t -> M clap.builder.command.Command.t :=
        ltac:(M.get_method (fun ℐ =>
          clap.derive.Subcommand.augment_subcommands
            (Self := coq_of_rust.Commands.t)
            (Trait := ℐ))) in
      let* α1 : clap.builder.command.Command.t := M.read __clap_app in
      let* α2 : clap.builder.command.Command.t := M.call (α0 α1) in
      M.alloc α2 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* α1 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["subcommand_required"] α0 true) in
      let* α2 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["arg_required_else_help"]
            α1
            true) in
      let* α3 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["subcommand_required"] α2 false) in
      let* α4 : clap.builder.command.Command.t :=
        M.call
          (clap.builder.command.Command.t::["arg_required_else_help"]
            α3
            false) in
      M.alloc α4 in
    let* __clap_app : M.Val clap.builder.command.Command.t :=
      let* α0 : clap.builder.command.Command.t := M.read __clap_app in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : ref str.t := M.read (mk_str "debug") in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["new"] α0) in
        let* α2 : ref str.t := M.read (mk_str "DEBUG") in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_name"] α1 α2) in
        let* α4 : M.Val clap.builder.action.ArgAction.t :=
          M.alloc clap.builder.action.ArgAction.Count in
        let* α5 : bool.t :=
          M.call
            (clap.builder.action.ArgAction.t::["takes_values"] (borrow α4)) in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["required"]
              α3
              (BinOp.Pure.and true α5)) in
        let* auto : M.Val (clap.builder.value_parser._AutoValueParser.t u8.t) :=
          let* α0 : clap.builder.value_parser._AutoValueParser.t u8.t :=
            M.call
              (clap.builder.value_parser._AutoValueParser.t u8.t)::["new"] in
          M.alloc α0 in
        let* α0 :
            (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              u8.t))))))))
              ->
              M _ :=
          ltac:(M.get_method (fun ℐ =>
            clap.builder.value_parser.via_prelude._ValueParserViaFactory.value_parser
              (Self :=
                ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (ref
                            (clap.builder.value_parser._AutoValueParser.t
                              u8.t)))))))
              (Trait := ℐ))) in
        let* α1 :
            M.Val (ref (clap.builder.value_parser._AutoValueParser.t u8.t)) :=
          M.alloc (borrow auto) in
        let* α2 :
            M.Val
              (ref (ref (clap.builder.value_parser._AutoValueParser.t u8.t))) :=
          M.alloc (borrow α1) in
        let* α3 :
            M.Val
              (ref
                (ref
                  (ref (clap.builder.value_parser._AutoValueParser.t u8.t)))) :=
          M.alloc (borrow α2) in
        let* α4 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (clap.builder.value_parser._AutoValueParser.t u8.t))))) :=
          M.alloc (borrow α3) in
        let* α5 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (clap.builder.value_parser._AutoValueParser.t
                          u8.t)))))) :=
          M.alloc (borrow α4) in
        let* α6 :
            M.Val
              (ref
                (ref
                  (ref
                    (ref
                      (ref
                        (ref
                          (clap.builder.value_parser._AutoValueParser.t
                            u8.t))))))) :=
          M.alloc (borrow α5) in
        let* α7 : clap.builder.value_parser.RangedI64ValueParser.t u8.t :=
          M.call (α0 (borrow α6)) in
        let* α7 :
            M.Val (clap.builder.value_parser.RangedI64ValueParser.t u8.t) :=
          M.alloc α7 in
        let* α8 : clap.builder.value_parser.RangedI64ValueParser.t u8.t :=
          M.read α7 in
        let* α9 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["value_parser"] α6 α8) in
        let* α10 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["action"]
              α9
              clap.builder.action.ArgAction.Count) in
        M.alloc α10 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : ref str.t :=
          M.read (mk_str "Turn debugging information on") in
        let* α2 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["help"] α0 α1) in
        let* α3 : clap.builder.arg.Arg.t :=
          M.call
            (clap.builder.arg.Arg.t::["long_help"]
              α2
              core.option.Option.None) in
        let* α4 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["short"] α3 "d"%char) in
        let* α5 : ref str.t := M.read (mk_str "debug") in
        let* α6 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["long"] α4 α5) in
        M.alloc α6 in
      let* arg : M.Val clap.builder.arg.Arg.t :=
        let* α0 : clap.builder.arg.Arg.t := M.read arg in
        let* α1 : clap.builder.arg.Arg.t :=
          M.call (clap.builder.arg.Arg.t::["required"] α0 false) in
        M.alloc α1 in
      let* α1 : clap.builder.arg.Arg.t := M.read arg in
      let* α2 : clap.builder.command.Command.t :=
        M.call (clap.builder.command.Command.t::["arg"] α0 α1) in
      M.alloc α2 in
    let* α0 : clap.builder.command.Command.t := M.read __clap_app in
    let* α1 : ref str.t := M.read (mk_str "0.1.0") in
    let* α2 : clap.builder.command.Command.t :=
      M.call (clap.builder.command.Command.t::["version"] α0 α1) in
    let* α3 : clap.builder.command.Command.t :=
      M.call
        (clap.builder.command.Command.t::["long_about"]
          α2
          core.option.Option.None) in
    let* α0 : M.Val clap.builder.command.Command.t := M.alloc α3 in
    M.read α0.
  
  Global Instance AssociatedFunction_augment_args_for_update :
    Notations.DoubleColon Self "augment_args_for_update" := {
    Notations.double_colon := augment_args_for_update;
  }.
  
  Global Instance ℐ : clap.derive.Args.Required.Trait Self := {
    clap.derive.Args.group_id := Datatypes.Some group_id;
    clap.derive.Args.augment_args := augment_args;
    clap.derive.Args.augment_args_for_update := augment_args_for_update;
  }.
End Impl_clap_derive_Args_for_coq_of_rust_Cli_t.
End Impl_clap_derive_Args_for_coq_of_rust_Cli_t.

(*
fn main() {
    use coq_of_rust_lib::core;
    let cli = Cli::parse();

    match cli.command {
        Commands::Translate(t) => {
            println!("Translating: {}", &t.path.display());
            core::run(core::CliOptions {
                path: t.path,
                output: t.output_path,
                axiomatize: t.axiomatize,
                axiomatize_public: t.axiomatize_public,
                generate_reorder: t.generate_reorder,
                configuration_file: t.configuration_file,
            });
            println!("Finished.");
        }
    }
}
*)
Definition main : M unit :=
  let* cli : M.Val coq_of_rust.Cli.t :=
    let* α0 : M coq_of_rust.Cli.t :=
      ltac:(M.get_method (fun ℐ =>
        clap.derive.Parser.parse (Self := coq_of_rust.Cli.t) (Trait := ℐ))) in
    let* α1 : coq_of_rust.Cli.t := M.call α0 in
    M.alloc α1 in
  let* α0 : M.Val unit :=
    match_operator
      (coq_of_rust.Cli.Get_command cli)
      [
        fun γ =>
          (let* α0 := M.read γ in
          match α0 with
          | coq_of_rust.Commands.Translate _ =>
            let γ0_0 := coq_of_rust.Commands.Get_Translate_0 γ in
            let* t := M.copy γ0_0 in
            let* _ : M.Val unit :=
              let* _ : M.Val unit :=
                let* α0 : ref str.t := M.read (mk_str "Translating: ") in
                let* α1 : ref str.t := M.read (mk_str "
") in
                let* α2 : M.Val (array (ref str.t)) := M.alloc [ α0; α1 ] in
                let* α3 : (ref std.path.PathBuf.t) -> M (ref _) :=
                  ltac:(M.get_method (fun ℐ =>
                    core.ops.deref.Deref.deref
                      (Self := std.path.PathBuf.t)
                      (Trait := ℐ))) in
                let* α4 : ref std.path.Path.t :=
                  M.call (α3 (borrow (coq_of_rust.Translate.Get_path t))) in
                let* α5 : std.path.Display.t :=
                  M.call (std.path.Path.t::["display"] α4) in
                let* α6 : M.Val std.path.Display.t := M.alloc α5 in
                let* α7 : M.Val (ref std.path.Display.t) :=
                  M.alloc (borrow α6) in
                let* α8 : core.fmt.rt.Argument.t :=
                  M.call
                    (core.fmt.rt.Argument.t::["new_display"] (borrow α7)) in
                let* α9 : M.Val (array core.fmt.rt.Argument.t) :=
                  M.alloc [ α8 ] in
                let* α10 : core.fmt.Arguments.t :=
                  M.call
                    (core.fmt.Arguments.t::["new_v1"]
                      (pointer_coercion "Unsize" (borrow α2))
                      (pointer_coercion "Unsize" (borrow α9))) in
                let* α11 : unit := M.call (std.io.stdio._print α10) in
                M.alloc α11 in
              M.alloc tt in
            let* _ : M.Val unit :=
              let* α0 : std.path.PathBuf.t :=
                M.read (coq_of_rust.Translate.Get_path t) in
              let* α1 : std.path.PathBuf.t :=
                M.read (coq_of_rust.Translate.Get_output_path t) in
              let* α2 : bool.t :=
                M.read (coq_of_rust.Translate.Get_axiomatize t) in
              let* α3 : bool.t :=
                M.read (coq_of_rust.Translate.Get_axiomatize_public t) in
              let* α4 : bool.t :=
                M.read (coq_of_rust.Translate.Get_generate_reorder t) in
              let* α5 : alloc.string.String.t :=
                M.read (coq_of_rust.Translate.Get_configuration_file t) in
              let* α6 : unit :=
                M.call
                  (coq_of_rust_lib.core.run
                    {|
                      coq_of_rust_lib.core.CliOptions.path := α0;
                      coq_of_rust_lib.core.CliOptions.output := α1;
                      coq_of_rust_lib.core.CliOptions.axiomatize := α2;
                      coq_of_rust_lib.core.CliOptions.axiomatize_public := α3;
                      coq_of_rust_lib.core.CliOptions.generate_reorder := α4;
                      coq_of_rust_lib.core.CliOptions.configuration_file := α5;
                    |}) in
              M.alloc α6 in
            let* _ : M.Val unit :=
              let* _ : M.Val unit :=
                let* α0 : ref str.t := M.read (mk_str "Finished.
") in
                let* α1 : M.Val (array (ref str.t)) := M.alloc [ α0 ] in
                let* α2 : core.fmt.Arguments.t :=
                  M.call
                    (core.fmt.Arguments.t::["new_const"]
                      (pointer_coercion "Unsize" (borrow α1))) in
                let* α3 : unit := M.call (std.io.stdio._print α2) in
                M.alloc α3 in
              M.alloc tt in
            M.alloc tt
          end) :
          M (M.Val unit)
      ] in
  M.read α0.
